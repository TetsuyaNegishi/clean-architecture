"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const typescript_1 = require("typescript");
const CodeHelper_1 = require("../helpers/CodeHelper");
const Position_1 = require("../models/Position");
const Range_1 = require("../models/Range");
const StepRegistry_1 = require("../models/StepRegistry");
const StepRegistryEntry_1 = require("../models/StepRegistryEntry");
const Util_1 = require("../utils/Util");
class StaticLoader extends CodeHelper_1.CodeHelper {
    loadImplementations() {
        this.loadFiles();
    }
    loadStepsFromText(file, text) {
        let source = typescript_1.createSourceFile(file, text, typescript_1.ScriptTarget.Latest);
        typescript_1.forEachChild(source, (childNode) => {
            if (typescript_1.isClassDeclaration(childNode)) {
                typescript_1.forEachChild(childNode, (node) => {
                    if (typescript_1.isMethodDeclaration(node) && this.hasStepDecorator(node)) {
                        this.processNode(node, file, source);
                    }
                });
            }
        });
    }
    reloadSteps(content, filePath) {
        StepRegistry_1.default.removeSteps(filePath);
        this.loadStepsFromText(filePath, content);
    }
    removeSteps(filePath) {
        StepRegistry_1.default.removeSteps(filePath);
    }
    loadFiles() {
        Util_1.Util.getListOfFiles().forEach((file) => {
            let text = Util_1.Util.readFile(file);
            this.loadStepsFromText(file, text);
        });
    }
    processNode(node, file, source) {
        let stepTexts = this.getStepTexts(node);
        for (let stepText of stepTexts) {
            let stepValue = stepText.replace(/(<.*?>)/g, "{}");
            StepRegistry_1.default.add(stepValue, new StepRegistryEntry_1.StepRegistryEntry(stepText, stepValue, file, undefined, this.getRange(node, source), stepTexts.length > 1));
        }
    }
    getRange(node, source) {
        let dec = node.decorators;
        let start = source.getLineAndCharacterOfPosition(dec[0].expression.pos);
        let end = source.getLineAndCharacterOfPosition(node.end);
        return new Range_1.Range(new Position_1.Position(start.line + 1, start.character), new Position_1.Position(end.line + 1, end.character));
    }
}
exports.StaticLoader = StaticLoader;
