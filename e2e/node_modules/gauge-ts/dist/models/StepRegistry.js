"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const assert_1 = require("assert");
class StepRegistry {
    constructor() {
        this._registry = new Map();
        this._continuOnFailureFuncs = new Map();
    }
    get(text) {
        return this._registry.get(text)[0];
    }
    isImplemented(text) {
        return this._registry.has(text);
    }
    hasMultipleImplementations(stepText) {
        return this._registry.has(stepText) &&
            this._registry.get(stepText).length > 1;
    }
    add(text, entry) {
        if (this._registry.has(text)) {
            this._registry.get(text).push(entry);
        }
        else {
            this._registry.set(text, [entry]);
        }
    }
    addContinueOnFailure(func, exceptions) {
        if (!exceptions)
            exceptions = [assert_1.AssertionError.name];
        this._continuOnFailureFuncs.set(func, exceptions);
    }
    getContinueOnFailureFuncs(func) {
        if (this._continuOnFailureFuncs.has(func))
            return this._continuOnFailureFuncs.get(func);
        return [];
    }
    getStepPositions(filePath) {
        let positions = new Array();
        this._registry.forEach((entries, step) => {
            entries.forEach((entry) => {
                if (entry.getFilePath() === filePath) {
                    positions.push({
                        stepValue: step,
                        span: entry.getRange()
                    });
                }
            });
        });
        return positions;
    }
    getStepTexts() {
        let steps = new Array();
        this._registry.forEach((v, k) => {
            steps = steps.concat(v[0].getStepText());
        });
        return steps;
    }
    isFileCached(filePath) {
        for (const kv of this._registry) {
            if (kv[1].some(i => i.getFilePath() === filePath))
                return true;
        }
        return false;
    }
    removeSteps(filePath) {
        let newReg = new Map();
        this._registry.forEach((entries, stepValue) => {
            let methods = entries.filter(entry => entry.getFilePath() !== filePath);
            if (methods.length > 0)
                newReg.set(stepValue, methods);
        });
        this._registry = newReg;
    }
    setInstanceForMethodsIn(file, instance) {
        this._registry.forEach((entries, _) => {
            entries.forEach((entry) => {
                if (entry.getFilePath() === file) {
                    entry.setInstance(instance);
                }
            });
        });
    }
    clear() {
        this._registry.clear();
        this._continuOnFailureFuncs.clear();
    }
}
exports.StepRegistry = StepRegistry;
const registry = new StepRegistry();
exports.default = registry;
