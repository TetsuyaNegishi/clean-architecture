"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const messages_1 = require("../gen/messages");
const ExecutionContext_1 = require("../public/context/ExecutionContext");
const Scenario_1 = require("../public/context/Scenario");
const Specification_1 = require("../public/context/Specification");
const StepInfo_1 = require("../public/context/StepInfo");
const Screenshot_1 = require("../screenshot/Screenshot");
const MessageStore_1 = require("../stores/MessageStore");
const ScreenshotStore_1 = require("../stores/ScreenshotStore");
const ExecutionProcessor_1 = require("./ExecutionProcessor");
class HookExecutionProcessor extends ExecutionProcessor_1.ExecutionProcessor {
    process(message) {
        return __awaiter(this, void 0, void 0, function* () {
            let res = yield this.executeHooks(message);
            return this.wrapInMessage(res, message);
        });
    }
    executeHooks(req) {
        return __awaiter(this, void 0, void 0, function* () {
            let start = Date.now();
            let context = this.getExecutionContext(this.getExecutionInfo(req));
            let hooks = this.getApplicableHooks(req);
            let result = new messages_1.gauge.messages.ProtoExecutionResult();
            result.failed = false;
            try {
                for (let hook of hooks) {
                    yield this.executeMethod(hook.getInstance(), hook.getMethod(), [context]);
                }
            }
            catch (error) {
                result.failed = true;
                result.recoverableError = false;
                result.errorMessage = error.message;
                result.stackTrace = error.stack;
                if (process.env.screenshot_on_failure !== "false") {
                    let s = yield Screenshot_1.Screenshot.capture();
                    result.failureScreenshotFile = s;
                }
            }
            result.executionTime = Date.now() - start;
            result.message = MessageStore_1.MessageStore.pendingMessages();
            result.screenshotFiles = ScreenshotStore_1.ScreenshotStore.pendingScreenshots();
            return result;
        });
    }
    getExecutionContext(info) {
        if (!info)
            return new ExecutionContext_1.ExecutionContext(null, null, null, null);
        let specInfo = info.currentSpec;
        let scenarioInfo = info.currentScenario;
        let stepInfo = info.currentStep;
        let trace = info.stacktrace;
        return new ExecutionContext_1.ExecutionContext(this.toSpec(specInfo), this.toScenario(scenarioInfo), this.toStepInfo(stepInfo), trace);
    }
    toSpec(specInfo) {
        if (!specInfo)
            return null;
        return new Specification_1.Specification(specInfo.name, specInfo.fileName, specInfo.isFailed, specInfo.tags);
    }
    toScenario(scenInfo) {
        if (!scenInfo)
            return null;
        return new Scenario_1.Scenario(scenInfo.name, scenInfo.isFailed, scenInfo.tags);
    }
    toStepInfo(stepInfo) {
        if (!stepInfo)
            return null;
        if (stepInfo.step) {
            let step = stepInfo.step;
            return new StepInfo_1.StepInfo(step.parsedStepText, step.actualStepText, stepInfo.isFailed, stepInfo.errorMessage, stepInfo.stackTrace);
        }
        return new StepInfo_1.StepInfo(null, null, stepInfo.isFailed, stepInfo.errorMessage, stepInfo.stackTrace);
    }
}
exports.HookExecutionProcessor = HookExecutionProcessor;
