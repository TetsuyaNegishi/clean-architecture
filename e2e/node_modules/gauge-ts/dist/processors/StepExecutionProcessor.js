"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const messages_1 = require("../gen/messages");
const StepRegistry_1 = require("../models/StepRegistry");
const Screenshot_1 = require("../screenshot/Screenshot");
const MessageStore_1 = require("../stores/MessageStore");
const ScreenshotStore_1 = require("../stores/ScreenshotStore");
const ExecutionProcessor_1 = require("./ExecutionProcessor");
class StepExecutionProcessor extends ExecutionProcessor_1.ExecutionProcessor {
    process(message) {
        return __awaiter(this, void 0, void 0, function* () {
            let req = message.executeStepRequest;
            if (!StepRegistry_1.default.isImplemented(req.parsedStepText))
                return Promise.resolve(this.executionError("Step Implementation not found", message));
            let result = yield this.execute(req);
            return this.wrapInMessage(result, message);
        });
    }
    execute(req) {
        return __awaiter(this, void 0, void 0, function* () {
            let start = Date.now();
            let result = new messages_1.gauge.messages.ProtoExecutionResult();
            result.failed = false;
            let mi = StepRegistry_1.default.get(req.parsedStepText);
            let params = req.parameters.map((item) => { return item.value ? item.value : item.table; });
            let method = mi.getMethod();
            try {
                if (method.length !== params.length) {
                    throw new Error(`Argument length mismatch for \`${req.actualStepText}\`.` +
                        ` Actual Count: [${method.length}], Expected Count: [${params.length}]`);
                }
                yield this.executeMethod(mi.getInstance(), method, params);
            }
            catch (error) {
                result.failed = true;
                let cofErrors = StepRegistry_1.default.getContinueOnFailureFuncs(method);
                if (cofErrors && cofErrors.includes(error.constructor.name)) {
                    result.recoverableError = true;
                }
                result.errorMessage = error.message;
                result.stackTrace = error.stack;
                if (process.env.screenshot_on_failure !== "false") {
                    let s = yield Screenshot_1.Screenshot.capture();
                    result.failureScreenshotFile = s;
                }
            }
            result.executionTime = Date.now() - start;
            result.message = MessageStore_1.MessageStore.pendingMessages();
            ;
            result.screenshotFiles = ScreenshotStore_1.ScreenshotStore.pendingScreenshots();
            return result;
        });
    }
    executionError(message, req) {
        var result = new messages_1.gauge.messages.ProtoExecutionResult();
        result.failed = true;
        result.recoverableError = false;
        result.executionTime = 0;
        result.errorMessage = message;
        return this.wrapInMessage(result, req);
    }
}
exports.StepExecutionProcessor = StepExecutionProcessor;
