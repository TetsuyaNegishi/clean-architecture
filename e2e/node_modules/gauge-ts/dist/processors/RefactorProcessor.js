"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const os_1 = require("os");
const typescript_1 = require("typescript");
const messages_1 = require("../gen/messages");
const CodeHelper_1 = require("../helpers/CodeHelper");
const StepRegistry_1 = require("../models/StepRegistry");
const Util_1 = require("../utils/Util");
class RefactorProcessor extends CodeHelper_1.CodeHelper {
    process(message) {
        return __awaiter(this, void 0, void 0, function* () {
            let req = message.refactorRequest;
            let oldStep = req.oldStepValue;
            let newStep = req.newStepValue;
            if (StepRegistry_1.default.hasMultipleImplementations(oldStep.stepValue)) {
                return this.wrapInMessage(message, new messages_1.gauge.messages.RefactorResponse({
                    success: false,
                    error: `Multiple Implementation found for ${oldStep.parameterizedStepValue}`
                }));
            }
            let positions = req.paramPositions.map((p) => {
                return new messages_1.gauge.messages.ParameterPosition({
                    newPosition: p.newPosition || 0,
                    oldPosition: p.oldPosition || 0
                });
            });
            return this.wrapInMessage(message, this.refactor(oldStep, newStep, positions, req.saveChanges));
        });
    }
    refactor(oldStep, newStep, paramPositions, saveChanges) {
        let respnse = new messages_1.gauge.messages.RefactorResponse();
        try {
            let info = StepRegistry_1.default.get(oldStep.stepValue);
            let filePath = info.getFilePath();
            let source = typescript_1.createSourceFile(filePath, Util_1.Util.readFile(filePath), typescript_1.ScriptTarget.Latest, false, typescript_1.ScriptKind.TS);
            let change1 = new messages_1.gauge.messages.FileChanges({ fileName: filePath, diffs: [] });
            let change2 = new messages_1.gauge.messages.FileChanges({ fileName: filePath, diffs: [] });
            typescript_1.forEachChild(source, (childNode) => {
                if (typescript_1.isClassDeclaration(childNode)) {
                    typescript_1.forEachChild(childNode, (node) => {
                        if (typescript_1.isMethodDeclaration(node) && this.hasStepDecorator(node) && this.hasStepText(node, info.getStepText())) {
                            change1.diffs.push(new messages_1.gauge.messages.TextDiff({ content: `"${newStep.parameterizedStepValue}"`, span: this.getStepTextRange(source, node) }));
                            this.updateStepText(node, newStep);
                            change2.diffs.push(new messages_1.gauge.messages.TextDiff({ span: this.createSpan(source, node.parameters) }));
                            let oldParams = node.parameters;
                            let newParams = new Array();
                            for (let p of paramPositions) {
                                if (p.oldPosition < 0) {
                                    let pName = this.getParamName(paramPositions.indexOf(p), oldParams, source);
                                    newParams.splice(p.newPosition, 0, typescript_1.createParameter(undefined, undefined, undefined, `${pName}: any`));
                                }
                                else {
                                    newParams.splice(p.newPosition, 0, oldParams[p.oldPosition]);
                                }
                            }
                            node.parameters = typescript_1.createNodeArray(newParams);
                            change2.diffs[0].content = newParams.map((p) => {
                                return this.printer.printNode(typescript_1.EmitHint.Unspecified, p, source);
                            }).join(', ');
                        }
                    });
                }
            });
            if (saveChanges)
                Util_1.Util.writeFile(filePath, this.printer.printFile(source));
            respnse.filesChanged = [filePath];
            respnse.fileChanges = [change1, change2];
            respnse.success = true;
        }
        catch (error) {
            respnse.error = error.message + os_1.EOL + error.stack;
            respnse.success = false;
        }
        return respnse;
    }
    updateStepText(node, newStep) {
        let dec = node.decorators;
        let stepDecExp = dec.filter(this.isStepDecorator)[0].expression;
        stepDecExp.arguments[0].text = newStep.parameterizedStepValue;
    }
    getParamName(index, params, source) {
        let name = `arg${index}`;
        let p = params.map((p) => { return this.printer.printNode(typescript_1.EmitHint.Unspecified, p, source); });
        return !p.includes(name) ? name : this.getParamName(index++, params, source);
    }
    getStepTextRange(source, node) {
        let dec = node.decorators;
        let stepDecExp = dec.filter(this.isStepDecorator)[0].expression;
        return this.createSpan(source, stepDecExp.arguments[0]);
    }
    createSpan(source, node) {
        let start = source.getLineAndCharacterOfPosition(node.pos);
        let end = source.getLineAndCharacterOfPosition(node.end);
        return new messages_1.gauge.messages.Span({
            start: start.line + 1,
            startChar: start.character,
            end: end.line + 1,
            endChar: end.character
        });
    }
    wrapInMessage(message, res) {
        return new messages_1.gauge.messages.Message({
            messageId: message.messageId,
            messageType: messages_1.gauge.messages.Message.MessageType.RefactorResponse,
            refactorResponse: res
        });
    }
}
exports.RefactorProcessor = RefactorProcessor;
