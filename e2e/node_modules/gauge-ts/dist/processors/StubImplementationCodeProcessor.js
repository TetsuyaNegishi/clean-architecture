"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const os_1 = require("os");
const path_1 = require("path");
const typescript_1 = require("typescript");
const messages_1 = require("../gen/messages");
const Util_1 = require("../utils/Util");
class StubImplementationCodeProcessor {
    process(message) {
        return __awaiter(this, void 0, void 0, function* () {
            let req = message.stubImplementationCodeRequest;
            let filePath = req.implementationFilePath;
            let content = req.codes.reduce((acc, cur) => { return acc + os_1.EOL + cur; });
            if (!Util_1.Util.exists(filePath)) {
                let filePath = Util_1.Util.getNewTSFileName(Util_1.Util.getImplDirs()[0]);
                let className = path_1.basename(filePath).replace(typescript_1.Extension.Ts, '');
                return this.wrapInMessage(message, filePath, this.diffForImplementationInNewClass(content, className));
            }
            return this.wrapInMessage(message, filePath, this.diffForImplementationInExistingClass(filePath, content));
        });
    }
    diffForImplementationInExistingClass(filePath, content) {
        let fileContent = Util_1.Util.readFile(filePath).toString().replace("\r\n", "\n");
        let source = typescript_1.createSourceFile(filePath, fileContent, typescript_1.ScriptTarget.Latest);
        let lastMethod = null;
        typescript_1.forEachChild(source, (childNode) => {
            if (typescript_1.isClassDeclaration(childNode)) {
                typescript_1.forEachChild(childNode, (node) => {
                    if (typescript_1.isMethodDeclaration(node)) {
                        lastMethod = node;
                    }
                });
            }
        });
        let pos = source.getLineAndCharacterOfPosition(lastMethod.end);
        let span = new messages_1.gauge.messages.Span({ start: pos.line + 1, end: pos.line + 1, startChar: 0, endChar: 0 });
        let textDiff = new messages_1.gauge.messages.TextDiff({ span: span, content: content.split(os_1.EOL).map((c) => { return '\t' + c; }).join(os_1.EOL) + os_1.EOL });
        return [textDiff];
    }
    wrapInMessage(message, filePath, diffs) {
        return new messages_1.gauge.messages.Message({
            messageId: message.messageId,
            messageType: messages_1.gauge.messages.Message.MessageType.FileDiff,
            fileDiff: new messages_1.gauge.messages.FileDiff({
                filePath: filePath,
                textDiffs: diffs
            })
        });
    }
    diffForImplementationInNewClass(content, className) {
        let span = new messages_1.gauge.messages.Span({
            start: 0,
            end: 0,
            startChar: 0,
            endChar: 0
        });
        let textDiff = new messages_1.gauge.messages.TextDiff({
            span: span,
            content: this.getContentForNewClass(content, className)
        });
        return [textDiff];
    }
    getContentForNewClass(content, className) {
        return `import { Step } from "gauge-ts";` + os_1.EOL +
            `export default class ${className} {` + os_1.EOL +
            `${content.split(os_1.EOL).map((c) => { return '\t' + c; }).join(os_1.EOL)}` + os_1.EOL +
            `}`;
    }
}
exports.StubImplementationCodeProcessor = StubImplementationCodeProcessor;
