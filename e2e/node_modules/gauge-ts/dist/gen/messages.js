/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/
"use strict";

var $protobuf = require("protobufjs/minimal");

// Common aliases
var $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;

// Exported root namespace
var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});

$root.gauge = (function() {

    /**
     * Namespace gauge.
     * @exports gauge
     * @namespace
     */
    var gauge = {};

    gauge.messages = (function() {

        /**
         * Namespace messages.
         * @memberof gauge
         * @namespace
         */
        var messages = {};

        messages.GetProjectRootRequest = (function() {

            /**
             * Properties of a GetProjectRootRequest.
             * @memberof gauge.messages
             * @interface IGetProjectRootRequest
             */

            /**
             * Constructs a new GetProjectRootRequest.
             * @memberof gauge.messages
             * @classdesc Request to get the Root Directory of the project
             * @implements IGetProjectRootRequest
             * @constructor
             * @param {gauge.messages.IGetProjectRootRequest=} [properties] Properties to set
             */
            function GetProjectRootRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new GetProjectRootRequest instance using the specified properties.
             * @function create
             * @memberof gauge.messages.GetProjectRootRequest
             * @static
             * @param {gauge.messages.IGetProjectRootRequest=} [properties] Properties to set
             * @returns {gauge.messages.GetProjectRootRequest} GetProjectRootRequest instance
             */
            GetProjectRootRequest.create = function create(properties) {
                return new GetProjectRootRequest(properties);
            };

            /**
             * Encodes the specified GetProjectRootRequest message. Does not implicitly {@link gauge.messages.GetProjectRootRequest.verify|verify} messages.
             * @function encode
             * @memberof gauge.messages.GetProjectRootRequest
             * @static
             * @param {gauge.messages.IGetProjectRootRequest} message GetProjectRootRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetProjectRootRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified GetProjectRootRequest message, length delimited. Does not implicitly {@link gauge.messages.GetProjectRootRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gauge.messages.GetProjectRootRequest
             * @static
             * @param {gauge.messages.IGetProjectRootRequest} message GetProjectRootRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetProjectRootRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetProjectRootRequest message from the specified reader or buffer.
             * @function decode
             * @memberof gauge.messages.GetProjectRootRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gauge.messages.GetProjectRootRequest} GetProjectRootRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetProjectRootRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gauge.messages.GetProjectRootRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetProjectRootRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gauge.messages.GetProjectRootRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gauge.messages.GetProjectRootRequest} GetProjectRootRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetProjectRootRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetProjectRootRequest message.
             * @function verify
             * @memberof gauge.messages.GetProjectRootRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetProjectRootRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a GetProjectRootRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gauge.messages.GetProjectRootRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gauge.messages.GetProjectRootRequest} GetProjectRootRequest
             */
            GetProjectRootRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.gauge.messages.GetProjectRootRequest)
                    return object;
                return new $root.gauge.messages.GetProjectRootRequest();
            };

            /**
             * Creates a plain object from a GetProjectRootRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gauge.messages.GetProjectRootRequest
             * @static
             * @param {gauge.messages.GetProjectRootRequest} message GetProjectRootRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetProjectRootRequest.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this GetProjectRootRequest to JSON.
             * @function toJSON
             * @memberof gauge.messages.GetProjectRootRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetProjectRootRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return GetProjectRootRequest;
        })();

        messages.GetProjectRootResponse = (function() {

            /**
             * Properties of a GetProjectRootResponse.
             * @memberof gauge.messages
             * @interface IGetProjectRootResponse
             * @property {string|null} [projectRoot] Holds the absolute path of the Project Root directory.
             */

            /**
             * Constructs a new GetProjectRootResponse.
             * @memberof gauge.messages
             * @classdesc Response of GetProjectRootRequest.
             * @implements IGetProjectRootResponse
             * @constructor
             * @param {gauge.messages.IGetProjectRootResponse=} [properties] Properties to set
             */
            function GetProjectRootResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Holds the absolute path of the Project Root directory.
             * @member {string} projectRoot
             * @memberof gauge.messages.GetProjectRootResponse
             * @instance
             */
            GetProjectRootResponse.prototype.projectRoot = "";

            /**
             * Creates a new GetProjectRootResponse instance using the specified properties.
             * @function create
             * @memberof gauge.messages.GetProjectRootResponse
             * @static
             * @param {gauge.messages.IGetProjectRootResponse=} [properties] Properties to set
             * @returns {gauge.messages.GetProjectRootResponse} GetProjectRootResponse instance
             */
            GetProjectRootResponse.create = function create(properties) {
                return new GetProjectRootResponse(properties);
            };

            /**
             * Encodes the specified GetProjectRootResponse message. Does not implicitly {@link gauge.messages.GetProjectRootResponse.verify|verify} messages.
             * @function encode
             * @memberof gauge.messages.GetProjectRootResponse
             * @static
             * @param {gauge.messages.IGetProjectRootResponse} message GetProjectRootResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetProjectRootResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.projectRoot != null && message.hasOwnProperty("projectRoot"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.projectRoot);
                return writer;
            };

            /**
             * Encodes the specified GetProjectRootResponse message, length delimited. Does not implicitly {@link gauge.messages.GetProjectRootResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gauge.messages.GetProjectRootResponse
             * @static
             * @param {gauge.messages.IGetProjectRootResponse} message GetProjectRootResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetProjectRootResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetProjectRootResponse message from the specified reader or buffer.
             * @function decode
             * @memberof gauge.messages.GetProjectRootResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gauge.messages.GetProjectRootResponse} GetProjectRootResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetProjectRootResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gauge.messages.GetProjectRootResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.projectRoot = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetProjectRootResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gauge.messages.GetProjectRootResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gauge.messages.GetProjectRootResponse} GetProjectRootResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetProjectRootResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetProjectRootResponse message.
             * @function verify
             * @memberof gauge.messages.GetProjectRootResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetProjectRootResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.projectRoot != null && message.hasOwnProperty("projectRoot"))
                    if (!$util.isString(message.projectRoot))
                        return "projectRoot: string expected";
                return null;
            };

            /**
             * Creates a GetProjectRootResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gauge.messages.GetProjectRootResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gauge.messages.GetProjectRootResponse} GetProjectRootResponse
             */
            GetProjectRootResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.gauge.messages.GetProjectRootResponse)
                    return object;
                var message = new $root.gauge.messages.GetProjectRootResponse();
                if (object.projectRoot != null)
                    message.projectRoot = String(object.projectRoot);
                return message;
            };

            /**
             * Creates a plain object from a GetProjectRootResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gauge.messages.GetProjectRootResponse
             * @static
             * @param {gauge.messages.GetProjectRootResponse} message GetProjectRootResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetProjectRootResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.projectRoot = "";
                if (message.projectRoot != null && message.hasOwnProperty("projectRoot"))
                    object.projectRoot = message.projectRoot;
                return object;
            };

            /**
             * Converts this GetProjectRootResponse to JSON.
             * @function toJSON
             * @memberof gauge.messages.GetProjectRootResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetProjectRootResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return GetProjectRootResponse;
        })();

        messages.GetInstallationRootRequest = (function() {

            /**
             * Properties of a GetInstallationRootRequest.
             * @memberof gauge.messages
             * @interface IGetInstallationRootRequest
             */

            /**
             * Constructs a new GetInstallationRootRequest.
             * @memberof gauge.messages
             * @classdesc Request to get the Root Directory of the Gauge installation
             * @implements IGetInstallationRootRequest
             * @constructor
             * @param {gauge.messages.IGetInstallationRootRequest=} [properties] Properties to set
             */
            function GetInstallationRootRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new GetInstallationRootRequest instance using the specified properties.
             * @function create
             * @memberof gauge.messages.GetInstallationRootRequest
             * @static
             * @param {gauge.messages.IGetInstallationRootRequest=} [properties] Properties to set
             * @returns {gauge.messages.GetInstallationRootRequest} GetInstallationRootRequest instance
             */
            GetInstallationRootRequest.create = function create(properties) {
                return new GetInstallationRootRequest(properties);
            };

            /**
             * Encodes the specified GetInstallationRootRequest message. Does not implicitly {@link gauge.messages.GetInstallationRootRequest.verify|verify} messages.
             * @function encode
             * @memberof gauge.messages.GetInstallationRootRequest
             * @static
             * @param {gauge.messages.IGetInstallationRootRequest} message GetInstallationRootRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetInstallationRootRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified GetInstallationRootRequest message, length delimited. Does not implicitly {@link gauge.messages.GetInstallationRootRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gauge.messages.GetInstallationRootRequest
             * @static
             * @param {gauge.messages.IGetInstallationRootRequest} message GetInstallationRootRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetInstallationRootRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetInstallationRootRequest message from the specified reader or buffer.
             * @function decode
             * @memberof gauge.messages.GetInstallationRootRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gauge.messages.GetInstallationRootRequest} GetInstallationRootRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetInstallationRootRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gauge.messages.GetInstallationRootRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetInstallationRootRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gauge.messages.GetInstallationRootRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gauge.messages.GetInstallationRootRequest} GetInstallationRootRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetInstallationRootRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetInstallationRootRequest message.
             * @function verify
             * @memberof gauge.messages.GetInstallationRootRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetInstallationRootRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a GetInstallationRootRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gauge.messages.GetInstallationRootRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gauge.messages.GetInstallationRootRequest} GetInstallationRootRequest
             */
            GetInstallationRootRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.gauge.messages.GetInstallationRootRequest)
                    return object;
                return new $root.gauge.messages.GetInstallationRootRequest();
            };

            /**
             * Creates a plain object from a GetInstallationRootRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gauge.messages.GetInstallationRootRequest
             * @static
             * @param {gauge.messages.GetInstallationRootRequest} message GetInstallationRootRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetInstallationRootRequest.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this GetInstallationRootRequest to JSON.
             * @function toJSON
             * @memberof gauge.messages.GetInstallationRootRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetInstallationRootRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return GetInstallationRootRequest;
        })();

        messages.GetInstallationRootResponse = (function() {

            /**
             * Properties of a GetInstallationRootResponse.
             * @memberof gauge.messages
             * @interface IGetInstallationRootResponse
             * @property {string|null} [installationRoot] Holds the absolute path of the Gauge installation directory
             */

            /**
             * Constructs a new GetInstallationRootResponse.
             * @memberof gauge.messages
             * @classdesc Response of GetInstallationRootRequest
             * @implements IGetInstallationRootResponse
             * @constructor
             * @param {gauge.messages.IGetInstallationRootResponse=} [properties] Properties to set
             */
            function GetInstallationRootResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Holds the absolute path of the Gauge installation directory
             * @member {string} installationRoot
             * @memberof gauge.messages.GetInstallationRootResponse
             * @instance
             */
            GetInstallationRootResponse.prototype.installationRoot = "";

            /**
             * Creates a new GetInstallationRootResponse instance using the specified properties.
             * @function create
             * @memberof gauge.messages.GetInstallationRootResponse
             * @static
             * @param {gauge.messages.IGetInstallationRootResponse=} [properties] Properties to set
             * @returns {gauge.messages.GetInstallationRootResponse} GetInstallationRootResponse instance
             */
            GetInstallationRootResponse.create = function create(properties) {
                return new GetInstallationRootResponse(properties);
            };

            /**
             * Encodes the specified GetInstallationRootResponse message. Does not implicitly {@link gauge.messages.GetInstallationRootResponse.verify|verify} messages.
             * @function encode
             * @memberof gauge.messages.GetInstallationRootResponse
             * @static
             * @param {gauge.messages.IGetInstallationRootResponse} message GetInstallationRootResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetInstallationRootResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.installationRoot != null && message.hasOwnProperty("installationRoot"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.installationRoot);
                return writer;
            };

            /**
             * Encodes the specified GetInstallationRootResponse message, length delimited. Does not implicitly {@link gauge.messages.GetInstallationRootResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gauge.messages.GetInstallationRootResponse
             * @static
             * @param {gauge.messages.IGetInstallationRootResponse} message GetInstallationRootResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetInstallationRootResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetInstallationRootResponse message from the specified reader or buffer.
             * @function decode
             * @memberof gauge.messages.GetInstallationRootResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gauge.messages.GetInstallationRootResponse} GetInstallationRootResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetInstallationRootResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gauge.messages.GetInstallationRootResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.installationRoot = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetInstallationRootResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gauge.messages.GetInstallationRootResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gauge.messages.GetInstallationRootResponse} GetInstallationRootResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetInstallationRootResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetInstallationRootResponse message.
             * @function verify
             * @memberof gauge.messages.GetInstallationRootResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetInstallationRootResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.installationRoot != null && message.hasOwnProperty("installationRoot"))
                    if (!$util.isString(message.installationRoot))
                        return "installationRoot: string expected";
                return null;
            };

            /**
             * Creates a GetInstallationRootResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gauge.messages.GetInstallationRootResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gauge.messages.GetInstallationRootResponse} GetInstallationRootResponse
             */
            GetInstallationRootResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.gauge.messages.GetInstallationRootResponse)
                    return object;
                var message = new $root.gauge.messages.GetInstallationRootResponse();
                if (object.installationRoot != null)
                    message.installationRoot = String(object.installationRoot);
                return message;
            };

            /**
             * Creates a plain object from a GetInstallationRootResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gauge.messages.GetInstallationRootResponse
             * @static
             * @param {gauge.messages.GetInstallationRootResponse} message GetInstallationRootResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetInstallationRootResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.installationRoot = "";
                if (message.installationRoot != null && message.hasOwnProperty("installationRoot"))
                    object.installationRoot = message.installationRoot;
                return object;
            };

            /**
             * Converts this GetInstallationRootResponse to JSON.
             * @function toJSON
             * @memberof gauge.messages.GetInstallationRootResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetInstallationRootResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return GetInstallationRootResponse;
        })();

        messages.GetAllStepsRequest = (function() {

            /**
             * Properties of a GetAllStepsRequest.
             * @memberof gauge.messages
             * @interface IGetAllStepsRequest
             */

            /**
             * Constructs a new GetAllStepsRequest.
             * @memberof gauge.messages
             * @classdesc Request to get all Steps in the project
             * @implements IGetAllStepsRequest
             * @constructor
             * @param {gauge.messages.IGetAllStepsRequest=} [properties] Properties to set
             */
            function GetAllStepsRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new GetAllStepsRequest instance using the specified properties.
             * @function create
             * @memberof gauge.messages.GetAllStepsRequest
             * @static
             * @param {gauge.messages.IGetAllStepsRequest=} [properties] Properties to set
             * @returns {gauge.messages.GetAllStepsRequest} GetAllStepsRequest instance
             */
            GetAllStepsRequest.create = function create(properties) {
                return new GetAllStepsRequest(properties);
            };

            /**
             * Encodes the specified GetAllStepsRequest message. Does not implicitly {@link gauge.messages.GetAllStepsRequest.verify|verify} messages.
             * @function encode
             * @memberof gauge.messages.GetAllStepsRequest
             * @static
             * @param {gauge.messages.IGetAllStepsRequest} message GetAllStepsRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetAllStepsRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified GetAllStepsRequest message, length delimited. Does not implicitly {@link gauge.messages.GetAllStepsRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gauge.messages.GetAllStepsRequest
             * @static
             * @param {gauge.messages.IGetAllStepsRequest} message GetAllStepsRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetAllStepsRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetAllStepsRequest message from the specified reader or buffer.
             * @function decode
             * @memberof gauge.messages.GetAllStepsRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gauge.messages.GetAllStepsRequest} GetAllStepsRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetAllStepsRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gauge.messages.GetAllStepsRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetAllStepsRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gauge.messages.GetAllStepsRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gauge.messages.GetAllStepsRequest} GetAllStepsRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetAllStepsRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetAllStepsRequest message.
             * @function verify
             * @memberof gauge.messages.GetAllStepsRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetAllStepsRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a GetAllStepsRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gauge.messages.GetAllStepsRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gauge.messages.GetAllStepsRequest} GetAllStepsRequest
             */
            GetAllStepsRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.gauge.messages.GetAllStepsRequest)
                    return object;
                return new $root.gauge.messages.GetAllStepsRequest();
            };

            /**
             * Creates a plain object from a GetAllStepsRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gauge.messages.GetAllStepsRequest
             * @static
             * @param {gauge.messages.GetAllStepsRequest} message GetAllStepsRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetAllStepsRequest.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this GetAllStepsRequest to JSON.
             * @function toJSON
             * @memberof gauge.messages.GetAllStepsRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetAllStepsRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return GetAllStepsRequest;
        })();

        messages.GetAllStepsResponse = (function() {

            /**
             * Properties of a GetAllStepsResponse.
             * @memberof gauge.messages
             * @interface IGetAllStepsResponse
             * @property {Array.<gauge.messages.IProtoStepValue>|null} [allSteps] Holds a collection of Steps that are defined in the project.
             */

            /**
             * Constructs a new GetAllStepsResponse.
             * @memberof gauge.messages
             * @classdesc Response to GetAllStepsRequest
             * @implements IGetAllStepsResponse
             * @constructor
             * @param {gauge.messages.IGetAllStepsResponse=} [properties] Properties to set
             */
            function GetAllStepsResponse(properties) {
                this.allSteps = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Holds a collection of Steps that are defined in the project.
             * @member {Array.<gauge.messages.IProtoStepValue>} allSteps
             * @memberof gauge.messages.GetAllStepsResponse
             * @instance
             */
            GetAllStepsResponse.prototype.allSteps = $util.emptyArray;

            /**
             * Creates a new GetAllStepsResponse instance using the specified properties.
             * @function create
             * @memberof gauge.messages.GetAllStepsResponse
             * @static
             * @param {gauge.messages.IGetAllStepsResponse=} [properties] Properties to set
             * @returns {gauge.messages.GetAllStepsResponse} GetAllStepsResponse instance
             */
            GetAllStepsResponse.create = function create(properties) {
                return new GetAllStepsResponse(properties);
            };

            /**
             * Encodes the specified GetAllStepsResponse message. Does not implicitly {@link gauge.messages.GetAllStepsResponse.verify|verify} messages.
             * @function encode
             * @memberof gauge.messages.GetAllStepsResponse
             * @static
             * @param {gauge.messages.IGetAllStepsResponse} message GetAllStepsResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetAllStepsResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.allSteps != null && message.allSteps.length)
                    for (var i = 0; i < message.allSteps.length; ++i)
                        $root.gauge.messages.ProtoStepValue.encode(message.allSteps[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified GetAllStepsResponse message, length delimited. Does not implicitly {@link gauge.messages.GetAllStepsResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gauge.messages.GetAllStepsResponse
             * @static
             * @param {gauge.messages.IGetAllStepsResponse} message GetAllStepsResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetAllStepsResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetAllStepsResponse message from the specified reader or buffer.
             * @function decode
             * @memberof gauge.messages.GetAllStepsResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gauge.messages.GetAllStepsResponse} GetAllStepsResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetAllStepsResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gauge.messages.GetAllStepsResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.allSteps && message.allSteps.length))
                            message.allSteps = [];
                        message.allSteps.push($root.gauge.messages.ProtoStepValue.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetAllStepsResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gauge.messages.GetAllStepsResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gauge.messages.GetAllStepsResponse} GetAllStepsResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetAllStepsResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetAllStepsResponse message.
             * @function verify
             * @memberof gauge.messages.GetAllStepsResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetAllStepsResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.allSteps != null && message.hasOwnProperty("allSteps")) {
                    if (!Array.isArray(message.allSteps))
                        return "allSteps: array expected";
                    for (var i = 0; i < message.allSteps.length; ++i) {
                        var error = $root.gauge.messages.ProtoStepValue.verify(message.allSteps[i]);
                        if (error)
                            return "allSteps." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a GetAllStepsResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gauge.messages.GetAllStepsResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gauge.messages.GetAllStepsResponse} GetAllStepsResponse
             */
            GetAllStepsResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.gauge.messages.GetAllStepsResponse)
                    return object;
                var message = new $root.gauge.messages.GetAllStepsResponse();
                if (object.allSteps) {
                    if (!Array.isArray(object.allSteps))
                        throw TypeError(".gauge.messages.GetAllStepsResponse.allSteps: array expected");
                    message.allSteps = [];
                    for (var i = 0; i < object.allSteps.length; ++i) {
                        if (typeof object.allSteps[i] !== "object")
                            throw TypeError(".gauge.messages.GetAllStepsResponse.allSteps: object expected");
                        message.allSteps[i] = $root.gauge.messages.ProtoStepValue.fromObject(object.allSteps[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a GetAllStepsResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gauge.messages.GetAllStepsResponse
             * @static
             * @param {gauge.messages.GetAllStepsResponse} message GetAllStepsResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetAllStepsResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.allSteps = [];
                if (message.allSteps && message.allSteps.length) {
                    object.allSteps = [];
                    for (var j = 0; j < message.allSteps.length; ++j)
                        object.allSteps[j] = $root.gauge.messages.ProtoStepValue.toObject(message.allSteps[j], options);
                }
                return object;
            };

            /**
             * Converts this GetAllStepsResponse to JSON.
             * @function toJSON
             * @memberof gauge.messages.GetAllStepsResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetAllStepsResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return GetAllStepsResponse;
        })();

        messages.SpecsRequest = (function() {

            /**
             * Properties of a SpecsRequest.
             * @memberof gauge.messages
             * @interface ISpecsRequest
             * @property {Array.<string>|null} [specs] SpecsRequest specs
             */

            /**
             * Constructs a new SpecsRequest.
             * @memberof gauge.messages
             * @classdesc Request to get all Specs in the project
             * @implements ISpecsRequest
             * @constructor
             * @param {gauge.messages.ISpecsRequest=} [properties] Properties to set
             */
            function SpecsRequest(properties) {
                this.specs = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SpecsRequest specs.
             * @member {Array.<string>} specs
             * @memberof gauge.messages.SpecsRequest
             * @instance
             */
            SpecsRequest.prototype.specs = $util.emptyArray;

            /**
             * Creates a new SpecsRequest instance using the specified properties.
             * @function create
             * @memberof gauge.messages.SpecsRequest
             * @static
             * @param {gauge.messages.ISpecsRequest=} [properties] Properties to set
             * @returns {gauge.messages.SpecsRequest} SpecsRequest instance
             */
            SpecsRequest.create = function create(properties) {
                return new SpecsRequest(properties);
            };

            /**
             * Encodes the specified SpecsRequest message. Does not implicitly {@link gauge.messages.SpecsRequest.verify|verify} messages.
             * @function encode
             * @memberof gauge.messages.SpecsRequest
             * @static
             * @param {gauge.messages.ISpecsRequest} message SpecsRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SpecsRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.specs != null && message.specs.length)
                    for (var i = 0; i < message.specs.length; ++i)
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.specs[i]);
                return writer;
            };

            /**
             * Encodes the specified SpecsRequest message, length delimited. Does not implicitly {@link gauge.messages.SpecsRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gauge.messages.SpecsRequest
             * @static
             * @param {gauge.messages.ISpecsRequest} message SpecsRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SpecsRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SpecsRequest message from the specified reader or buffer.
             * @function decode
             * @memberof gauge.messages.SpecsRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gauge.messages.SpecsRequest} SpecsRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SpecsRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gauge.messages.SpecsRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.specs && message.specs.length))
                            message.specs = [];
                        message.specs.push(reader.string());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SpecsRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gauge.messages.SpecsRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gauge.messages.SpecsRequest} SpecsRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SpecsRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SpecsRequest message.
             * @function verify
             * @memberof gauge.messages.SpecsRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SpecsRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.specs != null && message.hasOwnProperty("specs")) {
                    if (!Array.isArray(message.specs))
                        return "specs: array expected";
                    for (var i = 0; i < message.specs.length; ++i)
                        if (!$util.isString(message.specs[i]))
                            return "specs: string[] expected";
                }
                return null;
            };

            /**
             * Creates a SpecsRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gauge.messages.SpecsRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gauge.messages.SpecsRequest} SpecsRequest
             */
            SpecsRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.gauge.messages.SpecsRequest)
                    return object;
                var message = new $root.gauge.messages.SpecsRequest();
                if (object.specs) {
                    if (!Array.isArray(object.specs))
                        throw TypeError(".gauge.messages.SpecsRequest.specs: array expected");
                    message.specs = [];
                    for (var i = 0; i < object.specs.length; ++i)
                        message.specs[i] = String(object.specs[i]);
                }
                return message;
            };

            /**
             * Creates a plain object from a SpecsRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gauge.messages.SpecsRequest
             * @static
             * @param {gauge.messages.SpecsRequest} message SpecsRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SpecsRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.specs = [];
                if (message.specs && message.specs.length) {
                    object.specs = [];
                    for (var j = 0; j < message.specs.length; ++j)
                        object.specs[j] = message.specs[j];
                }
                return object;
            };

            /**
             * Converts this SpecsRequest to JSON.
             * @function toJSON
             * @memberof gauge.messages.SpecsRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SpecsRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return SpecsRequest;
        })();

        messages.SpecsResponse = (function() {

            /**
             * Properties of a SpecsResponse.
             * @memberof gauge.messages
             * @interface ISpecsResponse
             * @property {Array.<gauge.messages.SpecsResponse.ISpecDetail>|null} [details] Holds a collection of Spec details.
             */

            /**
             * Constructs a new SpecsResponse.
             * @memberof gauge.messages
             * @classdesc Response to GetAllSpecsRequest
             * @implements ISpecsResponse
             * @constructor
             * @param {gauge.messages.ISpecsResponse=} [properties] Properties to set
             */
            function SpecsResponse(properties) {
                this.details = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Holds a collection of Spec details.
             * @member {Array.<gauge.messages.SpecsResponse.ISpecDetail>} details
             * @memberof gauge.messages.SpecsResponse
             * @instance
             */
            SpecsResponse.prototype.details = $util.emptyArray;

            /**
             * Creates a new SpecsResponse instance using the specified properties.
             * @function create
             * @memberof gauge.messages.SpecsResponse
             * @static
             * @param {gauge.messages.ISpecsResponse=} [properties] Properties to set
             * @returns {gauge.messages.SpecsResponse} SpecsResponse instance
             */
            SpecsResponse.create = function create(properties) {
                return new SpecsResponse(properties);
            };

            /**
             * Encodes the specified SpecsResponse message. Does not implicitly {@link gauge.messages.SpecsResponse.verify|verify} messages.
             * @function encode
             * @memberof gauge.messages.SpecsResponse
             * @static
             * @param {gauge.messages.ISpecsResponse} message SpecsResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SpecsResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.details != null && message.details.length)
                    for (var i = 0; i < message.details.length; ++i)
                        $root.gauge.messages.SpecsResponse.SpecDetail.encode(message.details[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified SpecsResponse message, length delimited. Does not implicitly {@link gauge.messages.SpecsResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gauge.messages.SpecsResponse
             * @static
             * @param {gauge.messages.ISpecsResponse} message SpecsResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SpecsResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SpecsResponse message from the specified reader or buffer.
             * @function decode
             * @memberof gauge.messages.SpecsResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gauge.messages.SpecsResponse} SpecsResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SpecsResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gauge.messages.SpecsResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.details && message.details.length))
                            message.details = [];
                        message.details.push($root.gauge.messages.SpecsResponse.SpecDetail.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SpecsResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gauge.messages.SpecsResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gauge.messages.SpecsResponse} SpecsResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SpecsResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SpecsResponse message.
             * @function verify
             * @memberof gauge.messages.SpecsResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SpecsResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.details != null && message.hasOwnProperty("details")) {
                    if (!Array.isArray(message.details))
                        return "details: array expected";
                    for (var i = 0; i < message.details.length; ++i) {
                        var error = $root.gauge.messages.SpecsResponse.SpecDetail.verify(message.details[i]);
                        if (error)
                            return "details." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a SpecsResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gauge.messages.SpecsResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gauge.messages.SpecsResponse} SpecsResponse
             */
            SpecsResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.gauge.messages.SpecsResponse)
                    return object;
                var message = new $root.gauge.messages.SpecsResponse();
                if (object.details) {
                    if (!Array.isArray(object.details))
                        throw TypeError(".gauge.messages.SpecsResponse.details: array expected");
                    message.details = [];
                    for (var i = 0; i < object.details.length; ++i) {
                        if (typeof object.details[i] !== "object")
                            throw TypeError(".gauge.messages.SpecsResponse.details: object expected");
                        message.details[i] = $root.gauge.messages.SpecsResponse.SpecDetail.fromObject(object.details[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a SpecsResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gauge.messages.SpecsResponse
             * @static
             * @param {gauge.messages.SpecsResponse} message SpecsResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SpecsResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.details = [];
                if (message.details && message.details.length) {
                    object.details = [];
                    for (var j = 0; j < message.details.length; ++j)
                        object.details[j] = $root.gauge.messages.SpecsResponse.SpecDetail.toObject(message.details[j], options);
                }
                return object;
            };

            /**
             * Converts this SpecsResponse to JSON.
             * @function toJSON
             * @memberof gauge.messages.SpecsResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SpecsResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            SpecsResponse.SpecDetail = (function() {

                /**
                 * Properties of a SpecDetail.
                 * @memberof gauge.messages.SpecsResponse
                 * @interface ISpecDetail
                 * @property {gauge.messages.IProtoSpec|null} [spec] Holds a collection of Specs that are defined in the project.
                 * @property {Array.<gauge.messages.IError>|null} [parseErrors] Holds a collection of parse errors present in the above spec.
                 */

                /**
                 * Constructs a new SpecDetail.
                 * @memberof gauge.messages.SpecsResponse
                 * @classdesc Represents a SpecDetail.
                 * @implements ISpecDetail
                 * @constructor
                 * @param {gauge.messages.SpecsResponse.ISpecDetail=} [properties] Properties to set
                 */
                function SpecDetail(properties) {
                    this.parseErrors = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Holds a collection of Specs that are defined in the project.
                 * @member {gauge.messages.IProtoSpec|null|undefined} spec
                 * @memberof gauge.messages.SpecsResponse.SpecDetail
                 * @instance
                 */
                SpecDetail.prototype.spec = null;

                /**
                 * Holds a collection of parse errors present in the above spec.
                 * @member {Array.<gauge.messages.IError>} parseErrors
                 * @memberof gauge.messages.SpecsResponse.SpecDetail
                 * @instance
                 */
                SpecDetail.prototype.parseErrors = $util.emptyArray;

                /**
                 * Creates a new SpecDetail instance using the specified properties.
                 * @function create
                 * @memberof gauge.messages.SpecsResponse.SpecDetail
                 * @static
                 * @param {gauge.messages.SpecsResponse.ISpecDetail=} [properties] Properties to set
                 * @returns {gauge.messages.SpecsResponse.SpecDetail} SpecDetail instance
                 */
                SpecDetail.create = function create(properties) {
                    return new SpecDetail(properties);
                };

                /**
                 * Encodes the specified SpecDetail message. Does not implicitly {@link gauge.messages.SpecsResponse.SpecDetail.verify|verify} messages.
                 * @function encode
                 * @memberof gauge.messages.SpecsResponse.SpecDetail
                 * @static
                 * @param {gauge.messages.SpecsResponse.ISpecDetail} message SpecDetail message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SpecDetail.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.spec != null && message.hasOwnProperty("spec"))
                        $root.gauge.messages.ProtoSpec.encode(message.spec, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.parseErrors != null && message.parseErrors.length)
                        for (var i = 0; i < message.parseErrors.length; ++i)
                            $root.gauge.messages.Error.encode(message.parseErrors[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified SpecDetail message, length delimited. Does not implicitly {@link gauge.messages.SpecsResponse.SpecDetail.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof gauge.messages.SpecsResponse.SpecDetail
                 * @static
                 * @param {gauge.messages.SpecsResponse.ISpecDetail} message SpecDetail message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SpecDetail.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a SpecDetail message from the specified reader or buffer.
                 * @function decode
                 * @memberof gauge.messages.SpecsResponse.SpecDetail
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {gauge.messages.SpecsResponse.SpecDetail} SpecDetail
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SpecDetail.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gauge.messages.SpecsResponse.SpecDetail();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.spec = $root.gauge.messages.ProtoSpec.decode(reader, reader.uint32());
                            break;
                        case 2:
                            if (!(message.parseErrors && message.parseErrors.length))
                                message.parseErrors = [];
                            message.parseErrors.push($root.gauge.messages.Error.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a SpecDetail message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof gauge.messages.SpecsResponse.SpecDetail
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {gauge.messages.SpecsResponse.SpecDetail} SpecDetail
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SpecDetail.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a SpecDetail message.
                 * @function verify
                 * @memberof gauge.messages.SpecsResponse.SpecDetail
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                SpecDetail.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.spec != null && message.hasOwnProperty("spec")) {
                        var error = $root.gauge.messages.ProtoSpec.verify(message.spec);
                        if (error)
                            return "spec." + error;
                    }
                    if (message.parseErrors != null && message.hasOwnProperty("parseErrors")) {
                        if (!Array.isArray(message.parseErrors))
                            return "parseErrors: array expected";
                        for (var i = 0; i < message.parseErrors.length; ++i) {
                            var error = $root.gauge.messages.Error.verify(message.parseErrors[i]);
                            if (error)
                                return "parseErrors." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a SpecDetail message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof gauge.messages.SpecsResponse.SpecDetail
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {gauge.messages.SpecsResponse.SpecDetail} SpecDetail
                 */
                SpecDetail.fromObject = function fromObject(object) {
                    if (object instanceof $root.gauge.messages.SpecsResponse.SpecDetail)
                        return object;
                    var message = new $root.gauge.messages.SpecsResponse.SpecDetail();
                    if (object.spec != null) {
                        if (typeof object.spec !== "object")
                            throw TypeError(".gauge.messages.SpecsResponse.SpecDetail.spec: object expected");
                        message.spec = $root.gauge.messages.ProtoSpec.fromObject(object.spec);
                    }
                    if (object.parseErrors) {
                        if (!Array.isArray(object.parseErrors))
                            throw TypeError(".gauge.messages.SpecsResponse.SpecDetail.parseErrors: array expected");
                        message.parseErrors = [];
                        for (var i = 0; i < object.parseErrors.length; ++i) {
                            if (typeof object.parseErrors[i] !== "object")
                                throw TypeError(".gauge.messages.SpecsResponse.SpecDetail.parseErrors: object expected");
                            message.parseErrors[i] = $root.gauge.messages.Error.fromObject(object.parseErrors[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a SpecDetail message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof gauge.messages.SpecsResponse.SpecDetail
                 * @static
                 * @param {gauge.messages.SpecsResponse.SpecDetail} message SpecDetail
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                SpecDetail.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.parseErrors = [];
                    if (options.defaults)
                        object.spec = null;
                    if (message.spec != null && message.hasOwnProperty("spec"))
                        object.spec = $root.gauge.messages.ProtoSpec.toObject(message.spec, options);
                    if (message.parseErrors && message.parseErrors.length) {
                        object.parseErrors = [];
                        for (var j = 0; j < message.parseErrors.length; ++j)
                            object.parseErrors[j] = $root.gauge.messages.Error.toObject(message.parseErrors[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this SpecDetail to JSON.
                 * @function toJSON
                 * @memberof gauge.messages.SpecsResponse.SpecDetail
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                SpecDetail.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return SpecDetail;
            })();

            return SpecsResponse;
        })();

        messages.GetAllConceptsRequest = (function() {

            /**
             * Properties of a GetAllConceptsRequest.
             * @memberof gauge.messages
             * @interface IGetAllConceptsRequest
             */

            /**
             * Constructs a new GetAllConceptsRequest.
             * @memberof gauge.messages
             * @classdesc Request to get all Concepts in the project
             * @implements IGetAllConceptsRequest
             * @constructor
             * @param {gauge.messages.IGetAllConceptsRequest=} [properties] Properties to set
             */
            function GetAllConceptsRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new GetAllConceptsRequest instance using the specified properties.
             * @function create
             * @memberof gauge.messages.GetAllConceptsRequest
             * @static
             * @param {gauge.messages.IGetAllConceptsRequest=} [properties] Properties to set
             * @returns {gauge.messages.GetAllConceptsRequest} GetAllConceptsRequest instance
             */
            GetAllConceptsRequest.create = function create(properties) {
                return new GetAllConceptsRequest(properties);
            };

            /**
             * Encodes the specified GetAllConceptsRequest message. Does not implicitly {@link gauge.messages.GetAllConceptsRequest.verify|verify} messages.
             * @function encode
             * @memberof gauge.messages.GetAllConceptsRequest
             * @static
             * @param {gauge.messages.IGetAllConceptsRequest} message GetAllConceptsRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetAllConceptsRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified GetAllConceptsRequest message, length delimited. Does not implicitly {@link gauge.messages.GetAllConceptsRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gauge.messages.GetAllConceptsRequest
             * @static
             * @param {gauge.messages.IGetAllConceptsRequest} message GetAllConceptsRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetAllConceptsRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetAllConceptsRequest message from the specified reader or buffer.
             * @function decode
             * @memberof gauge.messages.GetAllConceptsRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gauge.messages.GetAllConceptsRequest} GetAllConceptsRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetAllConceptsRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gauge.messages.GetAllConceptsRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetAllConceptsRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gauge.messages.GetAllConceptsRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gauge.messages.GetAllConceptsRequest} GetAllConceptsRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetAllConceptsRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetAllConceptsRequest message.
             * @function verify
             * @memberof gauge.messages.GetAllConceptsRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetAllConceptsRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a GetAllConceptsRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gauge.messages.GetAllConceptsRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gauge.messages.GetAllConceptsRequest} GetAllConceptsRequest
             */
            GetAllConceptsRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.gauge.messages.GetAllConceptsRequest)
                    return object;
                return new $root.gauge.messages.GetAllConceptsRequest();
            };

            /**
             * Creates a plain object from a GetAllConceptsRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gauge.messages.GetAllConceptsRequest
             * @static
             * @param {gauge.messages.GetAllConceptsRequest} message GetAllConceptsRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetAllConceptsRequest.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this GetAllConceptsRequest to JSON.
             * @function toJSON
             * @memberof gauge.messages.GetAllConceptsRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetAllConceptsRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return GetAllConceptsRequest;
        })();

        messages.GetAllConceptsResponse = (function() {

            /**
             * Properties of a GetAllConceptsResponse.
             * @memberof gauge.messages
             * @interface IGetAllConceptsResponse
             * @property {Array.<gauge.messages.IConceptInfo>|null} [concepts] Holds a collection of Concepts that are defined in the project.
             */

            /**
             * Constructs a new GetAllConceptsResponse.
             * @memberof gauge.messages
             * @classdesc Response to GetAllConceptsResponse
             * @implements IGetAllConceptsResponse
             * @constructor
             * @param {gauge.messages.IGetAllConceptsResponse=} [properties] Properties to set
             */
            function GetAllConceptsResponse(properties) {
                this.concepts = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Holds a collection of Concepts that are defined in the project.
             * @member {Array.<gauge.messages.IConceptInfo>} concepts
             * @memberof gauge.messages.GetAllConceptsResponse
             * @instance
             */
            GetAllConceptsResponse.prototype.concepts = $util.emptyArray;

            /**
             * Creates a new GetAllConceptsResponse instance using the specified properties.
             * @function create
             * @memberof gauge.messages.GetAllConceptsResponse
             * @static
             * @param {gauge.messages.IGetAllConceptsResponse=} [properties] Properties to set
             * @returns {gauge.messages.GetAllConceptsResponse} GetAllConceptsResponse instance
             */
            GetAllConceptsResponse.create = function create(properties) {
                return new GetAllConceptsResponse(properties);
            };

            /**
             * Encodes the specified GetAllConceptsResponse message. Does not implicitly {@link gauge.messages.GetAllConceptsResponse.verify|verify} messages.
             * @function encode
             * @memberof gauge.messages.GetAllConceptsResponse
             * @static
             * @param {gauge.messages.IGetAllConceptsResponse} message GetAllConceptsResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetAllConceptsResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.concepts != null && message.concepts.length)
                    for (var i = 0; i < message.concepts.length; ++i)
                        $root.gauge.messages.ConceptInfo.encode(message.concepts[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified GetAllConceptsResponse message, length delimited. Does not implicitly {@link gauge.messages.GetAllConceptsResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gauge.messages.GetAllConceptsResponse
             * @static
             * @param {gauge.messages.IGetAllConceptsResponse} message GetAllConceptsResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetAllConceptsResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetAllConceptsResponse message from the specified reader or buffer.
             * @function decode
             * @memberof gauge.messages.GetAllConceptsResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gauge.messages.GetAllConceptsResponse} GetAllConceptsResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetAllConceptsResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gauge.messages.GetAllConceptsResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.concepts && message.concepts.length))
                            message.concepts = [];
                        message.concepts.push($root.gauge.messages.ConceptInfo.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetAllConceptsResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gauge.messages.GetAllConceptsResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gauge.messages.GetAllConceptsResponse} GetAllConceptsResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetAllConceptsResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetAllConceptsResponse message.
             * @function verify
             * @memberof gauge.messages.GetAllConceptsResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetAllConceptsResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.concepts != null && message.hasOwnProperty("concepts")) {
                    if (!Array.isArray(message.concepts))
                        return "concepts: array expected";
                    for (var i = 0; i < message.concepts.length; ++i) {
                        var error = $root.gauge.messages.ConceptInfo.verify(message.concepts[i]);
                        if (error)
                            return "concepts." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a GetAllConceptsResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gauge.messages.GetAllConceptsResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gauge.messages.GetAllConceptsResponse} GetAllConceptsResponse
             */
            GetAllConceptsResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.gauge.messages.GetAllConceptsResponse)
                    return object;
                var message = new $root.gauge.messages.GetAllConceptsResponse();
                if (object.concepts) {
                    if (!Array.isArray(object.concepts))
                        throw TypeError(".gauge.messages.GetAllConceptsResponse.concepts: array expected");
                    message.concepts = [];
                    for (var i = 0; i < object.concepts.length; ++i) {
                        if (typeof object.concepts[i] !== "object")
                            throw TypeError(".gauge.messages.GetAllConceptsResponse.concepts: object expected");
                        message.concepts[i] = $root.gauge.messages.ConceptInfo.fromObject(object.concepts[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a GetAllConceptsResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gauge.messages.GetAllConceptsResponse
             * @static
             * @param {gauge.messages.GetAllConceptsResponse} message GetAllConceptsResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetAllConceptsResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.concepts = [];
                if (message.concepts && message.concepts.length) {
                    object.concepts = [];
                    for (var j = 0; j < message.concepts.length; ++j)
                        object.concepts[j] = $root.gauge.messages.ConceptInfo.toObject(message.concepts[j], options);
                }
                return object;
            };

            /**
             * Converts this GetAllConceptsResponse to JSON.
             * @function toJSON
             * @memberof gauge.messages.GetAllConceptsResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetAllConceptsResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return GetAllConceptsResponse;
        })();

        messages.ConceptInfo = (function() {

            /**
             * Properties of a ConceptInfo.
             * @memberof gauge.messages
             * @interface IConceptInfo
             * @property {gauge.messages.IProtoStepValue|null} [stepValue] The text that defines a concept
             * @property {string|null} [filepath] The absolute path to the file that contains the Concept
             * @property {number|null} [lineNumber] The line number in the file where the concept is defined.
             */

            /**
             * Constructs a new ConceptInfo.
             * @memberof gauge.messages
             * @classdesc Details of a Concept
             * @implements IConceptInfo
             * @constructor
             * @param {gauge.messages.IConceptInfo=} [properties] Properties to set
             */
            function ConceptInfo(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * The text that defines a concept
             * @member {gauge.messages.IProtoStepValue|null|undefined} stepValue
             * @memberof gauge.messages.ConceptInfo
             * @instance
             */
            ConceptInfo.prototype.stepValue = null;

            /**
             * The absolute path to the file that contains the Concept
             * @member {string} filepath
             * @memberof gauge.messages.ConceptInfo
             * @instance
             */
            ConceptInfo.prototype.filepath = "";

            /**
             * The line number in the file where the concept is defined.
             * @member {number} lineNumber
             * @memberof gauge.messages.ConceptInfo
             * @instance
             */
            ConceptInfo.prototype.lineNumber = 0;

            /**
             * Creates a new ConceptInfo instance using the specified properties.
             * @function create
             * @memberof gauge.messages.ConceptInfo
             * @static
             * @param {gauge.messages.IConceptInfo=} [properties] Properties to set
             * @returns {gauge.messages.ConceptInfo} ConceptInfo instance
             */
            ConceptInfo.create = function create(properties) {
                return new ConceptInfo(properties);
            };

            /**
             * Encodes the specified ConceptInfo message. Does not implicitly {@link gauge.messages.ConceptInfo.verify|verify} messages.
             * @function encode
             * @memberof gauge.messages.ConceptInfo
             * @static
             * @param {gauge.messages.IConceptInfo} message ConceptInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ConceptInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.stepValue != null && message.hasOwnProperty("stepValue"))
                    $root.gauge.messages.ProtoStepValue.encode(message.stepValue, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.filepath != null && message.hasOwnProperty("filepath"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.filepath);
                if (message.lineNumber != null && message.hasOwnProperty("lineNumber"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.lineNumber);
                return writer;
            };

            /**
             * Encodes the specified ConceptInfo message, length delimited. Does not implicitly {@link gauge.messages.ConceptInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gauge.messages.ConceptInfo
             * @static
             * @param {gauge.messages.IConceptInfo} message ConceptInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ConceptInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ConceptInfo message from the specified reader or buffer.
             * @function decode
             * @memberof gauge.messages.ConceptInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gauge.messages.ConceptInfo} ConceptInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ConceptInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gauge.messages.ConceptInfo();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.stepValue = $root.gauge.messages.ProtoStepValue.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.filepath = reader.string();
                        break;
                    case 3:
                        message.lineNumber = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ConceptInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gauge.messages.ConceptInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gauge.messages.ConceptInfo} ConceptInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ConceptInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ConceptInfo message.
             * @function verify
             * @memberof gauge.messages.ConceptInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ConceptInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.stepValue != null && message.hasOwnProperty("stepValue")) {
                    var error = $root.gauge.messages.ProtoStepValue.verify(message.stepValue);
                    if (error)
                        return "stepValue." + error;
                }
                if (message.filepath != null && message.hasOwnProperty("filepath"))
                    if (!$util.isString(message.filepath))
                        return "filepath: string expected";
                if (message.lineNumber != null && message.hasOwnProperty("lineNumber"))
                    if (!$util.isInteger(message.lineNumber))
                        return "lineNumber: integer expected";
                return null;
            };

            /**
             * Creates a ConceptInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gauge.messages.ConceptInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gauge.messages.ConceptInfo} ConceptInfo
             */
            ConceptInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.gauge.messages.ConceptInfo)
                    return object;
                var message = new $root.gauge.messages.ConceptInfo();
                if (object.stepValue != null) {
                    if (typeof object.stepValue !== "object")
                        throw TypeError(".gauge.messages.ConceptInfo.stepValue: object expected");
                    message.stepValue = $root.gauge.messages.ProtoStepValue.fromObject(object.stepValue);
                }
                if (object.filepath != null)
                    message.filepath = String(object.filepath);
                if (object.lineNumber != null)
                    message.lineNumber = object.lineNumber | 0;
                return message;
            };

            /**
             * Creates a plain object from a ConceptInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gauge.messages.ConceptInfo
             * @static
             * @param {gauge.messages.ConceptInfo} message ConceptInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ConceptInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.stepValue = null;
                    object.filepath = "";
                    object.lineNumber = 0;
                }
                if (message.stepValue != null && message.hasOwnProperty("stepValue"))
                    object.stepValue = $root.gauge.messages.ProtoStepValue.toObject(message.stepValue, options);
                if (message.filepath != null && message.hasOwnProperty("filepath"))
                    object.filepath = message.filepath;
                if (message.lineNumber != null && message.hasOwnProperty("lineNumber"))
                    object.lineNumber = message.lineNumber;
                return object;
            };

            /**
             * Converts this ConceptInfo to JSON.
             * @function toJSON
             * @memberof gauge.messages.ConceptInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ConceptInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ConceptInfo;
        })();

        messages.GetStepValueRequest = (function() {

            /**
             * Properties of a GetStepValueRequest.
             * @memberof gauge.messages
             * @interface IGetStepValueRequest
             * @property {string|null} [stepText] The text of the Step.
             * @property {boolean|null} [hasInlineTable] Flag to indicate if the Step has an inline table.
             */

            /**
             * Constructs a new GetStepValueRequest.
             * @memberof gauge.messages
             * @classdesc Request to get a Step Value.
             * @implements IGetStepValueRequest
             * @constructor
             * @param {gauge.messages.IGetStepValueRequest=} [properties] Properties to set
             */
            function GetStepValueRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * The text of the Step.
             * @member {string} stepText
             * @memberof gauge.messages.GetStepValueRequest
             * @instance
             */
            GetStepValueRequest.prototype.stepText = "";

            /**
             * Flag to indicate if the Step has an inline table.
             * @member {boolean} hasInlineTable
             * @memberof gauge.messages.GetStepValueRequest
             * @instance
             */
            GetStepValueRequest.prototype.hasInlineTable = false;

            /**
             * Creates a new GetStepValueRequest instance using the specified properties.
             * @function create
             * @memberof gauge.messages.GetStepValueRequest
             * @static
             * @param {gauge.messages.IGetStepValueRequest=} [properties] Properties to set
             * @returns {gauge.messages.GetStepValueRequest} GetStepValueRequest instance
             */
            GetStepValueRequest.create = function create(properties) {
                return new GetStepValueRequest(properties);
            };

            /**
             * Encodes the specified GetStepValueRequest message. Does not implicitly {@link gauge.messages.GetStepValueRequest.verify|verify} messages.
             * @function encode
             * @memberof gauge.messages.GetStepValueRequest
             * @static
             * @param {gauge.messages.IGetStepValueRequest} message GetStepValueRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetStepValueRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.stepText != null && message.hasOwnProperty("stepText"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.stepText);
                if (message.hasInlineTable != null && message.hasOwnProperty("hasInlineTable"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.hasInlineTable);
                return writer;
            };

            /**
             * Encodes the specified GetStepValueRequest message, length delimited. Does not implicitly {@link gauge.messages.GetStepValueRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gauge.messages.GetStepValueRequest
             * @static
             * @param {gauge.messages.IGetStepValueRequest} message GetStepValueRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetStepValueRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetStepValueRequest message from the specified reader or buffer.
             * @function decode
             * @memberof gauge.messages.GetStepValueRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gauge.messages.GetStepValueRequest} GetStepValueRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetStepValueRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gauge.messages.GetStepValueRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.stepText = reader.string();
                        break;
                    case 2:
                        message.hasInlineTable = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetStepValueRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gauge.messages.GetStepValueRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gauge.messages.GetStepValueRequest} GetStepValueRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetStepValueRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetStepValueRequest message.
             * @function verify
             * @memberof gauge.messages.GetStepValueRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetStepValueRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.stepText != null && message.hasOwnProperty("stepText"))
                    if (!$util.isString(message.stepText))
                        return "stepText: string expected";
                if (message.hasInlineTable != null && message.hasOwnProperty("hasInlineTable"))
                    if (typeof message.hasInlineTable !== "boolean")
                        return "hasInlineTable: boolean expected";
                return null;
            };

            /**
             * Creates a GetStepValueRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gauge.messages.GetStepValueRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gauge.messages.GetStepValueRequest} GetStepValueRequest
             */
            GetStepValueRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.gauge.messages.GetStepValueRequest)
                    return object;
                var message = new $root.gauge.messages.GetStepValueRequest();
                if (object.stepText != null)
                    message.stepText = String(object.stepText);
                if (object.hasInlineTable != null)
                    message.hasInlineTable = Boolean(object.hasInlineTable);
                return message;
            };

            /**
             * Creates a plain object from a GetStepValueRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gauge.messages.GetStepValueRequest
             * @static
             * @param {gauge.messages.GetStepValueRequest} message GetStepValueRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetStepValueRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.stepText = "";
                    object.hasInlineTable = false;
                }
                if (message.stepText != null && message.hasOwnProperty("stepText"))
                    object.stepText = message.stepText;
                if (message.hasInlineTable != null && message.hasOwnProperty("hasInlineTable"))
                    object.hasInlineTable = message.hasInlineTable;
                return object;
            };

            /**
             * Converts this GetStepValueRequest to JSON.
             * @function toJSON
             * @memberof gauge.messages.GetStepValueRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetStepValueRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return GetStepValueRequest;
        })();

        messages.GetStepValueResponse = (function() {

            /**
             * Properties of a GetStepValueResponse.
             * @memberof gauge.messages
             * @interface IGetStepValueResponse
             * @property {gauge.messages.IProtoStepValue|null} [stepValue] The Step corresponding to the request provided.
             */

            /**
             * Constructs a new GetStepValueResponse.
             * @memberof gauge.messages
             * @classdesc Response to GetStepValueRequest
             * @implements IGetStepValueResponse
             * @constructor
             * @param {gauge.messages.IGetStepValueResponse=} [properties] Properties to set
             */
            function GetStepValueResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * The Step corresponding to the request provided.
             * @member {gauge.messages.IProtoStepValue|null|undefined} stepValue
             * @memberof gauge.messages.GetStepValueResponse
             * @instance
             */
            GetStepValueResponse.prototype.stepValue = null;

            /**
             * Creates a new GetStepValueResponse instance using the specified properties.
             * @function create
             * @memberof gauge.messages.GetStepValueResponse
             * @static
             * @param {gauge.messages.IGetStepValueResponse=} [properties] Properties to set
             * @returns {gauge.messages.GetStepValueResponse} GetStepValueResponse instance
             */
            GetStepValueResponse.create = function create(properties) {
                return new GetStepValueResponse(properties);
            };

            /**
             * Encodes the specified GetStepValueResponse message. Does not implicitly {@link gauge.messages.GetStepValueResponse.verify|verify} messages.
             * @function encode
             * @memberof gauge.messages.GetStepValueResponse
             * @static
             * @param {gauge.messages.IGetStepValueResponse} message GetStepValueResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetStepValueResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.stepValue != null && message.hasOwnProperty("stepValue"))
                    $root.gauge.messages.ProtoStepValue.encode(message.stepValue, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified GetStepValueResponse message, length delimited. Does not implicitly {@link gauge.messages.GetStepValueResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gauge.messages.GetStepValueResponse
             * @static
             * @param {gauge.messages.IGetStepValueResponse} message GetStepValueResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetStepValueResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetStepValueResponse message from the specified reader or buffer.
             * @function decode
             * @memberof gauge.messages.GetStepValueResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gauge.messages.GetStepValueResponse} GetStepValueResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetStepValueResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gauge.messages.GetStepValueResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.stepValue = $root.gauge.messages.ProtoStepValue.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetStepValueResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gauge.messages.GetStepValueResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gauge.messages.GetStepValueResponse} GetStepValueResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetStepValueResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetStepValueResponse message.
             * @function verify
             * @memberof gauge.messages.GetStepValueResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetStepValueResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.stepValue != null && message.hasOwnProperty("stepValue")) {
                    var error = $root.gauge.messages.ProtoStepValue.verify(message.stepValue);
                    if (error)
                        return "stepValue." + error;
                }
                return null;
            };

            /**
             * Creates a GetStepValueResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gauge.messages.GetStepValueResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gauge.messages.GetStepValueResponse} GetStepValueResponse
             */
            GetStepValueResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.gauge.messages.GetStepValueResponse)
                    return object;
                var message = new $root.gauge.messages.GetStepValueResponse();
                if (object.stepValue != null) {
                    if (typeof object.stepValue !== "object")
                        throw TypeError(".gauge.messages.GetStepValueResponse.stepValue: object expected");
                    message.stepValue = $root.gauge.messages.ProtoStepValue.fromObject(object.stepValue);
                }
                return message;
            };

            /**
             * Creates a plain object from a GetStepValueResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gauge.messages.GetStepValueResponse
             * @static
             * @param {gauge.messages.GetStepValueResponse} message GetStepValueResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetStepValueResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.stepValue = null;
                if (message.stepValue != null && message.hasOwnProperty("stepValue"))
                    object.stepValue = $root.gauge.messages.ProtoStepValue.toObject(message.stepValue, options);
                return object;
            };

            /**
             * Converts this GetStepValueResponse to JSON.
             * @function toJSON
             * @memberof gauge.messages.GetStepValueResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetStepValueResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return GetStepValueResponse;
        })();

        messages.GetLanguagePluginLibPathRequest = (function() {

            /**
             * Properties of a GetLanguagePluginLibPathRequest.
             * @memberof gauge.messages
             * @interface IGetLanguagePluginLibPathRequest
             * @property {string|null} [language] The language to locate the lib directory for.
             */

            /**
             * Constructs a new GetLanguagePluginLibPathRequest.
             * @memberof gauge.messages
             * @classdesc Request to get the location of language plugin's Lib directory
             * @implements IGetLanguagePluginLibPathRequest
             * @constructor
             * @param {gauge.messages.IGetLanguagePluginLibPathRequest=} [properties] Properties to set
             */
            function GetLanguagePluginLibPathRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * The language to locate the lib directory for.
             * @member {string} language
             * @memberof gauge.messages.GetLanguagePluginLibPathRequest
             * @instance
             */
            GetLanguagePluginLibPathRequest.prototype.language = "";

            /**
             * Creates a new GetLanguagePluginLibPathRequest instance using the specified properties.
             * @function create
             * @memberof gauge.messages.GetLanguagePluginLibPathRequest
             * @static
             * @param {gauge.messages.IGetLanguagePluginLibPathRequest=} [properties] Properties to set
             * @returns {gauge.messages.GetLanguagePluginLibPathRequest} GetLanguagePluginLibPathRequest instance
             */
            GetLanguagePluginLibPathRequest.create = function create(properties) {
                return new GetLanguagePluginLibPathRequest(properties);
            };

            /**
             * Encodes the specified GetLanguagePluginLibPathRequest message. Does not implicitly {@link gauge.messages.GetLanguagePluginLibPathRequest.verify|verify} messages.
             * @function encode
             * @memberof gauge.messages.GetLanguagePluginLibPathRequest
             * @static
             * @param {gauge.messages.IGetLanguagePluginLibPathRequest} message GetLanguagePluginLibPathRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetLanguagePluginLibPathRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.language != null && message.hasOwnProperty("language"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.language);
                return writer;
            };

            /**
             * Encodes the specified GetLanguagePluginLibPathRequest message, length delimited. Does not implicitly {@link gauge.messages.GetLanguagePluginLibPathRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gauge.messages.GetLanguagePluginLibPathRequest
             * @static
             * @param {gauge.messages.IGetLanguagePluginLibPathRequest} message GetLanguagePluginLibPathRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetLanguagePluginLibPathRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetLanguagePluginLibPathRequest message from the specified reader or buffer.
             * @function decode
             * @memberof gauge.messages.GetLanguagePluginLibPathRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gauge.messages.GetLanguagePluginLibPathRequest} GetLanguagePluginLibPathRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetLanguagePluginLibPathRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gauge.messages.GetLanguagePluginLibPathRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.language = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetLanguagePluginLibPathRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gauge.messages.GetLanguagePluginLibPathRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gauge.messages.GetLanguagePluginLibPathRequest} GetLanguagePluginLibPathRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetLanguagePluginLibPathRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetLanguagePluginLibPathRequest message.
             * @function verify
             * @memberof gauge.messages.GetLanguagePluginLibPathRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetLanguagePluginLibPathRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.language != null && message.hasOwnProperty("language"))
                    if (!$util.isString(message.language))
                        return "language: string expected";
                return null;
            };

            /**
             * Creates a GetLanguagePluginLibPathRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gauge.messages.GetLanguagePluginLibPathRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gauge.messages.GetLanguagePluginLibPathRequest} GetLanguagePluginLibPathRequest
             */
            GetLanguagePluginLibPathRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.gauge.messages.GetLanguagePluginLibPathRequest)
                    return object;
                var message = new $root.gauge.messages.GetLanguagePluginLibPathRequest();
                if (object.language != null)
                    message.language = String(object.language);
                return message;
            };

            /**
             * Creates a plain object from a GetLanguagePluginLibPathRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gauge.messages.GetLanguagePluginLibPathRequest
             * @static
             * @param {gauge.messages.GetLanguagePluginLibPathRequest} message GetLanguagePluginLibPathRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetLanguagePluginLibPathRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.language = "";
                if (message.language != null && message.hasOwnProperty("language"))
                    object.language = message.language;
                return object;
            };

            /**
             * Converts this GetLanguagePluginLibPathRequest to JSON.
             * @function toJSON
             * @memberof gauge.messages.GetLanguagePluginLibPathRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetLanguagePluginLibPathRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return GetLanguagePluginLibPathRequest;
        })();

        messages.GetLanguagePluginLibPathResponse = (function() {

            /**
             * Properties of a GetLanguagePluginLibPathResponse.
             * @memberof gauge.messages
             * @interface IGetLanguagePluginLibPathResponse
             * @property {string|null} [path] Absolute path to the Lib directory of the language.
             */

            /**
             * Constructs a new GetLanguagePluginLibPathResponse.
             * @memberof gauge.messages
             * @classdesc Response to GetLanguagePluginLibPathRequest
             * @implements IGetLanguagePluginLibPathResponse
             * @constructor
             * @param {gauge.messages.IGetLanguagePluginLibPathResponse=} [properties] Properties to set
             */
            function GetLanguagePluginLibPathResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Absolute path to the Lib directory of the language.
             * @member {string} path
             * @memberof gauge.messages.GetLanguagePluginLibPathResponse
             * @instance
             */
            GetLanguagePluginLibPathResponse.prototype.path = "";

            /**
             * Creates a new GetLanguagePluginLibPathResponse instance using the specified properties.
             * @function create
             * @memberof gauge.messages.GetLanguagePluginLibPathResponse
             * @static
             * @param {gauge.messages.IGetLanguagePluginLibPathResponse=} [properties] Properties to set
             * @returns {gauge.messages.GetLanguagePluginLibPathResponse} GetLanguagePluginLibPathResponse instance
             */
            GetLanguagePluginLibPathResponse.create = function create(properties) {
                return new GetLanguagePluginLibPathResponse(properties);
            };

            /**
             * Encodes the specified GetLanguagePluginLibPathResponse message. Does not implicitly {@link gauge.messages.GetLanguagePluginLibPathResponse.verify|verify} messages.
             * @function encode
             * @memberof gauge.messages.GetLanguagePluginLibPathResponse
             * @static
             * @param {gauge.messages.IGetLanguagePluginLibPathResponse} message GetLanguagePluginLibPathResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetLanguagePluginLibPathResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.path != null && message.hasOwnProperty("path"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.path);
                return writer;
            };

            /**
             * Encodes the specified GetLanguagePluginLibPathResponse message, length delimited. Does not implicitly {@link gauge.messages.GetLanguagePluginLibPathResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gauge.messages.GetLanguagePluginLibPathResponse
             * @static
             * @param {gauge.messages.IGetLanguagePluginLibPathResponse} message GetLanguagePluginLibPathResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetLanguagePluginLibPathResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetLanguagePluginLibPathResponse message from the specified reader or buffer.
             * @function decode
             * @memberof gauge.messages.GetLanguagePluginLibPathResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gauge.messages.GetLanguagePluginLibPathResponse} GetLanguagePluginLibPathResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetLanguagePluginLibPathResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gauge.messages.GetLanguagePluginLibPathResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.path = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetLanguagePluginLibPathResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gauge.messages.GetLanguagePluginLibPathResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gauge.messages.GetLanguagePluginLibPathResponse} GetLanguagePluginLibPathResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetLanguagePluginLibPathResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetLanguagePluginLibPathResponse message.
             * @function verify
             * @memberof gauge.messages.GetLanguagePluginLibPathResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetLanguagePluginLibPathResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.path != null && message.hasOwnProperty("path"))
                    if (!$util.isString(message.path))
                        return "path: string expected";
                return null;
            };

            /**
             * Creates a GetLanguagePluginLibPathResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gauge.messages.GetLanguagePluginLibPathResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gauge.messages.GetLanguagePluginLibPathResponse} GetLanguagePluginLibPathResponse
             */
            GetLanguagePluginLibPathResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.gauge.messages.GetLanguagePluginLibPathResponse)
                    return object;
                var message = new $root.gauge.messages.GetLanguagePluginLibPathResponse();
                if (object.path != null)
                    message.path = String(object.path);
                return message;
            };

            /**
             * Creates a plain object from a GetLanguagePluginLibPathResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gauge.messages.GetLanguagePluginLibPathResponse
             * @static
             * @param {gauge.messages.GetLanguagePluginLibPathResponse} message GetLanguagePluginLibPathResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetLanguagePluginLibPathResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.path = "";
                if (message.path != null && message.hasOwnProperty("path"))
                    object.path = message.path;
                return object;
            };

            /**
             * Converts this GetLanguagePluginLibPathResponse to JSON.
             * @function toJSON
             * @memberof gauge.messages.GetLanguagePluginLibPathResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetLanguagePluginLibPathResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return GetLanguagePluginLibPathResponse;
        })();

        messages.ErrorResponse = (function() {

            /**
             * Properties of an ErrorResponse.
             * @memberof gauge.messages
             * @interface IErrorResponse
             * @property {string|null} [error] Actual error message
             */

            /**
             * Constructs a new ErrorResponse.
             * @memberof gauge.messages
             * @classdesc A generic failure response
             * @implements IErrorResponse
             * @constructor
             * @param {gauge.messages.IErrorResponse=} [properties] Properties to set
             */
            function ErrorResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Actual error message
             * @member {string} error
             * @memberof gauge.messages.ErrorResponse
             * @instance
             */
            ErrorResponse.prototype.error = "";

            /**
             * Creates a new ErrorResponse instance using the specified properties.
             * @function create
             * @memberof gauge.messages.ErrorResponse
             * @static
             * @param {gauge.messages.IErrorResponse=} [properties] Properties to set
             * @returns {gauge.messages.ErrorResponse} ErrorResponse instance
             */
            ErrorResponse.create = function create(properties) {
                return new ErrorResponse(properties);
            };

            /**
             * Encodes the specified ErrorResponse message. Does not implicitly {@link gauge.messages.ErrorResponse.verify|verify} messages.
             * @function encode
             * @memberof gauge.messages.ErrorResponse
             * @static
             * @param {gauge.messages.IErrorResponse} message ErrorResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ErrorResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.error != null && message.hasOwnProperty("error"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.error);
                return writer;
            };

            /**
             * Encodes the specified ErrorResponse message, length delimited. Does not implicitly {@link gauge.messages.ErrorResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gauge.messages.ErrorResponse
             * @static
             * @param {gauge.messages.IErrorResponse} message ErrorResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ErrorResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an ErrorResponse message from the specified reader or buffer.
             * @function decode
             * @memberof gauge.messages.ErrorResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gauge.messages.ErrorResponse} ErrorResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ErrorResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gauge.messages.ErrorResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.error = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an ErrorResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gauge.messages.ErrorResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gauge.messages.ErrorResponse} ErrorResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ErrorResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an ErrorResponse message.
             * @function verify
             * @memberof gauge.messages.ErrorResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ErrorResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.error != null && message.hasOwnProperty("error"))
                    if (!$util.isString(message.error))
                        return "error: string expected";
                return null;
            };

            /**
             * Creates an ErrorResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gauge.messages.ErrorResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gauge.messages.ErrorResponse} ErrorResponse
             */
            ErrorResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.gauge.messages.ErrorResponse)
                    return object;
                var message = new $root.gauge.messages.ErrorResponse();
                if (object.error != null)
                    message.error = String(object.error);
                return message;
            };

            /**
             * Creates a plain object from an ErrorResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gauge.messages.ErrorResponse
             * @static
             * @param {gauge.messages.ErrorResponse} message ErrorResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ErrorResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.error = "";
                if (message.error != null && message.hasOwnProperty("error"))
                    object.error = message.error;
                return object;
            };

            /**
             * Converts this ErrorResponse to JSON.
             * @function toJSON
             * @memberof gauge.messages.ErrorResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ErrorResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ErrorResponse;
        })();

        messages.PerformRefactoringRequest = (function() {

            /**
             * Properties of a PerformRefactoringRequest.
             * @memberof gauge.messages
             * @interface IPerformRefactoringRequest
             * @property {string|null} [oldStep] Step to refactor
             * @property {string|null} [newStep] Change to be made
             */

            /**
             * Constructs a new PerformRefactoringRequest.
             * @memberof gauge.messages
             * @classdesc Request to perform a Refactor
             * @implements IPerformRefactoringRequest
             * @constructor
             * @param {gauge.messages.IPerformRefactoringRequest=} [properties] Properties to set
             */
            function PerformRefactoringRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Step to refactor
             * @member {string} oldStep
             * @memberof gauge.messages.PerformRefactoringRequest
             * @instance
             */
            PerformRefactoringRequest.prototype.oldStep = "";

            /**
             * Change to be made
             * @member {string} newStep
             * @memberof gauge.messages.PerformRefactoringRequest
             * @instance
             */
            PerformRefactoringRequest.prototype.newStep = "";

            /**
             * Creates a new PerformRefactoringRequest instance using the specified properties.
             * @function create
             * @memberof gauge.messages.PerformRefactoringRequest
             * @static
             * @param {gauge.messages.IPerformRefactoringRequest=} [properties] Properties to set
             * @returns {gauge.messages.PerformRefactoringRequest} PerformRefactoringRequest instance
             */
            PerformRefactoringRequest.create = function create(properties) {
                return new PerformRefactoringRequest(properties);
            };

            /**
             * Encodes the specified PerformRefactoringRequest message. Does not implicitly {@link gauge.messages.PerformRefactoringRequest.verify|verify} messages.
             * @function encode
             * @memberof gauge.messages.PerformRefactoringRequest
             * @static
             * @param {gauge.messages.IPerformRefactoringRequest} message PerformRefactoringRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PerformRefactoringRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.oldStep != null && message.hasOwnProperty("oldStep"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.oldStep);
                if (message.newStep != null && message.hasOwnProperty("newStep"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.newStep);
                return writer;
            };

            /**
             * Encodes the specified PerformRefactoringRequest message, length delimited. Does not implicitly {@link gauge.messages.PerformRefactoringRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gauge.messages.PerformRefactoringRequest
             * @static
             * @param {gauge.messages.IPerformRefactoringRequest} message PerformRefactoringRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PerformRefactoringRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PerformRefactoringRequest message from the specified reader or buffer.
             * @function decode
             * @memberof gauge.messages.PerformRefactoringRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gauge.messages.PerformRefactoringRequest} PerformRefactoringRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PerformRefactoringRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gauge.messages.PerformRefactoringRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.oldStep = reader.string();
                        break;
                    case 2:
                        message.newStep = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a PerformRefactoringRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gauge.messages.PerformRefactoringRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gauge.messages.PerformRefactoringRequest} PerformRefactoringRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PerformRefactoringRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PerformRefactoringRequest message.
             * @function verify
             * @memberof gauge.messages.PerformRefactoringRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PerformRefactoringRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.oldStep != null && message.hasOwnProperty("oldStep"))
                    if (!$util.isString(message.oldStep))
                        return "oldStep: string expected";
                if (message.newStep != null && message.hasOwnProperty("newStep"))
                    if (!$util.isString(message.newStep))
                        return "newStep: string expected";
                return null;
            };

            /**
             * Creates a PerformRefactoringRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gauge.messages.PerformRefactoringRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gauge.messages.PerformRefactoringRequest} PerformRefactoringRequest
             */
            PerformRefactoringRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.gauge.messages.PerformRefactoringRequest)
                    return object;
                var message = new $root.gauge.messages.PerformRefactoringRequest();
                if (object.oldStep != null)
                    message.oldStep = String(object.oldStep);
                if (object.newStep != null)
                    message.newStep = String(object.newStep);
                return message;
            };

            /**
             * Creates a plain object from a PerformRefactoringRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gauge.messages.PerformRefactoringRequest
             * @static
             * @param {gauge.messages.PerformRefactoringRequest} message PerformRefactoringRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PerformRefactoringRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.oldStep = "";
                    object.newStep = "";
                }
                if (message.oldStep != null && message.hasOwnProperty("oldStep"))
                    object.oldStep = message.oldStep;
                if (message.newStep != null && message.hasOwnProperty("newStep"))
                    object.newStep = message.newStep;
                return object;
            };

            /**
             * Converts this PerformRefactoringRequest to JSON.
             * @function toJSON
             * @memberof gauge.messages.PerformRefactoringRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PerformRefactoringRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return PerformRefactoringRequest;
        })();

        messages.PerformRefactoringResponse = (function() {

            /**
             * Properties of a PerformRefactoringResponse.
             * @memberof gauge.messages
             * @interface IPerformRefactoringResponse
             * @property {boolean|null} [success] Flag indicating Success
             * @property {Array.<string>|null} [errors] Error message if the refactoring was unsuccessful.
             * @property {Array.<string>|null} [filesChanged] Collection of files that were changed as part of the Refactoring.
             */

            /**
             * Constructs a new PerformRefactoringResponse.
             * @memberof gauge.messages
             * @classdesc Response to PerformRefactoringRequest
             * @implements IPerformRefactoringResponse
             * @constructor
             * @param {gauge.messages.IPerformRefactoringResponse=} [properties] Properties to set
             */
            function PerformRefactoringResponse(properties) {
                this.errors = [];
                this.filesChanged = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Flag indicating Success
             * @member {boolean} success
             * @memberof gauge.messages.PerformRefactoringResponse
             * @instance
             */
            PerformRefactoringResponse.prototype.success = false;

            /**
             * Error message if the refactoring was unsuccessful.
             * @member {Array.<string>} errors
             * @memberof gauge.messages.PerformRefactoringResponse
             * @instance
             */
            PerformRefactoringResponse.prototype.errors = $util.emptyArray;

            /**
             * Collection of files that were changed as part of the Refactoring.
             * @member {Array.<string>} filesChanged
             * @memberof gauge.messages.PerformRefactoringResponse
             * @instance
             */
            PerformRefactoringResponse.prototype.filesChanged = $util.emptyArray;

            /**
             * Creates a new PerformRefactoringResponse instance using the specified properties.
             * @function create
             * @memberof gauge.messages.PerformRefactoringResponse
             * @static
             * @param {gauge.messages.IPerformRefactoringResponse=} [properties] Properties to set
             * @returns {gauge.messages.PerformRefactoringResponse} PerformRefactoringResponse instance
             */
            PerformRefactoringResponse.create = function create(properties) {
                return new PerformRefactoringResponse(properties);
            };

            /**
             * Encodes the specified PerformRefactoringResponse message. Does not implicitly {@link gauge.messages.PerformRefactoringResponse.verify|verify} messages.
             * @function encode
             * @memberof gauge.messages.PerformRefactoringResponse
             * @static
             * @param {gauge.messages.IPerformRefactoringResponse} message PerformRefactoringResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PerformRefactoringResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.success != null && message.hasOwnProperty("success"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.success);
                if (message.errors != null && message.errors.length)
                    for (var i = 0; i < message.errors.length; ++i)
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.errors[i]);
                if (message.filesChanged != null && message.filesChanged.length)
                    for (var i = 0; i < message.filesChanged.length; ++i)
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.filesChanged[i]);
                return writer;
            };

            /**
             * Encodes the specified PerformRefactoringResponse message, length delimited. Does not implicitly {@link gauge.messages.PerformRefactoringResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gauge.messages.PerformRefactoringResponse
             * @static
             * @param {gauge.messages.IPerformRefactoringResponse} message PerformRefactoringResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PerformRefactoringResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PerformRefactoringResponse message from the specified reader or buffer.
             * @function decode
             * @memberof gauge.messages.PerformRefactoringResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gauge.messages.PerformRefactoringResponse} PerformRefactoringResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PerformRefactoringResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gauge.messages.PerformRefactoringResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.success = reader.bool();
                        break;
                    case 2:
                        if (!(message.errors && message.errors.length))
                            message.errors = [];
                        message.errors.push(reader.string());
                        break;
                    case 3:
                        if (!(message.filesChanged && message.filesChanged.length))
                            message.filesChanged = [];
                        message.filesChanged.push(reader.string());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a PerformRefactoringResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gauge.messages.PerformRefactoringResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gauge.messages.PerformRefactoringResponse} PerformRefactoringResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PerformRefactoringResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PerformRefactoringResponse message.
             * @function verify
             * @memberof gauge.messages.PerformRefactoringResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PerformRefactoringResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.success != null && message.hasOwnProperty("success"))
                    if (typeof message.success !== "boolean")
                        return "success: boolean expected";
                if (message.errors != null && message.hasOwnProperty("errors")) {
                    if (!Array.isArray(message.errors))
                        return "errors: array expected";
                    for (var i = 0; i < message.errors.length; ++i)
                        if (!$util.isString(message.errors[i]))
                            return "errors: string[] expected";
                }
                if (message.filesChanged != null && message.hasOwnProperty("filesChanged")) {
                    if (!Array.isArray(message.filesChanged))
                        return "filesChanged: array expected";
                    for (var i = 0; i < message.filesChanged.length; ++i)
                        if (!$util.isString(message.filesChanged[i]))
                            return "filesChanged: string[] expected";
                }
                return null;
            };

            /**
             * Creates a PerformRefactoringResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gauge.messages.PerformRefactoringResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gauge.messages.PerformRefactoringResponse} PerformRefactoringResponse
             */
            PerformRefactoringResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.gauge.messages.PerformRefactoringResponse)
                    return object;
                var message = new $root.gauge.messages.PerformRefactoringResponse();
                if (object.success != null)
                    message.success = Boolean(object.success);
                if (object.errors) {
                    if (!Array.isArray(object.errors))
                        throw TypeError(".gauge.messages.PerformRefactoringResponse.errors: array expected");
                    message.errors = [];
                    for (var i = 0; i < object.errors.length; ++i)
                        message.errors[i] = String(object.errors[i]);
                }
                if (object.filesChanged) {
                    if (!Array.isArray(object.filesChanged))
                        throw TypeError(".gauge.messages.PerformRefactoringResponse.filesChanged: array expected");
                    message.filesChanged = [];
                    for (var i = 0; i < object.filesChanged.length; ++i)
                        message.filesChanged[i] = String(object.filesChanged[i]);
                }
                return message;
            };

            /**
             * Creates a plain object from a PerformRefactoringResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gauge.messages.PerformRefactoringResponse
             * @static
             * @param {gauge.messages.PerformRefactoringResponse} message PerformRefactoringResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PerformRefactoringResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults) {
                    object.errors = [];
                    object.filesChanged = [];
                }
                if (options.defaults)
                    object.success = false;
                if (message.success != null && message.hasOwnProperty("success"))
                    object.success = message.success;
                if (message.errors && message.errors.length) {
                    object.errors = [];
                    for (var j = 0; j < message.errors.length; ++j)
                        object.errors[j] = message.errors[j];
                }
                if (message.filesChanged && message.filesChanged.length) {
                    object.filesChanged = [];
                    for (var j = 0; j < message.filesChanged.length; ++j)
                        object.filesChanged[j] = message.filesChanged[j];
                }
                return object;
            };

            /**
             * Converts this PerformRefactoringResponse to JSON.
             * @function toJSON
             * @memberof gauge.messages.PerformRefactoringResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PerformRefactoringResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return PerformRefactoringResponse;
        })();

        messages.ExtractConceptRequest = (function() {

            /**
             * Properties of an ExtractConceptRequest.
             * @memberof gauge.messages
             * @interface IExtractConceptRequest
             * @property {gauge.messages.Istep|null} [conceptName] The Concept name given by the user
             * @property {Array.<gauge.messages.Istep>|null} [steps] steps to extract
             * @property {boolean|null} [changeAcrossProject] Flag indicating if refactoring should be done across project
             * @property {string|null} [conceptFileName] The concept filename in which extracted concept will be added
             * @property {gauge.messages.ItextInfo|null} [selectedTextInfo] Info related to selected text, only if changeAcrossProject is false
             */

            /**
             * Constructs a new ExtractConceptRequest.
             * @memberof gauge.messages
             * @classdesc Request to perform Extract to Concept refactoring
             * @implements IExtractConceptRequest
             * @constructor
             * @param {gauge.messages.IExtractConceptRequest=} [properties] Properties to set
             */
            function ExtractConceptRequest(properties) {
                this.steps = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * The Concept name given by the user
             * @member {gauge.messages.Istep|null|undefined} conceptName
             * @memberof gauge.messages.ExtractConceptRequest
             * @instance
             */
            ExtractConceptRequest.prototype.conceptName = null;

            /**
             * steps to extract
             * @member {Array.<gauge.messages.Istep>} steps
             * @memberof gauge.messages.ExtractConceptRequest
             * @instance
             */
            ExtractConceptRequest.prototype.steps = $util.emptyArray;

            /**
             * Flag indicating if refactoring should be done across project
             * @member {boolean} changeAcrossProject
             * @memberof gauge.messages.ExtractConceptRequest
             * @instance
             */
            ExtractConceptRequest.prototype.changeAcrossProject = false;

            /**
             * The concept filename in which extracted concept will be added
             * @member {string} conceptFileName
             * @memberof gauge.messages.ExtractConceptRequest
             * @instance
             */
            ExtractConceptRequest.prototype.conceptFileName = "";

            /**
             * Info related to selected text, only if changeAcrossProject is false
             * @member {gauge.messages.ItextInfo|null|undefined} selectedTextInfo
             * @memberof gauge.messages.ExtractConceptRequest
             * @instance
             */
            ExtractConceptRequest.prototype.selectedTextInfo = null;

            /**
             * Creates a new ExtractConceptRequest instance using the specified properties.
             * @function create
             * @memberof gauge.messages.ExtractConceptRequest
             * @static
             * @param {gauge.messages.IExtractConceptRequest=} [properties] Properties to set
             * @returns {gauge.messages.ExtractConceptRequest} ExtractConceptRequest instance
             */
            ExtractConceptRequest.create = function create(properties) {
                return new ExtractConceptRequest(properties);
            };

            /**
             * Encodes the specified ExtractConceptRequest message. Does not implicitly {@link gauge.messages.ExtractConceptRequest.verify|verify} messages.
             * @function encode
             * @memberof gauge.messages.ExtractConceptRequest
             * @static
             * @param {gauge.messages.IExtractConceptRequest} message ExtractConceptRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExtractConceptRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.conceptName != null && message.hasOwnProperty("conceptName"))
                    $root.gauge.messages.step.encode(message.conceptName, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.steps != null && message.steps.length)
                    for (var i = 0; i < message.steps.length; ++i)
                        $root.gauge.messages.step.encode(message.steps[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.changeAcrossProject != null && message.hasOwnProperty("changeAcrossProject"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.changeAcrossProject);
                if (message.conceptFileName != null && message.hasOwnProperty("conceptFileName"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.conceptFileName);
                if (message.selectedTextInfo != null && message.hasOwnProperty("selectedTextInfo"))
                    $root.gauge.messages.textInfo.encode(message.selectedTextInfo, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ExtractConceptRequest message, length delimited. Does not implicitly {@link gauge.messages.ExtractConceptRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gauge.messages.ExtractConceptRequest
             * @static
             * @param {gauge.messages.IExtractConceptRequest} message ExtractConceptRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExtractConceptRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an ExtractConceptRequest message from the specified reader or buffer.
             * @function decode
             * @memberof gauge.messages.ExtractConceptRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gauge.messages.ExtractConceptRequest} ExtractConceptRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExtractConceptRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gauge.messages.ExtractConceptRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.conceptName = $root.gauge.messages.step.decode(reader, reader.uint32());
                        break;
                    case 2:
                        if (!(message.steps && message.steps.length))
                            message.steps = [];
                        message.steps.push($root.gauge.messages.step.decode(reader, reader.uint32()));
                        break;
                    case 3:
                        message.changeAcrossProject = reader.bool();
                        break;
                    case 4:
                        message.conceptFileName = reader.string();
                        break;
                    case 5:
                        message.selectedTextInfo = $root.gauge.messages.textInfo.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an ExtractConceptRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gauge.messages.ExtractConceptRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gauge.messages.ExtractConceptRequest} ExtractConceptRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExtractConceptRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an ExtractConceptRequest message.
             * @function verify
             * @memberof gauge.messages.ExtractConceptRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ExtractConceptRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.conceptName != null && message.hasOwnProperty("conceptName")) {
                    var error = $root.gauge.messages.step.verify(message.conceptName);
                    if (error)
                        return "conceptName." + error;
                }
                if (message.steps != null && message.hasOwnProperty("steps")) {
                    if (!Array.isArray(message.steps))
                        return "steps: array expected";
                    for (var i = 0; i < message.steps.length; ++i) {
                        var error = $root.gauge.messages.step.verify(message.steps[i]);
                        if (error)
                            return "steps." + error;
                    }
                }
                if (message.changeAcrossProject != null && message.hasOwnProperty("changeAcrossProject"))
                    if (typeof message.changeAcrossProject !== "boolean")
                        return "changeAcrossProject: boolean expected";
                if (message.conceptFileName != null && message.hasOwnProperty("conceptFileName"))
                    if (!$util.isString(message.conceptFileName))
                        return "conceptFileName: string expected";
                if (message.selectedTextInfo != null && message.hasOwnProperty("selectedTextInfo")) {
                    var error = $root.gauge.messages.textInfo.verify(message.selectedTextInfo);
                    if (error)
                        return "selectedTextInfo." + error;
                }
                return null;
            };

            /**
             * Creates an ExtractConceptRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gauge.messages.ExtractConceptRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gauge.messages.ExtractConceptRequest} ExtractConceptRequest
             */
            ExtractConceptRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.gauge.messages.ExtractConceptRequest)
                    return object;
                var message = new $root.gauge.messages.ExtractConceptRequest();
                if (object.conceptName != null) {
                    if (typeof object.conceptName !== "object")
                        throw TypeError(".gauge.messages.ExtractConceptRequest.conceptName: object expected");
                    message.conceptName = $root.gauge.messages.step.fromObject(object.conceptName);
                }
                if (object.steps) {
                    if (!Array.isArray(object.steps))
                        throw TypeError(".gauge.messages.ExtractConceptRequest.steps: array expected");
                    message.steps = [];
                    for (var i = 0; i < object.steps.length; ++i) {
                        if (typeof object.steps[i] !== "object")
                            throw TypeError(".gauge.messages.ExtractConceptRequest.steps: object expected");
                        message.steps[i] = $root.gauge.messages.step.fromObject(object.steps[i]);
                    }
                }
                if (object.changeAcrossProject != null)
                    message.changeAcrossProject = Boolean(object.changeAcrossProject);
                if (object.conceptFileName != null)
                    message.conceptFileName = String(object.conceptFileName);
                if (object.selectedTextInfo != null) {
                    if (typeof object.selectedTextInfo !== "object")
                        throw TypeError(".gauge.messages.ExtractConceptRequest.selectedTextInfo: object expected");
                    message.selectedTextInfo = $root.gauge.messages.textInfo.fromObject(object.selectedTextInfo);
                }
                return message;
            };

            /**
             * Creates a plain object from an ExtractConceptRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gauge.messages.ExtractConceptRequest
             * @static
             * @param {gauge.messages.ExtractConceptRequest} message ExtractConceptRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ExtractConceptRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.steps = [];
                if (options.defaults) {
                    object.conceptName = null;
                    object.changeAcrossProject = false;
                    object.conceptFileName = "";
                    object.selectedTextInfo = null;
                }
                if (message.conceptName != null && message.hasOwnProperty("conceptName"))
                    object.conceptName = $root.gauge.messages.step.toObject(message.conceptName, options);
                if (message.steps && message.steps.length) {
                    object.steps = [];
                    for (var j = 0; j < message.steps.length; ++j)
                        object.steps[j] = $root.gauge.messages.step.toObject(message.steps[j], options);
                }
                if (message.changeAcrossProject != null && message.hasOwnProperty("changeAcrossProject"))
                    object.changeAcrossProject = message.changeAcrossProject;
                if (message.conceptFileName != null && message.hasOwnProperty("conceptFileName"))
                    object.conceptFileName = message.conceptFileName;
                if (message.selectedTextInfo != null && message.hasOwnProperty("selectedTextInfo"))
                    object.selectedTextInfo = $root.gauge.messages.textInfo.toObject(message.selectedTextInfo, options);
                return object;
            };

            /**
             * Converts this ExtractConceptRequest to JSON.
             * @function toJSON
             * @memberof gauge.messages.ExtractConceptRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ExtractConceptRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ExtractConceptRequest;
        })();

        messages.textInfo = (function() {

            /**
             * Properties of a textInfo.
             * @memberof gauge.messages
             * @interface ItextInfo
             * @property {string|null} [fileName] The filename from where concept is being extracted
             * @property {number|null} [startingLineNo] storing the starting and ending line number of selected text
             * @property {number|null} [endLineNo] textInfo endLineNo
             */

            /**
             * Constructs a new textInfo.
             * @memberof gauge.messages
             * @classdesc Represents a textInfo.
             * @implements ItextInfo
             * @constructor
             * @param {gauge.messages.ItextInfo=} [properties] Properties to set
             */
            function textInfo(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * The filename from where concept is being extracted
             * @member {string} fileName
             * @memberof gauge.messages.textInfo
             * @instance
             */
            textInfo.prototype.fileName = "";

            /**
             * storing the starting and ending line number of selected text
             * @member {number} startingLineNo
             * @memberof gauge.messages.textInfo
             * @instance
             */
            textInfo.prototype.startingLineNo = 0;

            /**
             * textInfo endLineNo.
             * @member {number} endLineNo
             * @memberof gauge.messages.textInfo
             * @instance
             */
            textInfo.prototype.endLineNo = 0;

            /**
             * Creates a new textInfo instance using the specified properties.
             * @function create
             * @memberof gauge.messages.textInfo
             * @static
             * @param {gauge.messages.ItextInfo=} [properties] Properties to set
             * @returns {gauge.messages.textInfo} textInfo instance
             */
            textInfo.create = function create(properties) {
                return new textInfo(properties);
            };

            /**
             * Encodes the specified textInfo message. Does not implicitly {@link gauge.messages.textInfo.verify|verify} messages.
             * @function encode
             * @memberof gauge.messages.textInfo
             * @static
             * @param {gauge.messages.ItextInfo} message textInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            textInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.fileName != null && message.hasOwnProperty("fileName"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.fileName);
                if (message.startingLineNo != null && message.hasOwnProperty("startingLineNo"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.startingLineNo);
                if (message.endLineNo != null && message.hasOwnProperty("endLineNo"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.endLineNo);
                return writer;
            };

            /**
             * Encodes the specified textInfo message, length delimited. Does not implicitly {@link gauge.messages.textInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gauge.messages.textInfo
             * @static
             * @param {gauge.messages.ItextInfo} message textInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            textInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a textInfo message from the specified reader or buffer.
             * @function decode
             * @memberof gauge.messages.textInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gauge.messages.textInfo} textInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            textInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gauge.messages.textInfo();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.fileName = reader.string();
                        break;
                    case 2:
                        message.startingLineNo = reader.int32();
                        break;
                    case 3:
                        message.endLineNo = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a textInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gauge.messages.textInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gauge.messages.textInfo} textInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            textInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a textInfo message.
             * @function verify
             * @memberof gauge.messages.textInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            textInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.fileName != null && message.hasOwnProperty("fileName"))
                    if (!$util.isString(message.fileName))
                        return "fileName: string expected";
                if (message.startingLineNo != null && message.hasOwnProperty("startingLineNo"))
                    if (!$util.isInteger(message.startingLineNo))
                        return "startingLineNo: integer expected";
                if (message.endLineNo != null && message.hasOwnProperty("endLineNo"))
                    if (!$util.isInteger(message.endLineNo))
                        return "endLineNo: integer expected";
                return null;
            };

            /**
             * Creates a textInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gauge.messages.textInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gauge.messages.textInfo} textInfo
             */
            textInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.gauge.messages.textInfo)
                    return object;
                var message = new $root.gauge.messages.textInfo();
                if (object.fileName != null)
                    message.fileName = String(object.fileName);
                if (object.startingLineNo != null)
                    message.startingLineNo = object.startingLineNo | 0;
                if (object.endLineNo != null)
                    message.endLineNo = object.endLineNo | 0;
                return message;
            };

            /**
             * Creates a plain object from a textInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gauge.messages.textInfo
             * @static
             * @param {gauge.messages.textInfo} message textInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            textInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.fileName = "";
                    object.startingLineNo = 0;
                    object.endLineNo = 0;
                }
                if (message.fileName != null && message.hasOwnProperty("fileName"))
                    object.fileName = message.fileName;
                if (message.startingLineNo != null && message.hasOwnProperty("startingLineNo"))
                    object.startingLineNo = message.startingLineNo;
                if (message.endLineNo != null && message.hasOwnProperty("endLineNo"))
                    object.endLineNo = message.endLineNo;
                return object;
            };

            /**
             * Converts this textInfo to JSON.
             * @function toJSON
             * @memberof gauge.messages.textInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            textInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return textInfo;
        })();

        messages.step = (function() {

            /**
             * Properties of a step.
             * @memberof gauge.messages
             * @interface Istep
             * @property {string|null} [name] name of the step
             * @property {string|null} [table] table present in step as parameter
             * @property {string|null} [paramTableName] name of table in concept heading, if it comes as a param to concept
             */

            /**
             * Constructs a new step.
             * @memberof gauge.messages
             * @classdesc Represents a step.
             * @implements Istep
             * @constructor
             * @param {gauge.messages.Istep=} [properties] Properties to set
             */
            function step(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * name of the step
             * @member {string} name
             * @memberof gauge.messages.step
             * @instance
             */
            step.prototype.name = "";

            /**
             * table present in step as parameter
             * @member {string} table
             * @memberof gauge.messages.step
             * @instance
             */
            step.prototype.table = "";

            /**
             * name of table in concept heading, if it comes as a param to concept
             * @member {string} paramTableName
             * @memberof gauge.messages.step
             * @instance
             */
            step.prototype.paramTableName = "";

            /**
             * Creates a new step instance using the specified properties.
             * @function create
             * @memberof gauge.messages.step
             * @static
             * @param {gauge.messages.Istep=} [properties] Properties to set
             * @returns {gauge.messages.step} step instance
             */
            step.create = function create(properties) {
                return new step(properties);
            };

            /**
             * Encodes the specified step message. Does not implicitly {@link gauge.messages.step.verify|verify} messages.
             * @function encode
             * @memberof gauge.messages.step
             * @static
             * @param {gauge.messages.Istep} message step message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            step.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && message.hasOwnProperty("name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.table != null && message.hasOwnProperty("table"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.table);
                if (message.paramTableName != null && message.hasOwnProperty("paramTableName"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.paramTableName);
                return writer;
            };

            /**
             * Encodes the specified step message, length delimited. Does not implicitly {@link gauge.messages.step.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gauge.messages.step
             * @static
             * @param {gauge.messages.Istep} message step message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            step.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a step message from the specified reader or buffer.
             * @function decode
             * @memberof gauge.messages.step
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gauge.messages.step} step
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            step.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gauge.messages.step();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        message.table = reader.string();
                        break;
                    case 3:
                        message.paramTableName = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a step message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gauge.messages.step
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gauge.messages.step} step
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            step.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a step message.
             * @function verify
             * @memberof gauge.messages.step
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            step.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.table != null && message.hasOwnProperty("table"))
                    if (!$util.isString(message.table))
                        return "table: string expected";
                if (message.paramTableName != null && message.hasOwnProperty("paramTableName"))
                    if (!$util.isString(message.paramTableName))
                        return "paramTableName: string expected";
                return null;
            };

            /**
             * Creates a step message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gauge.messages.step
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gauge.messages.step} step
             */
            step.fromObject = function fromObject(object) {
                if (object instanceof $root.gauge.messages.step)
                    return object;
                var message = new $root.gauge.messages.step();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.table != null)
                    message.table = String(object.table);
                if (object.paramTableName != null)
                    message.paramTableName = String(object.paramTableName);
                return message;
            };

            /**
             * Creates a plain object from a step message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gauge.messages.step
             * @static
             * @param {gauge.messages.step} message step
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            step.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.name = "";
                    object.table = "";
                    object.paramTableName = "";
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.table != null && message.hasOwnProperty("table"))
                    object.table = message.table;
                if (message.paramTableName != null && message.hasOwnProperty("paramTableName"))
                    object.paramTableName = message.paramTableName;
                return object;
            };

            /**
             * Converts this step to JSON.
             * @function toJSON
             * @memberof gauge.messages.step
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            step.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return step;
        })();

        messages.ExtractConceptResponse = (function() {

            /**
             * Properties of an ExtractConceptResponse.
             * @memberof gauge.messages
             * @interface IExtractConceptResponse
             * @property {boolean|null} [isSuccess] Flag indicating Success
             * @property {string|null} [error] Error message if the refactoring was unsuccessful.
             * @property {Array.<string>|null} [filesChanged] Collection of files that were changed as part of the Refactoring.
             */

            /**
             * Constructs a new ExtractConceptResponse.
             * @memberof gauge.messages
             * @classdesc Response to perform Extract to Concept refactoring
             * @implements IExtractConceptResponse
             * @constructor
             * @param {gauge.messages.IExtractConceptResponse=} [properties] Properties to set
             */
            function ExtractConceptResponse(properties) {
                this.filesChanged = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Flag indicating Success
             * @member {boolean} isSuccess
             * @memberof gauge.messages.ExtractConceptResponse
             * @instance
             */
            ExtractConceptResponse.prototype.isSuccess = false;

            /**
             * Error message if the refactoring was unsuccessful.
             * @member {string} error
             * @memberof gauge.messages.ExtractConceptResponse
             * @instance
             */
            ExtractConceptResponse.prototype.error = "";

            /**
             * Collection of files that were changed as part of the Refactoring.
             * @member {Array.<string>} filesChanged
             * @memberof gauge.messages.ExtractConceptResponse
             * @instance
             */
            ExtractConceptResponse.prototype.filesChanged = $util.emptyArray;

            /**
             * Creates a new ExtractConceptResponse instance using the specified properties.
             * @function create
             * @memberof gauge.messages.ExtractConceptResponse
             * @static
             * @param {gauge.messages.IExtractConceptResponse=} [properties] Properties to set
             * @returns {gauge.messages.ExtractConceptResponse} ExtractConceptResponse instance
             */
            ExtractConceptResponse.create = function create(properties) {
                return new ExtractConceptResponse(properties);
            };

            /**
             * Encodes the specified ExtractConceptResponse message. Does not implicitly {@link gauge.messages.ExtractConceptResponse.verify|verify} messages.
             * @function encode
             * @memberof gauge.messages.ExtractConceptResponse
             * @static
             * @param {gauge.messages.IExtractConceptResponse} message ExtractConceptResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExtractConceptResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.isSuccess != null && message.hasOwnProperty("isSuccess"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.isSuccess);
                if (message.error != null && message.hasOwnProperty("error"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.error);
                if (message.filesChanged != null && message.filesChanged.length)
                    for (var i = 0; i < message.filesChanged.length; ++i)
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.filesChanged[i]);
                return writer;
            };

            /**
             * Encodes the specified ExtractConceptResponse message, length delimited. Does not implicitly {@link gauge.messages.ExtractConceptResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gauge.messages.ExtractConceptResponse
             * @static
             * @param {gauge.messages.IExtractConceptResponse} message ExtractConceptResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExtractConceptResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an ExtractConceptResponse message from the specified reader or buffer.
             * @function decode
             * @memberof gauge.messages.ExtractConceptResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gauge.messages.ExtractConceptResponse} ExtractConceptResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExtractConceptResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gauge.messages.ExtractConceptResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.isSuccess = reader.bool();
                        break;
                    case 2:
                        message.error = reader.string();
                        break;
                    case 3:
                        if (!(message.filesChanged && message.filesChanged.length))
                            message.filesChanged = [];
                        message.filesChanged.push(reader.string());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an ExtractConceptResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gauge.messages.ExtractConceptResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gauge.messages.ExtractConceptResponse} ExtractConceptResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExtractConceptResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an ExtractConceptResponse message.
             * @function verify
             * @memberof gauge.messages.ExtractConceptResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ExtractConceptResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.isSuccess != null && message.hasOwnProperty("isSuccess"))
                    if (typeof message.isSuccess !== "boolean")
                        return "isSuccess: boolean expected";
                if (message.error != null && message.hasOwnProperty("error"))
                    if (!$util.isString(message.error))
                        return "error: string expected";
                if (message.filesChanged != null && message.hasOwnProperty("filesChanged")) {
                    if (!Array.isArray(message.filesChanged))
                        return "filesChanged: array expected";
                    for (var i = 0; i < message.filesChanged.length; ++i)
                        if (!$util.isString(message.filesChanged[i]))
                            return "filesChanged: string[] expected";
                }
                return null;
            };

            /**
             * Creates an ExtractConceptResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gauge.messages.ExtractConceptResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gauge.messages.ExtractConceptResponse} ExtractConceptResponse
             */
            ExtractConceptResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.gauge.messages.ExtractConceptResponse)
                    return object;
                var message = new $root.gauge.messages.ExtractConceptResponse();
                if (object.isSuccess != null)
                    message.isSuccess = Boolean(object.isSuccess);
                if (object.error != null)
                    message.error = String(object.error);
                if (object.filesChanged) {
                    if (!Array.isArray(object.filesChanged))
                        throw TypeError(".gauge.messages.ExtractConceptResponse.filesChanged: array expected");
                    message.filesChanged = [];
                    for (var i = 0; i < object.filesChanged.length; ++i)
                        message.filesChanged[i] = String(object.filesChanged[i]);
                }
                return message;
            };

            /**
             * Creates a plain object from an ExtractConceptResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gauge.messages.ExtractConceptResponse
             * @static
             * @param {gauge.messages.ExtractConceptResponse} message ExtractConceptResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ExtractConceptResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.filesChanged = [];
                if (options.defaults) {
                    object.isSuccess = false;
                    object.error = "";
                }
                if (message.isSuccess != null && message.hasOwnProperty("isSuccess"))
                    object.isSuccess = message.isSuccess;
                if (message.error != null && message.hasOwnProperty("error"))
                    object.error = message.error;
                if (message.filesChanged && message.filesChanged.length) {
                    object.filesChanged = [];
                    for (var j = 0; j < message.filesChanged.length; ++j)
                        object.filesChanged[j] = message.filesChanged[j];
                }
                return object;
            };

            /**
             * Converts this ExtractConceptResponse to JSON.
             * @function toJSON
             * @memberof gauge.messages.ExtractConceptResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ExtractConceptResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ExtractConceptResponse;
        })();

        messages.FormatSpecsRequest = (function() {

            /**
             * Properties of a FormatSpecsRequest.
             * @memberof gauge.messages
             * @interface IFormatSpecsRequest
             * @property {Array.<string>|null} [specs] Specs to be formatted
             */

            /**
             * Constructs a new FormatSpecsRequest.
             * @memberof gauge.messages
             * @classdesc Request to format spec files
             * @implements IFormatSpecsRequest
             * @constructor
             * @param {gauge.messages.IFormatSpecsRequest=} [properties] Properties to set
             */
            function FormatSpecsRequest(properties) {
                this.specs = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Specs to be formatted
             * @member {Array.<string>} specs
             * @memberof gauge.messages.FormatSpecsRequest
             * @instance
             */
            FormatSpecsRequest.prototype.specs = $util.emptyArray;

            /**
             * Creates a new FormatSpecsRequest instance using the specified properties.
             * @function create
             * @memberof gauge.messages.FormatSpecsRequest
             * @static
             * @param {gauge.messages.IFormatSpecsRequest=} [properties] Properties to set
             * @returns {gauge.messages.FormatSpecsRequest} FormatSpecsRequest instance
             */
            FormatSpecsRequest.create = function create(properties) {
                return new FormatSpecsRequest(properties);
            };

            /**
             * Encodes the specified FormatSpecsRequest message. Does not implicitly {@link gauge.messages.FormatSpecsRequest.verify|verify} messages.
             * @function encode
             * @memberof gauge.messages.FormatSpecsRequest
             * @static
             * @param {gauge.messages.IFormatSpecsRequest} message FormatSpecsRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FormatSpecsRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.specs != null && message.specs.length)
                    for (var i = 0; i < message.specs.length; ++i)
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.specs[i]);
                return writer;
            };

            /**
             * Encodes the specified FormatSpecsRequest message, length delimited. Does not implicitly {@link gauge.messages.FormatSpecsRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gauge.messages.FormatSpecsRequest
             * @static
             * @param {gauge.messages.IFormatSpecsRequest} message FormatSpecsRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FormatSpecsRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a FormatSpecsRequest message from the specified reader or buffer.
             * @function decode
             * @memberof gauge.messages.FormatSpecsRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gauge.messages.FormatSpecsRequest} FormatSpecsRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FormatSpecsRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gauge.messages.FormatSpecsRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.specs && message.specs.length))
                            message.specs = [];
                        message.specs.push(reader.string());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a FormatSpecsRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gauge.messages.FormatSpecsRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gauge.messages.FormatSpecsRequest} FormatSpecsRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FormatSpecsRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a FormatSpecsRequest message.
             * @function verify
             * @memberof gauge.messages.FormatSpecsRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FormatSpecsRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.specs != null && message.hasOwnProperty("specs")) {
                    if (!Array.isArray(message.specs))
                        return "specs: array expected";
                    for (var i = 0; i < message.specs.length; ++i)
                        if (!$util.isString(message.specs[i]))
                            return "specs: string[] expected";
                }
                return null;
            };

            /**
             * Creates a FormatSpecsRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gauge.messages.FormatSpecsRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gauge.messages.FormatSpecsRequest} FormatSpecsRequest
             */
            FormatSpecsRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.gauge.messages.FormatSpecsRequest)
                    return object;
                var message = new $root.gauge.messages.FormatSpecsRequest();
                if (object.specs) {
                    if (!Array.isArray(object.specs))
                        throw TypeError(".gauge.messages.FormatSpecsRequest.specs: array expected");
                    message.specs = [];
                    for (var i = 0; i < object.specs.length; ++i)
                        message.specs[i] = String(object.specs[i]);
                }
                return message;
            };

            /**
             * Creates a plain object from a FormatSpecsRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gauge.messages.FormatSpecsRequest
             * @static
             * @param {gauge.messages.FormatSpecsRequest} message FormatSpecsRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FormatSpecsRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.specs = [];
                if (message.specs && message.specs.length) {
                    object.specs = [];
                    for (var j = 0; j < message.specs.length; ++j)
                        object.specs[j] = message.specs[j];
                }
                return object;
            };

            /**
             * Converts this FormatSpecsRequest to JSON.
             * @function toJSON
             * @memberof gauge.messages.FormatSpecsRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FormatSpecsRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return FormatSpecsRequest;
        })();

        messages.FormatSpecsResponse = (function() {

            /**
             * Properties of a FormatSpecsResponse.
             * @memberof gauge.messages
             * @interface IFormatSpecsResponse
             * @property {Array.<string>|null} [errors] Errors occurred on formatting
             * @property {Array.<string>|null} [warnings] Warnings occurred on formatting
             */

            /**
             * Constructs a new FormatSpecsResponse.
             * @memberof gauge.messages
             * @classdesc Response on formatting spec files
             * @implements IFormatSpecsResponse
             * @constructor
             * @param {gauge.messages.IFormatSpecsResponse=} [properties] Properties to set
             */
            function FormatSpecsResponse(properties) {
                this.errors = [];
                this.warnings = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Errors occurred on formatting
             * @member {Array.<string>} errors
             * @memberof gauge.messages.FormatSpecsResponse
             * @instance
             */
            FormatSpecsResponse.prototype.errors = $util.emptyArray;

            /**
             * Warnings occurred on formatting
             * @member {Array.<string>} warnings
             * @memberof gauge.messages.FormatSpecsResponse
             * @instance
             */
            FormatSpecsResponse.prototype.warnings = $util.emptyArray;

            /**
             * Creates a new FormatSpecsResponse instance using the specified properties.
             * @function create
             * @memberof gauge.messages.FormatSpecsResponse
             * @static
             * @param {gauge.messages.IFormatSpecsResponse=} [properties] Properties to set
             * @returns {gauge.messages.FormatSpecsResponse} FormatSpecsResponse instance
             */
            FormatSpecsResponse.create = function create(properties) {
                return new FormatSpecsResponse(properties);
            };

            /**
             * Encodes the specified FormatSpecsResponse message. Does not implicitly {@link gauge.messages.FormatSpecsResponse.verify|verify} messages.
             * @function encode
             * @memberof gauge.messages.FormatSpecsResponse
             * @static
             * @param {gauge.messages.IFormatSpecsResponse} message FormatSpecsResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FormatSpecsResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.errors != null && message.errors.length)
                    for (var i = 0; i < message.errors.length; ++i)
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.errors[i]);
                if (message.warnings != null && message.warnings.length)
                    for (var i = 0; i < message.warnings.length; ++i)
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.warnings[i]);
                return writer;
            };

            /**
             * Encodes the specified FormatSpecsResponse message, length delimited. Does not implicitly {@link gauge.messages.FormatSpecsResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gauge.messages.FormatSpecsResponse
             * @static
             * @param {gauge.messages.IFormatSpecsResponse} message FormatSpecsResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FormatSpecsResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a FormatSpecsResponse message from the specified reader or buffer.
             * @function decode
             * @memberof gauge.messages.FormatSpecsResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gauge.messages.FormatSpecsResponse} FormatSpecsResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FormatSpecsResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gauge.messages.FormatSpecsResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.errors && message.errors.length))
                            message.errors = [];
                        message.errors.push(reader.string());
                        break;
                    case 2:
                        if (!(message.warnings && message.warnings.length))
                            message.warnings = [];
                        message.warnings.push(reader.string());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a FormatSpecsResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gauge.messages.FormatSpecsResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gauge.messages.FormatSpecsResponse} FormatSpecsResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FormatSpecsResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a FormatSpecsResponse message.
             * @function verify
             * @memberof gauge.messages.FormatSpecsResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FormatSpecsResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.errors != null && message.hasOwnProperty("errors")) {
                    if (!Array.isArray(message.errors))
                        return "errors: array expected";
                    for (var i = 0; i < message.errors.length; ++i)
                        if (!$util.isString(message.errors[i]))
                            return "errors: string[] expected";
                }
                if (message.warnings != null && message.hasOwnProperty("warnings")) {
                    if (!Array.isArray(message.warnings))
                        return "warnings: array expected";
                    for (var i = 0; i < message.warnings.length; ++i)
                        if (!$util.isString(message.warnings[i]))
                            return "warnings: string[] expected";
                }
                return null;
            };

            /**
             * Creates a FormatSpecsResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gauge.messages.FormatSpecsResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gauge.messages.FormatSpecsResponse} FormatSpecsResponse
             */
            FormatSpecsResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.gauge.messages.FormatSpecsResponse)
                    return object;
                var message = new $root.gauge.messages.FormatSpecsResponse();
                if (object.errors) {
                    if (!Array.isArray(object.errors))
                        throw TypeError(".gauge.messages.FormatSpecsResponse.errors: array expected");
                    message.errors = [];
                    for (var i = 0; i < object.errors.length; ++i)
                        message.errors[i] = String(object.errors[i]);
                }
                if (object.warnings) {
                    if (!Array.isArray(object.warnings))
                        throw TypeError(".gauge.messages.FormatSpecsResponse.warnings: array expected");
                    message.warnings = [];
                    for (var i = 0; i < object.warnings.length; ++i)
                        message.warnings[i] = String(object.warnings[i]);
                }
                return message;
            };

            /**
             * Creates a plain object from a FormatSpecsResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gauge.messages.FormatSpecsResponse
             * @static
             * @param {gauge.messages.FormatSpecsResponse} message FormatSpecsResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FormatSpecsResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults) {
                    object.errors = [];
                    object.warnings = [];
                }
                if (message.errors && message.errors.length) {
                    object.errors = [];
                    for (var j = 0; j < message.errors.length; ++j)
                        object.errors[j] = message.errors[j];
                }
                if (message.warnings && message.warnings.length) {
                    object.warnings = [];
                    for (var j = 0; j < message.warnings.length; ++j)
                        object.warnings[j] = message.warnings[j];
                }
                return object;
            };

            /**
             * Converts this FormatSpecsResponse to JSON.
             * @function toJSON
             * @memberof gauge.messages.FormatSpecsResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FormatSpecsResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return FormatSpecsResponse;
        })();

        messages.UnsupportedApiMessageResponse = (function() {

            /**
             * Properties of an UnsupportedApiMessageResponse.
             * @memberof gauge.messages
             * @interface IUnsupportedApiMessageResponse
             */

            /**
             * Constructs a new UnsupportedApiMessageResponse.
             * @memberof gauge.messages
             * @classdesc Response when a API message request is not supported.
             * @implements IUnsupportedApiMessageResponse
             * @constructor
             * @param {gauge.messages.IUnsupportedApiMessageResponse=} [properties] Properties to set
             */
            function UnsupportedApiMessageResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new UnsupportedApiMessageResponse instance using the specified properties.
             * @function create
             * @memberof gauge.messages.UnsupportedApiMessageResponse
             * @static
             * @param {gauge.messages.IUnsupportedApiMessageResponse=} [properties] Properties to set
             * @returns {gauge.messages.UnsupportedApiMessageResponse} UnsupportedApiMessageResponse instance
             */
            UnsupportedApiMessageResponse.create = function create(properties) {
                return new UnsupportedApiMessageResponse(properties);
            };

            /**
             * Encodes the specified UnsupportedApiMessageResponse message. Does not implicitly {@link gauge.messages.UnsupportedApiMessageResponse.verify|verify} messages.
             * @function encode
             * @memberof gauge.messages.UnsupportedApiMessageResponse
             * @static
             * @param {gauge.messages.IUnsupportedApiMessageResponse} message UnsupportedApiMessageResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UnsupportedApiMessageResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified UnsupportedApiMessageResponse message, length delimited. Does not implicitly {@link gauge.messages.UnsupportedApiMessageResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gauge.messages.UnsupportedApiMessageResponse
             * @static
             * @param {gauge.messages.IUnsupportedApiMessageResponse} message UnsupportedApiMessageResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UnsupportedApiMessageResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an UnsupportedApiMessageResponse message from the specified reader or buffer.
             * @function decode
             * @memberof gauge.messages.UnsupportedApiMessageResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gauge.messages.UnsupportedApiMessageResponse} UnsupportedApiMessageResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UnsupportedApiMessageResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gauge.messages.UnsupportedApiMessageResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an UnsupportedApiMessageResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gauge.messages.UnsupportedApiMessageResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gauge.messages.UnsupportedApiMessageResponse} UnsupportedApiMessageResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UnsupportedApiMessageResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an UnsupportedApiMessageResponse message.
             * @function verify
             * @memberof gauge.messages.UnsupportedApiMessageResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            UnsupportedApiMessageResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates an UnsupportedApiMessageResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gauge.messages.UnsupportedApiMessageResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gauge.messages.UnsupportedApiMessageResponse} UnsupportedApiMessageResponse
             */
            UnsupportedApiMessageResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.gauge.messages.UnsupportedApiMessageResponse)
                    return object;
                return new $root.gauge.messages.UnsupportedApiMessageResponse();
            };

            /**
             * Creates a plain object from an UnsupportedApiMessageResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gauge.messages.UnsupportedApiMessageResponse
             * @static
             * @param {gauge.messages.UnsupportedApiMessageResponse} message UnsupportedApiMessageResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            UnsupportedApiMessageResponse.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this UnsupportedApiMessageResponse to JSON.
             * @function toJSON
             * @memberof gauge.messages.UnsupportedApiMessageResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            UnsupportedApiMessageResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return UnsupportedApiMessageResponse;
        })();

        messages.APIMessage = (function() {

            /**
             * Properties of a APIMessage.
             * @memberof gauge.messages
             * @interface IAPIMessage
             * @property {gauge.messages.APIMessage.APIMessageType|null} [messageType] Type of API call being made
             * @property {number|Long|null} [messageId] This is used to synchronize messages & responses
             * @property {gauge.messages.IGetProjectRootRequest|null} [projectRootRequest] [GetProjectRootRequest](#gauge.messages.GetProjectRootRequest)
             * @property {gauge.messages.IGetProjectRootResponse|null} [projectRootResponse] [GetProjectRootResponse](#gauge.messages.GetProjectRootResponse)
             * @property {gauge.messages.IGetInstallationRootRequest|null} [installationRootRequest] [GetInstallationRootRequest](#gauge.messages.GetInstallationRootRequest)
             * @property {gauge.messages.IGetInstallationRootResponse|null} [installationRootResponse] [GetInstallationRootResponse](#gauge.messages.GetInstallationRootResponse)
             * @property {gauge.messages.IGetAllStepsRequest|null} [allStepsRequest] [GetAllStepsRequest](#gauge.messages.GetAllStepsRequest)
             * @property {gauge.messages.IGetAllStepsResponse|null} [allStepsResponse] [GetAllStepsResponse](#gauge.messages.GetAllStepsResponse)
             * @property {gauge.messages.ISpecsRequest|null} [specsRequest] [GetAllSpecsRequest](#gauge.messages.GetAllSpecsRequest)
             * @property {gauge.messages.ISpecsResponse|null} [specsResponse] [GetAllSpecsResponse](#gauge.messages.GetAllSpecsResponse)
             * @property {gauge.messages.IGetStepValueRequest|null} [stepValueRequest] [GetStepValueRequest](#gauge.messages.GetStepValueRequest)
             * @property {gauge.messages.IGetStepValueResponse|null} [stepValueResponse] [GetStepValueResponse](#gauge.messages.GetStepValueResponse)
             * @property {gauge.messages.IGetLanguagePluginLibPathRequest|null} [libPathRequest] [GetLanguagePluginLibPathRequest](#gauge.messages.GetLanguagePluginLibPathRequest)
             * @property {gauge.messages.IGetLanguagePluginLibPathResponse|null} [libPathResponse] [GetLanguagePluginLibPathResponse](#gauge.messages.GetLanguagePluginLibPathResponse)
             * @property {gauge.messages.IErrorResponse|null} [error] [ErrorResponse](#gauge.messages.ErrorResponse)
             * @property {gauge.messages.IGetAllConceptsRequest|null} [allConceptsRequest] [GetAllConceptsRequest](#gauge.messages.GetAllConceptsRequest)
             * @property {gauge.messages.IGetAllConceptsResponse|null} [allConceptsResponse] [GetAllConceptsResponse](#gauge.messages.GetAllConceptsResponse)
             * @property {gauge.messages.IPerformRefactoringRequest|null} [performRefactoringRequest] [PerformRefactoringRequest](#gauge.messages.PerformRefactoringRequest)
             * @property {gauge.messages.IPerformRefactoringResponse|null} [performRefactoringResponse] [PerformRefactoringResponse](#gauge.messages.PerformRefactoringResponse)
             * @property {gauge.messages.IExtractConceptRequest|null} [extractConceptRequest] [ExtractConceptRequest](#gauge.messages.ExtractConceptRequest)
             * @property {gauge.messages.IExtractConceptResponse|null} [extractConceptResponse] [ExtractConceptResponse](#gauge.messages.ExtractConceptResponse)
             * @property {gauge.messages.IFormatSpecsRequest|null} [formatSpecsRequest] [FormatSpecsRequest] (#gauge.messages.FormatSpecsRequest)
             * @property {gauge.messages.IFormatSpecsResponse|null} [formatSpecsResponse] [FormatSpecsResponse] (#gauge.messages.FormatSpecsResponse)
             * @property {gauge.messages.IUnsupportedApiMessageResponse|null} [unsupportedApiMessageResponse] [UnsupportedApiMessageResponse] (#gauge.messages.UnsupportedApiMessageResponse)
             */

            /**
             * Constructs a new APIMessage.
             * @memberof gauge.messages
             * @classdesc One of the Request/Response fields will have value, depending on the MessageType set.
             * @implements IAPIMessage
             * @constructor
             * @param {gauge.messages.IAPIMessage=} [properties] Properties to set
             */
            function APIMessage(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Type of API call being made
             * @member {gauge.messages.APIMessage.APIMessageType} messageType
             * @memberof gauge.messages.APIMessage
             * @instance
             */
            APIMessage.prototype.messageType = 0;

            /**
             * This is used to synchronize messages & responses
             * @member {number|Long} messageId
             * @memberof gauge.messages.APIMessage
             * @instance
             */
            APIMessage.prototype.messageId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * [GetProjectRootRequest](#gauge.messages.GetProjectRootRequest)
             * @member {gauge.messages.IGetProjectRootRequest|null|undefined} projectRootRequest
             * @memberof gauge.messages.APIMessage
             * @instance
             */
            APIMessage.prototype.projectRootRequest = null;

            /**
             * [GetProjectRootResponse](#gauge.messages.GetProjectRootResponse)
             * @member {gauge.messages.IGetProjectRootResponse|null|undefined} projectRootResponse
             * @memberof gauge.messages.APIMessage
             * @instance
             */
            APIMessage.prototype.projectRootResponse = null;

            /**
             * [GetInstallationRootRequest](#gauge.messages.GetInstallationRootRequest)
             * @member {gauge.messages.IGetInstallationRootRequest|null|undefined} installationRootRequest
             * @memberof gauge.messages.APIMessage
             * @instance
             */
            APIMessage.prototype.installationRootRequest = null;

            /**
             * [GetInstallationRootResponse](#gauge.messages.GetInstallationRootResponse)
             * @member {gauge.messages.IGetInstallationRootResponse|null|undefined} installationRootResponse
             * @memberof gauge.messages.APIMessage
             * @instance
             */
            APIMessage.prototype.installationRootResponse = null;

            /**
             * [GetAllStepsRequest](#gauge.messages.GetAllStepsRequest)
             * @member {gauge.messages.IGetAllStepsRequest|null|undefined} allStepsRequest
             * @memberof gauge.messages.APIMessage
             * @instance
             */
            APIMessage.prototype.allStepsRequest = null;

            /**
             * [GetAllStepsResponse](#gauge.messages.GetAllStepsResponse)
             * @member {gauge.messages.IGetAllStepsResponse|null|undefined} allStepsResponse
             * @memberof gauge.messages.APIMessage
             * @instance
             */
            APIMessage.prototype.allStepsResponse = null;

            /**
             * [GetAllSpecsRequest](#gauge.messages.GetAllSpecsRequest)
             * @member {gauge.messages.ISpecsRequest|null|undefined} specsRequest
             * @memberof gauge.messages.APIMessage
             * @instance
             */
            APIMessage.prototype.specsRequest = null;

            /**
             * [GetAllSpecsResponse](#gauge.messages.GetAllSpecsResponse)
             * @member {gauge.messages.ISpecsResponse|null|undefined} specsResponse
             * @memberof gauge.messages.APIMessage
             * @instance
             */
            APIMessage.prototype.specsResponse = null;

            /**
             * [GetStepValueRequest](#gauge.messages.GetStepValueRequest)
             * @member {gauge.messages.IGetStepValueRequest|null|undefined} stepValueRequest
             * @memberof gauge.messages.APIMessage
             * @instance
             */
            APIMessage.prototype.stepValueRequest = null;

            /**
             * [GetStepValueResponse](#gauge.messages.GetStepValueResponse)
             * @member {gauge.messages.IGetStepValueResponse|null|undefined} stepValueResponse
             * @memberof gauge.messages.APIMessage
             * @instance
             */
            APIMessage.prototype.stepValueResponse = null;

            /**
             * [GetLanguagePluginLibPathRequest](#gauge.messages.GetLanguagePluginLibPathRequest)
             * @member {gauge.messages.IGetLanguagePluginLibPathRequest|null|undefined} libPathRequest
             * @memberof gauge.messages.APIMessage
             * @instance
             */
            APIMessage.prototype.libPathRequest = null;

            /**
             * [GetLanguagePluginLibPathResponse](#gauge.messages.GetLanguagePluginLibPathResponse)
             * @member {gauge.messages.IGetLanguagePluginLibPathResponse|null|undefined} libPathResponse
             * @memberof gauge.messages.APIMessage
             * @instance
             */
            APIMessage.prototype.libPathResponse = null;

            /**
             * [ErrorResponse](#gauge.messages.ErrorResponse)
             * @member {gauge.messages.IErrorResponse|null|undefined} error
             * @memberof gauge.messages.APIMessage
             * @instance
             */
            APIMessage.prototype.error = null;

            /**
             * [GetAllConceptsRequest](#gauge.messages.GetAllConceptsRequest)
             * @member {gauge.messages.IGetAllConceptsRequest|null|undefined} allConceptsRequest
             * @memberof gauge.messages.APIMessage
             * @instance
             */
            APIMessage.prototype.allConceptsRequest = null;

            /**
             * [GetAllConceptsResponse](#gauge.messages.GetAllConceptsResponse)
             * @member {gauge.messages.IGetAllConceptsResponse|null|undefined} allConceptsResponse
             * @memberof gauge.messages.APIMessage
             * @instance
             */
            APIMessage.prototype.allConceptsResponse = null;

            /**
             * [PerformRefactoringRequest](#gauge.messages.PerformRefactoringRequest)
             * @member {gauge.messages.IPerformRefactoringRequest|null|undefined} performRefactoringRequest
             * @memberof gauge.messages.APIMessage
             * @instance
             */
            APIMessage.prototype.performRefactoringRequest = null;

            /**
             * [PerformRefactoringResponse](#gauge.messages.PerformRefactoringResponse)
             * @member {gauge.messages.IPerformRefactoringResponse|null|undefined} performRefactoringResponse
             * @memberof gauge.messages.APIMessage
             * @instance
             */
            APIMessage.prototype.performRefactoringResponse = null;

            /**
             * [ExtractConceptRequest](#gauge.messages.ExtractConceptRequest)
             * @member {gauge.messages.IExtractConceptRequest|null|undefined} extractConceptRequest
             * @memberof gauge.messages.APIMessage
             * @instance
             */
            APIMessage.prototype.extractConceptRequest = null;

            /**
             * [ExtractConceptResponse](#gauge.messages.ExtractConceptResponse)
             * @member {gauge.messages.IExtractConceptResponse|null|undefined} extractConceptResponse
             * @memberof gauge.messages.APIMessage
             * @instance
             */
            APIMessage.prototype.extractConceptResponse = null;

            /**
             * [FormatSpecsRequest] (#gauge.messages.FormatSpecsRequest)
             * @member {gauge.messages.IFormatSpecsRequest|null|undefined} formatSpecsRequest
             * @memberof gauge.messages.APIMessage
             * @instance
             */
            APIMessage.prototype.formatSpecsRequest = null;

            /**
             * [FormatSpecsResponse] (#gauge.messages.FormatSpecsResponse)
             * @member {gauge.messages.IFormatSpecsResponse|null|undefined} formatSpecsResponse
             * @memberof gauge.messages.APIMessage
             * @instance
             */
            APIMessage.prototype.formatSpecsResponse = null;

            /**
             * [UnsupportedApiMessageResponse] (#gauge.messages.UnsupportedApiMessageResponse)
             * @member {gauge.messages.IUnsupportedApiMessageResponse|null|undefined} unsupportedApiMessageResponse
             * @memberof gauge.messages.APIMessage
             * @instance
             */
            APIMessage.prototype.unsupportedApiMessageResponse = null;

            /**
             * Creates a new APIMessage instance using the specified properties.
             * @function create
             * @memberof gauge.messages.APIMessage
             * @static
             * @param {gauge.messages.IAPIMessage=} [properties] Properties to set
             * @returns {gauge.messages.APIMessage} APIMessage instance
             */
            APIMessage.create = function create(properties) {
                return new APIMessage(properties);
            };

            /**
             * Encodes the specified APIMessage message. Does not implicitly {@link gauge.messages.APIMessage.verify|verify} messages.
             * @function encode
             * @memberof gauge.messages.APIMessage
             * @static
             * @param {gauge.messages.IAPIMessage} message APIMessage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            APIMessage.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.messageType != null && message.hasOwnProperty("messageType"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.messageType);
                if (message.messageId != null && message.hasOwnProperty("messageId"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.messageId);
                if (message.projectRootRequest != null && message.hasOwnProperty("projectRootRequest"))
                    $root.gauge.messages.GetProjectRootRequest.encode(message.projectRootRequest, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.projectRootResponse != null && message.hasOwnProperty("projectRootResponse"))
                    $root.gauge.messages.GetProjectRootResponse.encode(message.projectRootResponse, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.installationRootRequest != null && message.hasOwnProperty("installationRootRequest"))
                    $root.gauge.messages.GetInstallationRootRequest.encode(message.installationRootRequest, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.installationRootResponse != null && message.hasOwnProperty("installationRootResponse"))
                    $root.gauge.messages.GetInstallationRootResponse.encode(message.installationRootResponse, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.allStepsRequest != null && message.hasOwnProperty("allStepsRequest"))
                    $root.gauge.messages.GetAllStepsRequest.encode(message.allStepsRequest, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                if (message.allStepsResponse != null && message.hasOwnProperty("allStepsResponse"))
                    $root.gauge.messages.GetAllStepsResponse.encode(message.allStepsResponse, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                if (message.specsRequest != null && message.hasOwnProperty("specsRequest"))
                    $root.gauge.messages.SpecsRequest.encode(message.specsRequest, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                if (message.specsResponse != null && message.hasOwnProperty("specsResponse"))
                    $root.gauge.messages.SpecsResponse.encode(message.specsResponse, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                if (message.stepValueRequest != null && message.hasOwnProperty("stepValueRequest"))
                    $root.gauge.messages.GetStepValueRequest.encode(message.stepValueRequest, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
                if (message.stepValueResponse != null && message.hasOwnProperty("stepValueResponse"))
                    $root.gauge.messages.GetStepValueResponse.encode(message.stepValueResponse, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
                if (message.libPathRequest != null && message.hasOwnProperty("libPathRequest"))
                    $root.gauge.messages.GetLanguagePluginLibPathRequest.encode(message.libPathRequest, writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
                if (message.libPathResponse != null && message.hasOwnProperty("libPathResponse"))
                    $root.gauge.messages.GetLanguagePluginLibPathResponse.encode(message.libPathResponse, writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
                if (message.error != null && message.hasOwnProperty("error"))
                    $root.gauge.messages.ErrorResponse.encode(message.error, writer.uint32(/* id 15, wireType 2 =*/122).fork()).ldelim();
                if (message.allConceptsRequest != null && message.hasOwnProperty("allConceptsRequest"))
                    $root.gauge.messages.GetAllConceptsRequest.encode(message.allConceptsRequest, writer.uint32(/* id 16, wireType 2 =*/130).fork()).ldelim();
                if (message.allConceptsResponse != null && message.hasOwnProperty("allConceptsResponse"))
                    $root.gauge.messages.GetAllConceptsResponse.encode(message.allConceptsResponse, writer.uint32(/* id 17, wireType 2 =*/138).fork()).ldelim();
                if (message.performRefactoringRequest != null && message.hasOwnProperty("performRefactoringRequest"))
                    $root.gauge.messages.PerformRefactoringRequest.encode(message.performRefactoringRequest, writer.uint32(/* id 18, wireType 2 =*/146).fork()).ldelim();
                if (message.performRefactoringResponse != null && message.hasOwnProperty("performRefactoringResponse"))
                    $root.gauge.messages.PerformRefactoringResponse.encode(message.performRefactoringResponse, writer.uint32(/* id 19, wireType 2 =*/154).fork()).ldelim();
                if (message.extractConceptRequest != null && message.hasOwnProperty("extractConceptRequest"))
                    $root.gauge.messages.ExtractConceptRequest.encode(message.extractConceptRequest, writer.uint32(/* id 20, wireType 2 =*/162).fork()).ldelim();
                if (message.extractConceptResponse != null && message.hasOwnProperty("extractConceptResponse"))
                    $root.gauge.messages.ExtractConceptResponse.encode(message.extractConceptResponse, writer.uint32(/* id 21, wireType 2 =*/170).fork()).ldelim();
                if (message.formatSpecsRequest != null && message.hasOwnProperty("formatSpecsRequest"))
                    $root.gauge.messages.FormatSpecsRequest.encode(message.formatSpecsRequest, writer.uint32(/* id 22, wireType 2 =*/178).fork()).ldelim();
                if (message.formatSpecsResponse != null && message.hasOwnProperty("formatSpecsResponse"))
                    $root.gauge.messages.FormatSpecsResponse.encode(message.formatSpecsResponse, writer.uint32(/* id 23, wireType 2 =*/186).fork()).ldelim();
                if (message.unsupportedApiMessageResponse != null && message.hasOwnProperty("unsupportedApiMessageResponse"))
                    $root.gauge.messages.UnsupportedApiMessageResponse.encode(message.unsupportedApiMessageResponse, writer.uint32(/* id 24, wireType 2 =*/194).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified APIMessage message, length delimited. Does not implicitly {@link gauge.messages.APIMessage.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gauge.messages.APIMessage
             * @static
             * @param {gauge.messages.IAPIMessage} message APIMessage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            APIMessage.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a APIMessage message from the specified reader or buffer.
             * @function decode
             * @memberof gauge.messages.APIMessage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gauge.messages.APIMessage} APIMessage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            APIMessage.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gauge.messages.APIMessage();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.messageType = reader.int32();
                        break;
                    case 2:
                        message.messageId = reader.int64();
                        break;
                    case 3:
                        message.projectRootRequest = $root.gauge.messages.GetProjectRootRequest.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.projectRootResponse = $root.gauge.messages.GetProjectRootResponse.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.installationRootRequest = $root.gauge.messages.GetInstallationRootRequest.decode(reader, reader.uint32());
                        break;
                    case 6:
                        message.installationRootResponse = $root.gauge.messages.GetInstallationRootResponse.decode(reader, reader.uint32());
                        break;
                    case 7:
                        message.allStepsRequest = $root.gauge.messages.GetAllStepsRequest.decode(reader, reader.uint32());
                        break;
                    case 8:
                        message.allStepsResponse = $root.gauge.messages.GetAllStepsResponse.decode(reader, reader.uint32());
                        break;
                    case 9:
                        message.specsRequest = $root.gauge.messages.SpecsRequest.decode(reader, reader.uint32());
                        break;
                    case 10:
                        message.specsResponse = $root.gauge.messages.SpecsResponse.decode(reader, reader.uint32());
                        break;
                    case 11:
                        message.stepValueRequest = $root.gauge.messages.GetStepValueRequest.decode(reader, reader.uint32());
                        break;
                    case 12:
                        message.stepValueResponse = $root.gauge.messages.GetStepValueResponse.decode(reader, reader.uint32());
                        break;
                    case 13:
                        message.libPathRequest = $root.gauge.messages.GetLanguagePluginLibPathRequest.decode(reader, reader.uint32());
                        break;
                    case 14:
                        message.libPathResponse = $root.gauge.messages.GetLanguagePluginLibPathResponse.decode(reader, reader.uint32());
                        break;
                    case 15:
                        message.error = $root.gauge.messages.ErrorResponse.decode(reader, reader.uint32());
                        break;
                    case 16:
                        message.allConceptsRequest = $root.gauge.messages.GetAllConceptsRequest.decode(reader, reader.uint32());
                        break;
                    case 17:
                        message.allConceptsResponse = $root.gauge.messages.GetAllConceptsResponse.decode(reader, reader.uint32());
                        break;
                    case 18:
                        message.performRefactoringRequest = $root.gauge.messages.PerformRefactoringRequest.decode(reader, reader.uint32());
                        break;
                    case 19:
                        message.performRefactoringResponse = $root.gauge.messages.PerformRefactoringResponse.decode(reader, reader.uint32());
                        break;
                    case 20:
                        message.extractConceptRequest = $root.gauge.messages.ExtractConceptRequest.decode(reader, reader.uint32());
                        break;
                    case 21:
                        message.extractConceptResponse = $root.gauge.messages.ExtractConceptResponse.decode(reader, reader.uint32());
                        break;
                    case 22:
                        message.formatSpecsRequest = $root.gauge.messages.FormatSpecsRequest.decode(reader, reader.uint32());
                        break;
                    case 23:
                        message.formatSpecsResponse = $root.gauge.messages.FormatSpecsResponse.decode(reader, reader.uint32());
                        break;
                    case 24:
                        message.unsupportedApiMessageResponse = $root.gauge.messages.UnsupportedApiMessageResponse.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a APIMessage message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gauge.messages.APIMessage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gauge.messages.APIMessage} APIMessage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            APIMessage.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a APIMessage message.
             * @function verify
             * @memberof gauge.messages.APIMessage
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            APIMessage.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.messageType != null && message.hasOwnProperty("messageType"))
                    switch (message.messageType) {
                    default:
                        return "messageType: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                    case 8:
                    case 9:
                    case 10:
                    case 11:
                    case 12:
                    case 13:
                    case 14:
                    case 15:
                    case 16:
                    case 17:
                    case 18:
                    case 19:
                    case 20:
                    case 21:
                        break;
                    }
                if (message.messageId != null && message.hasOwnProperty("messageId"))
                    if (!$util.isInteger(message.messageId) && !(message.messageId && $util.isInteger(message.messageId.low) && $util.isInteger(message.messageId.high)))
                        return "messageId: integer|Long expected";
                if (message.projectRootRequest != null && message.hasOwnProperty("projectRootRequest")) {
                    var error = $root.gauge.messages.GetProjectRootRequest.verify(message.projectRootRequest);
                    if (error)
                        return "projectRootRequest." + error;
                }
                if (message.projectRootResponse != null && message.hasOwnProperty("projectRootResponse")) {
                    var error = $root.gauge.messages.GetProjectRootResponse.verify(message.projectRootResponse);
                    if (error)
                        return "projectRootResponse." + error;
                }
                if (message.installationRootRequest != null && message.hasOwnProperty("installationRootRequest")) {
                    var error = $root.gauge.messages.GetInstallationRootRequest.verify(message.installationRootRequest);
                    if (error)
                        return "installationRootRequest." + error;
                }
                if (message.installationRootResponse != null && message.hasOwnProperty("installationRootResponse")) {
                    var error = $root.gauge.messages.GetInstallationRootResponse.verify(message.installationRootResponse);
                    if (error)
                        return "installationRootResponse." + error;
                }
                if (message.allStepsRequest != null && message.hasOwnProperty("allStepsRequest")) {
                    var error = $root.gauge.messages.GetAllStepsRequest.verify(message.allStepsRequest);
                    if (error)
                        return "allStepsRequest." + error;
                }
                if (message.allStepsResponse != null && message.hasOwnProperty("allStepsResponse")) {
                    var error = $root.gauge.messages.GetAllStepsResponse.verify(message.allStepsResponse);
                    if (error)
                        return "allStepsResponse." + error;
                }
                if (message.specsRequest != null && message.hasOwnProperty("specsRequest")) {
                    var error = $root.gauge.messages.SpecsRequest.verify(message.specsRequest);
                    if (error)
                        return "specsRequest." + error;
                }
                if (message.specsResponse != null && message.hasOwnProperty("specsResponse")) {
                    var error = $root.gauge.messages.SpecsResponse.verify(message.specsResponse);
                    if (error)
                        return "specsResponse." + error;
                }
                if (message.stepValueRequest != null && message.hasOwnProperty("stepValueRequest")) {
                    var error = $root.gauge.messages.GetStepValueRequest.verify(message.stepValueRequest);
                    if (error)
                        return "stepValueRequest." + error;
                }
                if (message.stepValueResponse != null && message.hasOwnProperty("stepValueResponse")) {
                    var error = $root.gauge.messages.GetStepValueResponse.verify(message.stepValueResponse);
                    if (error)
                        return "stepValueResponse." + error;
                }
                if (message.libPathRequest != null && message.hasOwnProperty("libPathRequest")) {
                    var error = $root.gauge.messages.GetLanguagePluginLibPathRequest.verify(message.libPathRequest);
                    if (error)
                        return "libPathRequest." + error;
                }
                if (message.libPathResponse != null && message.hasOwnProperty("libPathResponse")) {
                    var error = $root.gauge.messages.GetLanguagePluginLibPathResponse.verify(message.libPathResponse);
                    if (error)
                        return "libPathResponse." + error;
                }
                if (message.error != null && message.hasOwnProperty("error")) {
                    var error = $root.gauge.messages.ErrorResponse.verify(message.error);
                    if (error)
                        return "error." + error;
                }
                if (message.allConceptsRequest != null && message.hasOwnProperty("allConceptsRequest")) {
                    var error = $root.gauge.messages.GetAllConceptsRequest.verify(message.allConceptsRequest);
                    if (error)
                        return "allConceptsRequest." + error;
                }
                if (message.allConceptsResponse != null && message.hasOwnProperty("allConceptsResponse")) {
                    var error = $root.gauge.messages.GetAllConceptsResponse.verify(message.allConceptsResponse);
                    if (error)
                        return "allConceptsResponse." + error;
                }
                if (message.performRefactoringRequest != null && message.hasOwnProperty("performRefactoringRequest")) {
                    var error = $root.gauge.messages.PerformRefactoringRequest.verify(message.performRefactoringRequest);
                    if (error)
                        return "performRefactoringRequest." + error;
                }
                if (message.performRefactoringResponse != null && message.hasOwnProperty("performRefactoringResponse")) {
                    var error = $root.gauge.messages.PerformRefactoringResponse.verify(message.performRefactoringResponse);
                    if (error)
                        return "performRefactoringResponse." + error;
                }
                if (message.extractConceptRequest != null && message.hasOwnProperty("extractConceptRequest")) {
                    var error = $root.gauge.messages.ExtractConceptRequest.verify(message.extractConceptRequest);
                    if (error)
                        return "extractConceptRequest." + error;
                }
                if (message.extractConceptResponse != null && message.hasOwnProperty("extractConceptResponse")) {
                    var error = $root.gauge.messages.ExtractConceptResponse.verify(message.extractConceptResponse);
                    if (error)
                        return "extractConceptResponse." + error;
                }
                if (message.formatSpecsRequest != null && message.hasOwnProperty("formatSpecsRequest")) {
                    var error = $root.gauge.messages.FormatSpecsRequest.verify(message.formatSpecsRequest);
                    if (error)
                        return "formatSpecsRequest." + error;
                }
                if (message.formatSpecsResponse != null && message.hasOwnProperty("formatSpecsResponse")) {
                    var error = $root.gauge.messages.FormatSpecsResponse.verify(message.formatSpecsResponse);
                    if (error)
                        return "formatSpecsResponse." + error;
                }
                if (message.unsupportedApiMessageResponse != null && message.hasOwnProperty("unsupportedApiMessageResponse")) {
                    var error = $root.gauge.messages.UnsupportedApiMessageResponse.verify(message.unsupportedApiMessageResponse);
                    if (error)
                        return "unsupportedApiMessageResponse." + error;
                }
                return null;
            };

            /**
             * Creates a APIMessage message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gauge.messages.APIMessage
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gauge.messages.APIMessage} APIMessage
             */
            APIMessage.fromObject = function fromObject(object) {
                if (object instanceof $root.gauge.messages.APIMessage)
                    return object;
                var message = new $root.gauge.messages.APIMessage();
                switch (object.messageType) {
                case "GetProjectRootRequest":
                case 0:
                    message.messageType = 0;
                    break;
                case "GetProjectRootResponse":
                case 1:
                    message.messageType = 1;
                    break;
                case "GetInstallationRootRequest":
                case 2:
                    message.messageType = 2;
                    break;
                case "GetInstallationRootResponse":
                case 3:
                    message.messageType = 3;
                    break;
                case "GetAllStepsRequest":
                case 4:
                    message.messageType = 4;
                    break;
                case "GetAllStepResponse":
                case 5:
                    message.messageType = 5;
                    break;
                case "SpecsRequest":
                case 6:
                    message.messageType = 6;
                    break;
                case "SpecsResponse":
                case 7:
                    message.messageType = 7;
                    break;
                case "GetStepValueRequest":
                case 8:
                    message.messageType = 8;
                    break;
                case "GetStepValueResponse":
                case 9:
                    message.messageType = 9;
                    break;
                case "GetLanguagePluginLibPathRequest":
                case 10:
                    message.messageType = 10;
                    break;
                case "GetLanguagePluginLibPathResponse":
                case 11:
                    message.messageType = 11;
                    break;
                case "ErrorResponse":
                case 12:
                    message.messageType = 12;
                    break;
                case "GetAllConceptsRequest":
                case 13:
                    message.messageType = 13;
                    break;
                case "GetAllConceptsResponse":
                case 14:
                    message.messageType = 14;
                    break;
                case "PerformRefactoringRequest":
                case 15:
                    message.messageType = 15;
                    break;
                case "PerformRefactoringResponse":
                case 16:
                    message.messageType = 16;
                    break;
                case "ExtractConceptRequest":
                case 17:
                    message.messageType = 17;
                    break;
                case "ExtractConceptResponse":
                case 18:
                    message.messageType = 18;
                    break;
                case "FormatSpecsRequest":
                case 19:
                    message.messageType = 19;
                    break;
                case "FormatSpecsResponse":
                case 20:
                    message.messageType = 20;
                    break;
                case "UnsupportedApiMessageResponse":
                case 21:
                    message.messageType = 21;
                    break;
                }
                if (object.messageId != null)
                    if ($util.Long)
                        (message.messageId = $util.Long.fromValue(object.messageId)).unsigned = false;
                    else if (typeof object.messageId === "string")
                        message.messageId = parseInt(object.messageId, 10);
                    else if (typeof object.messageId === "number")
                        message.messageId = object.messageId;
                    else if (typeof object.messageId === "object")
                        message.messageId = new $util.LongBits(object.messageId.low >>> 0, object.messageId.high >>> 0).toNumber();
                if (object.projectRootRequest != null) {
                    if (typeof object.projectRootRequest !== "object")
                        throw TypeError(".gauge.messages.APIMessage.projectRootRequest: object expected");
                    message.projectRootRequest = $root.gauge.messages.GetProjectRootRequest.fromObject(object.projectRootRequest);
                }
                if (object.projectRootResponse != null) {
                    if (typeof object.projectRootResponse !== "object")
                        throw TypeError(".gauge.messages.APIMessage.projectRootResponse: object expected");
                    message.projectRootResponse = $root.gauge.messages.GetProjectRootResponse.fromObject(object.projectRootResponse);
                }
                if (object.installationRootRequest != null) {
                    if (typeof object.installationRootRequest !== "object")
                        throw TypeError(".gauge.messages.APIMessage.installationRootRequest: object expected");
                    message.installationRootRequest = $root.gauge.messages.GetInstallationRootRequest.fromObject(object.installationRootRequest);
                }
                if (object.installationRootResponse != null) {
                    if (typeof object.installationRootResponse !== "object")
                        throw TypeError(".gauge.messages.APIMessage.installationRootResponse: object expected");
                    message.installationRootResponse = $root.gauge.messages.GetInstallationRootResponse.fromObject(object.installationRootResponse);
                }
                if (object.allStepsRequest != null) {
                    if (typeof object.allStepsRequest !== "object")
                        throw TypeError(".gauge.messages.APIMessage.allStepsRequest: object expected");
                    message.allStepsRequest = $root.gauge.messages.GetAllStepsRequest.fromObject(object.allStepsRequest);
                }
                if (object.allStepsResponse != null) {
                    if (typeof object.allStepsResponse !== "object")
                        throw TypeError(".gauge.messages.APIMessage.allStepsResponse: object expected");
                    message.allStepsResponse = $root.gauge.messages.GetAllStepsResponse.fromObject(object.allStepsResponse);
                }
                if (object.specsRequest != null) {
                    if (typeof object.specsRequest !== "object")
                        throw TypeError(".gauge.messages.APIMessage.specsRequest: object expected");
                    message.specsRequest = $root.gauge.messages.SpecsRequest.fromObject(object.specsRequest);
                }
                if (object.specsResponse != null) {
                    if (typeof object.specsResponse !== "object")
                        throw TypeError(".gauge.messages.APIMessage.specsResponse: object expected");
                    message.specsResponse = $root.gauge.messages.SpecsResponse.fromObject(object.specsResponse);
                }
                if (object.stepValueRequest != null) {
                    if (typeof object.stepValueRequest !== "object")
                        throw TypeError(".gauge.messages.APIMessage.stepValueRequest: object expected");
                    message.stepValueRequest = $root.gauge.messages.GetStepValueRequest.fromObject(object.stepValueRequest);
                }
                if (object.stepValueResponse != null) {
                    if (typeof object.stepValueResponse !== "object")
                        throw TypeError(".gauge.messages.APIMessage.stepValueResponse: object expected");
                    message.stepValueResponse = $root.gauge.messages.GetStepValueResponse.fromObject(object.stepValueResponse);
                }
                if (object.libPathRequest != null) {
                    if (typeof object.libPathRequest !== "object")
                        throw TypeError(".gauge.messages.APIMessage.libPathRequest: object expected");
                    message.libPathRequest = $root.gauge.messages.GetLanguagePluginLibPathRequest.fromObject(object.libPathRequest);
                }
                if (object.libPathResponse != null) {
                    if (typeof object.libPathResponse !== "object")
                        throw TypeError(".gauge.messages.APIMessage.libPathResponse: object expected");
                    message.libPathResponse = $root.gauge.messages.GetLanguagePluginLibPathResponse.fromObject(object.libPathResponse);
                }
                if (object.error != null) {
                    if (typeof object.error !== "object")
                        throw TypeError(".gauge.messages.APIMessage.error: object expected");
                    message.error = $root.gauge.messages.ErrorResponse.fromObject(object.error);
                }
                if (object.allConceptsRequest != null) {
                    if (typeof object.allConceptsRequest !== "object")
                        throw TypeError(".gauge.messages.APIMessage.allConceptsRequest: object expected");
                    message.allConceptsRequest = $root.gauge.messages.GetAllConceptsRequest.fromObject(object.allConceptsRequest);
                }
                if (object.allConceptsResponse != null) {
                    if (typeof object.allConceptsResponse !== "object")
                        throw TypeError(".gauge.messages.APIMessage.allConceptsResponse: object expected");
                    message.allConceptsResponse = $root.gauge.messages.GetAllConceptsResponse.fromObject(object.allConceptsResponse);
                }
                if (object.performRefactoringRequest != null) {
                    if (typeof object.performRefactoringRequest !== "object")
                        throw TypeError(".gauge.messages.APIMessage.performRefactoringRequest: object expected");
                    message.performRefactoringRequest = $root.gauge.messages.PerformRefactoringRequest.fromObject(object.performRefactoringRequest);
                }
                if (object.performRefactoringResponse != null) {
                    if (typeof object.performRefactoringResponse !== "object")
                        throw TypeError(".gauge.messages.APIMessage.performRefactoringResponse: object expected");
                    message.performRefactoringResponse = $root.gauge.messages.PerformRefactoringResponse.fromObject(object.performRefactoringResponse);
                }
                if (object.extractConceptRequest != null) {
                    if (typeof object.extractConceptRequest !== "object")
                        throw TypeError(".gauge.messages.APIMessage.extractConceptRequest: object expected");
                    message.extractConceptRequest = $root.gauge.messages.ExtractConceptRequest.fromObject(object.extractConceptRequest);
                }
                if (object.extractConceptResponse != null) {
                    if (typeof object.extractConceptResponse !== "object")
                        throw TypeError(".gauge.messages.APIMessage.extractConceptResponse: object expected");
                    message.extractConceptResponse = $root.gauge.messages.ExtractConceptResponse.fromObject(object.extractConceptResponse);
                }
                if (object.formatSpecsRequest != null) {
                    if (typeof object.formatSpecsRequest !== "object")
                        throw TypeError(".gauge.messages.APIMessage.formatSpecsRequest: object expected");
                    message.formatSpecsRequest = $root.gauge.messages.FormatSpecsRequest.fromObject(object.formatSpecsRequest);
                }
                if (object.formatSpecsResponse != null) {
                    if (typeof object.formatSpecsResponse !== "object")
                        throw TypeError(".gauge.messages.APIMessage.formatSpecsResponse: object expected");
                    message.formatSpecsResponse = $root.gauge.messages.FormatSpecsResponse.fromObject(object.formatSpecsResponse);
                }
                if (object.unsupportedApiMessageResponse != null) {
                    if (typeof object.unsupportedApiMessageResponse !== "object")
                        throw TypeError(".gauge.messages.APIMessage.unsupportedApiMessageResponse: object expected");
                    message.unsupportedApiMessageResponse = $root.gauge.messages.UnsupportedApiMessageResponse.fromObject(object.unsupportedApiMessageResponse);
                }
                return message;
            };

            /**
             * Creates a plain object from a APIMessage message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gauge.messages.APIMessage
             * @static
             * @param {gauge.messages.APIMessage} message APIMessage
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            APIMessage.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.messageType = options.enums === String ? "GetProjectRootRequest" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.messageId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.messageId = options.longs === String ? "0" : 0;
                    object.projectRootRequest = null;
                    object.projectRootResponse = null;
                    object.installationRootRequest = null;
                    object.installationRootResponse = null;
                    object.allStepsRequest = null;
                    object.allStepsResponse = null;
                    object.specsRequest = null;
                    object.specsResponse = null;
                    object.stepValueRequest = null;
                    object.stepValueResponse = null;
                    object.libPathRequest = null;
                    object.libPathResponse = null;
                    object.error = null;
                    object.allConceptsRequest = null;
                    object.allConceptsResponse = null;
                    object.performRefactoringRequest = null;
                    object.performRefactoringResponse = null;
                    object.extractConceptRequest = null;
                    object.extractConceptResponse = null;
                    object.formatSpecsRequest = null;
                    object.formatSpecsResponse = null;
                    object.unsupportedApiMessageResponse = null;
                }
                if (message.messageType != null && message.hasOwnProperty("messageType"))
                    object.messageType = options.enums === String ? $root.gauge.messages.APIMessage.APIMessageType[message.messageType] : message.messageType;
                if (message.messageId != null && message.hasOwnProperty("messageId"))
                    if (typeof message.messageId === "number")
                        object.messageId = options.longs === String ? String(message.messageId) : message.messageId;
                    else
                        object.messageId = options.longs === String ? $util.Long.prototype.toString.call(message.messageId) : options.longs === Number ? new $util.LongBits(message.messageId.low >>> 0, message.messageId.high >>> 0).toNumber() : message.messageId;
                if (message.projectRootRequest != null && message.hasOwnProperty("projectRootRequest"))
                    object.projectRootRequest = $root.gauge.messages.GetProjectRootRequest.toObject(message.projectRootRequest, options);
                if (message.projectRootResponse != null && message.hasOwnProperty("projectRootResponse"))
                    object.projectRootResponse = $root.gauge.messages.GetProjectRootResponse.toObject(message.projectRootResponse, options);
                if (message.installationRootRequest != null && message.hasOwnProperty("installationRootRequest"))
                    object.installationRootRequest = $root.gauge.messages.GetInstallationRootRequest.toObject(message.installationRootRequest, options);
                if (message.installationRootResponse != null && message.hasOwnProperty("installationRootResponse"))
                    object.installationRootResponse = $root.gauge.messages.GetInstallationRootResponse.toObject(message.installationRootResponse, options);
                if (message.allStepsRequest != null && message.hasOwnProperty("allStepsRequest"))
                    object.allStepsRequest = $root.gauge.messages.GetAllStepsRequest.toObject(message.allStepsRequest, options);
                if (message.allStepsResponse != null && message.hasOwnProperty("allStepsResponse"))
                    object.allStepsResponse = $root.gauge.messages.GetAllStepsResponse.toObject(message.allStepsResponse, options);
                if (message.specsRequest != null && message.hasOwnProperty("specsRequest"))
                    object.specsRequest = $root.gauge.messages.SpecsRequest.toObject(message.specsRequest, options);
                if (message.specsResponse != null && message.hasOwnProperty("specsResponse"))
                    object.specsResponse = $root.gauge.messages.SpecsResponse.toObject(message.specsResponse, options);
                if (message.stepValueRequest != null && message.hasOwnProperty("stepValueRequest"))
                    object.stepValueRequest = $root.gauge.messages.GetStepValueRequest.toObject(message.stepValueRequest, options);
                if (message.stepValueResponse != null && message.hasOwnProperty("stepValueResponse"))
                    object.stepValueResponse = $root.gauge.messages.GetStepValueResponse.toObject(message.stepValueResponse, options);
                if (message.libPathRequest != null && message.hasOwnProperty("libPathRequest"))
                    object.libPathRequest = $root.gauge.messages.GetLanguagePluginLibPathRequest.toObject(message.libPathRequest, options);
                if (message.libPathResponse != null && message.hasOwnProperty("libPathResponse"))
                    object.libPathResponse = $root.gauge.messages.GetLanguagePluginLibPathResponse.toObject(message.libPathResponse, options);
                if (message.error != null && message.hasOwnProperty("error"))
                    object.error = $root.gauge.messages.ErrorResponse.toObject(message.error, options);
                if (message.allConceptsRequest != null && message.hasOwnProperty("allConceptsRequest"))
                    object.allConceptsRequest = $root.gauge.messages.GetAllConceptsRequest.toObject(message.allConceptsRequest, options);
                if (message.allConceptsResponse != null && message.hasOwnProperty("allConceptsResponse"))
                    object.allConceptsResponse = $root.gauge.messages.GetAllConceptsResponse.toObject(message.allConceptsResponse, options);
                if (message.performRefactoringRequest != null && message.hasOwnProperty("performRefactoringRequest"))
                    object.performRefactoringRequest = $root.gauge.messages.PerformRefactoringRequest.toObject(message.performRefactoringRequest, options);
                if (message.performRefactoringResponse != null && message.hasOwnProperty("performRefactoringResponse"))
                    object.performRefactoringResponse = $root.gauge.messages.PerformRefactoringResponse.toObject(message.performRefactoringResponse, options);
                if (message.extractConceptRequest != null && message.hasOwnProperty("extractConceptRequest"))
                    object.extractConceptRequest = $root.gauge.messages.ExtractConceptRequest.toObject(message.extractConceptRequest, options);
                if (message.extractConceptResponse != null && message.hasOwnProperty("extractConceptResponse"))
                    object.extractConceptResponse = $root.gauge.messages.ExtractConceptResponse.toObject(message.extractConceptResponse, options);
                if (message.formatSpecsRequest != null && message.hasOwnProperty("formatSpecsRequest"))
                    object.formatSpecsRequest = $root.gauge.messages.FormatSpecsRequest.toObject(message.formatSpecsRequest, options);
                if (message.formatSpecsResponse != null && message.hasOwnProperty("formatSpecsResponse"))
                    object.formatSpecsResponse = $root.gauge.messages.FormatSpecsResponse.toObject(message.formatSpecsResponse, options);
                if (message.unsupportedApiMessageResponse != null && message.hasOwnProperty("unsupportedApiMessageResponse"))
                    object.unsupportedApiMessageResponse = $root.gauge.messages.UnsupportedApiMessageResponse.toObject(message.unsupportedApiMessageResponse, options);
                return object;
            };

            /**
             * Converts this APIMessage to JSON.
             * @function toJSON
             * @memberof gauge.messages.APIMessage
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            APIMessage.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * APIMessageType enum.
             * @name gauge.messages.APIMessage.APIMessageType
             * @enum {string}
             * @property {number} GetProjectRootRequest=0 GetProjectRootRequest value
             * @property {number} GetProjectRootResponse=1 GetProjectRootResponse value
             * @property {number} GetInstallationRootRequest=2 GetInstallationRootRequest value
             * @property {number} GetInstallationRootResponse=3 GetInstallationRootResponse value
             * @property {number} GetAllStepsRequest=4 GetAllStepsRequest value
             * @property {number} GetAllStepResponse=5 GetAllStepResponse value
             * @property {number} SpecsRequest=6 SpecsRequest value
             * @property {number} SpecsResponse=7 SpecsResponse value
             * @property {number} GetStepValueRequest=8 GetStepValueRequest value
             * @property {number} GetStepValueResponse=9 GetStepValueResponse value
             * @property {number} GetLanguagePluginLibPathRequest=10 GetLanguagePluginLibPathRequest value
             * @property {number} GetLanguagePluginLibPathResponse=11 GetLanguagePluginLibPathResponse value
             * @property {number} ErrorResponse=12 ErrorResponse value
             * @property {number} GetAllConceptsRequest=13 GetAllConceptsRequest value
             * @property {number} GetAllConceptsResponse=14 GetAllConceptsResponse value
             * @property {number} PerformRefactoringRequest=15 PerformRefactoringRequest value
             * @property {number} PerformRefactoringResponse=16 PerformRefactoringResponse value
             * @property {number} ExtractConceptRequest=17 ExtractConceptRequest value
             * @property {number} ExtractConceptResponse=18 ExtractConceptResponse value
             * @property {number} FormatSpecsRequest=19 FormatSpecsRequest value
             * @property {number} FormatSpecsResponse=20 FormatSpecsResponse value
             * @property {number} UnsupportedApiMessageResponse=21 UnsupportedApiMessageResponse value
             */
            APIMessage.APIMessageType = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "GetProjectRootRequest"] = 0;
                values[valuesById[1] = "GetProjectRootResponse"] = 1;
                values[valuesById[2] = "GetInstallationRootRequest"] = 2;
                values[valuesById[3] = "GetInstallationRootResponse"] = 3;
                values[valuesById[4] = "GetAllStepsRequest"] = 4;
                values[valuesById[5] = "GetAllStepResponse"] = 5;
                values[valuesById[6] = "SpecsRequest"] = 6;
                values[valuesById[7] = "SpecsResponse"] = 7;
                values[valuesById[8] = "GetStepValueRequest"] = 8;
                values[valuesById[9] = "GetStepValueResponse"] = 9;
                values[valuesById[10] = "GetLanguagePluginLibPathRequest"] = 10;
                values[valuesById[11] = "GetLanguagePluginLibPathResponse"] = 11;
                values[valuesById[12] = "ErrorResponse"] = 12;
                values[valuesById[13] = "GetAllConceptsRequest"] = 13;
                values[valuesById[14] = "GetAllConceptsResponse"] = 14;
                values[valuesById[15] = "PerformRefactoringRequest"] = 15;
                values[valuesById[16] = "PerformRefactoringResponse"] = 16;
                values[valuesById[17] = "ExtractConceptRequest"] = 17;
                values[valuesById[18] = "ExtractConceptResponse"] = 18;
                values[valuesById[19] = "FormatSpecsRequest"] = 19;
                values[valuesById[20] = "FormatSpecsResponse"] = 20;
                values[valuesById[21] = "UnsupportedApiMessageResponse"] = 21;
                return values;
            })();

            return APIMessage;
        })();

        messages.ProtoSpec = (function() {

            /**
             * Properties of a ProtoSpec.
             * @memberof gauge.messages
             * @interface IProtoSpec
             * @property {string|null} [specHeading] Heading describing the Specification
             * @property {Array.<gauge.messages.IProtoItem>|null} [items] A collection of items that come under this step
             * @property {boolean|null} [isTableDriven] Flag indicating if this is a Table Driven Specification. The table is defined in the context, this is different from using a table parameter.
             * @property {Array.<gauge.messages.IProtoHookFailure>|null} [preHookFailures] Contains a 'before' hook failure message. This happens when the `before_spec` hook has an error.
             * @property {Array.<gauge.messages.IProtoHookFailure>|null} [postHookFailures] Contains a 'before' hook failure message. This happens when the `after_hook` hook has an error.
             * @property {string|null} [fileName] Contains the filename for that holds this specification.
             * @property {Array.<string>|null} [tags] Contains a list of tags that are defined at the specification level. Scenario tags are not present here.
             * @property {Array.<string>|null} [preHookMessages] Additional information at pre hook exec time to be available on reports
             * @property {Array.<string>|null} [postHookMessages] Additional information at post hook exec time to be available on reports
             * @property {Array.<string>|null} [preHookMessage] [DEPRECATED, use preHookMessages] Additional information at pre hook exec time to be available on reports
             * @property {Array.<string>|null} [postHookMessage] [DEPRECATED, use postHookMessages] Additional information at post hook exec time to be available on reports
             * @property {Array.<Uint8Array>|null} [preHookScreenshots] [DEPRECATED, use preHookScreenshotFiles] Capture Screenshot at pre hook exec time to be available on reports
             * @property {Array.<Uint8Array>|null} [postHookScreenshots] [DEPRECATED, use postHookScreenshotFiles] Capture Screenshot at post hook exec time to be available on reports
             * @property {number|Long|null} [itemCount] used when items are sent as individual chunk
             * @property {Array.<string>|null} [preHookScreenshotFiles] Screenshots captured on pre hook exec time to be available on reports
             * @property {Array.<string>|null} [postHookScreenshotFiles] Screenshots captured on post hook exec time to be available on reports
             */

            /**
             * Constructs a new ProtoSpec.
             * @memberof gauge.messages
             * @classdesc A specification can contain Scenarios or Steps, besides Comments
             * @implements IProtoSpec
             * @constructor
             * @param {gauge.messages.IProtoSpec=} [properties] Properties to set
             */
            function ProtoSpec(properties) {
                this.items = [];
                this.preHookFailures = [];
                this.postHookFailures = [];
                this.tags = [];
                this.preHookMessages = [];
                this.postHookMessages = [];
                this.preHookMessage = [];
                this.postHookMessage = [];
                this.preHookScreenshots = [];
                this.postHookScreenshots = [];
                this.preHookScreenshotFiles = [];
                this.postHookScreenshotFiles = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Heading describing the Specification
             * @member {string} specHeading
             * @memberof gauge.messages.ProtoSpec
             * @instance
             */
            ProtoSpec.prototype.specHeading = "";

            /**
             * A collection of items that come under this step
             * @member {Array.<gauge.messages.IProtoItem>} items
             * @memberof gauge.messages.ProtoSpec
             * @instance
             */
            ProtoSpec.prototype.items = $util.emptyArray;

            /**
             * Flag indicating if this is a Table Driven Specification. The table is defined in the context, this is different from using a table parameter.
             * @member {boolean} isTableDriven
             * @memberof gauge.messages.ProtoSpec
             * @instance
             */
            ProtoSpec.prototype.isTableDriven = false;

            /**
             * Contains a 'before' hook failure message. This happens when the `before_spec` hook has an error.
             * @member {Array.<gauge.messages.IProtoHookFailure>} preHookFailures
             * @memberof gauge.messages.ProtoSpec
             * @instance
             */
            ProtoSpec.prototype.preHookFailures = $util.emptyArray;

            /**
             * Contains a 'before' hook failure message. This happens when the `after_hook` hook has an error.
             * @member {Array.<gauge.messages.IProtoHookFailure>} postHookFailures
             * @memberof gauge.messages.ProtoSpec
             * @instance
             */
            ProtoSpec.prototype.postHookFailures = $util.emptyArray;

            /**
             * Contains the filename for that holds this specification.
             * @member {string} fileName
             * @memberof gauge.messages.ProtoSpec
             * @instance
             */
            ProtoSpec.prototype.fileName = "";

            /**
             * Contains a list of tags that are defined at the specification level. Scenario tags are not present here.
             * @member {Array.<string>} tags
             * @memberof gauge.messages.ProtoSpec
             * @instance
             */
            ProtoSpec.prototype.tags = $util.emptyArray;

            /**
             * Additional information at pre hook exec time to be available on reports
             * @member {Array.<string>} preHookMessages
             * @memberof gauge.messages.ProtoSpec
             * @instance
             */
            ProtoSpec.prototype.preHookMessages = $util.emptyArray;

            /**
             * Additional information at post hook exec time to be available on reports
             * @member {Array.<string>} postHookMessages
             * @memberof gauge.messages.ProtoSpec
             * @instance
             */
            ProtoSpec.prototype.postHookMessages = $util.emptyArray;

            /**
             * [DEPRECATED, use preHookMessages] Additional information at pre hook exec time to be available on reports
             * @member {Array.<string>} preHookMessage
             * @memberof gauge.messages.ProtoSpec
             * @instance
             */
            ProtoSpec.prototype.preHookMessage = $util.emptyArray;

            /**
             * [DEPRECATED, use postHookMessages] Additional information at post hook exec time to be available on reports
             * @member {Array.<string>} postHookMessage
             * @memberof gauge.messages.ProtoSpec
             * @instance
             */
            ProtoSpec.prototype.postHookMessage = $util.emptyArray;

            /**
             * [DEPRECATED, use preHookScreenshotFiles] Capture Screenshot at pre hook exec time to be available on reports
             * @member {Array.<Uint8Array>} preHookScreenshots
             * @memberof gauge.messages.ProtoSpec
             * @instance
             */
            ProtoSpec.prototype.preHookScreenshots = $util.emptyArray;

            /**
             * [DEPRECATED, use postHookScreenshotFiles] Capture Screenshot at post hook exec time to be available on reports
             * @member {Array.<Uint8Array>} postHookScreenshots
             * @memberof gauge.messages.ProtoSpec
             * @instance
             */
            ProtoSpec.prototype.postHookScreenshots = $util.emptyArray;

            /**
             * used when items are sent as individual chunk
             * @member {number|Long} itemCount
             * @memberof gauge.messages.ProtoSpec
             * @instance
             */
            ProtoSpec.prototype.itemCount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Screenshots captured on pre hook exec time to be available on reports
             * @member {Array.<string>} preHookScreenshotFiles
             * @memberof gauge.messages.ProtoSpec
             * @instance
             */
            ProtoSpec.prototype.preHookScreenshotFiles = $util.emptyArray;

            /**
             * Screenshots captured on post hook exec time to be available on reports
             * @member {Array.<string>} postHookScreenshotFiles
             * @memberof gauge.messages.ProtoSpec
             * @instance
             */
            ProtoSpec.prototype.postHookScreenshotFiles = $util.emptyArray;

            /**
             * Creates a new ProtoSpec instance using the specified properties.
             * @function create
             * @memberof gauge.messages.ProtoSpec
             * @static
             * @param {gauge.messages.IProtoSpec=} [properties] Properties to set
             * @returns {gauge.messages.ProtoSpec} ProtoSpec instance
             */
            ProtoSpec.create = function create(properties) {
                return new ProtoSpec(properties);
            };

            /**
             * Encodes the specified ProtoSpec message. Does not implicitly {@link gauge.messages.ProtoSpec.verify|verify} messages.
             * @function encode
             * @memberof gauge.messages.ProtoSpec
             * @static
             * @param {gauge.messages.IProtoSpec} message ProtoSpec message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ProtoSpec.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.specHeading != null && message.hasOwnProperty("specHeading"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.specHeading);
                if (message.items != null && message.items.length)
                    for (var i = 0; i < message.items.length; ++i)
                        $root.gauge.messages.ProtoItem.encode(message.items[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.isTableDriven != null && message.hasOwnProperty("isTableDriven"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.isTableDriven);
                if (message.preHookFailures != null && message.preHookFailures.length)
                    for (var i = 0; i < message.preHookFailures.length; ++i)
                        $root.gauge.messages.ProtoHookFailure.encode(message.preHookFailures[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.postHookFailures != null && message.postHookFailures.length)
                    for (var i = 0; i < message.postHookFailures.length; ++i)
                        $root.gauge.messages.ProtoHookFailure.encode(message.postHookFailures[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.fileName != null && message.hasOwnProperty("fileName"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.fileName);
                if (message.tags != null && message.tags.length)
                    for (var i = 0; i < message.tags.length; ++i)
                        writer.uint32(/* id 7, wireType 2 =*/58).string(message.tags[i]);
                if (message.preHookMessages != null && message.preHookMessages.length)
                    for (var i = 0; i < message.preHookMessages.length; ++i)
                        writer.uint32(/* id 8, wireType 2 =*/66).string(message.preHookMessages[i]);
                if (message.postHookMessages != null && message.postHookMessages.length)
                    for (var i = 0; i < message.postHookMessages.length; ++i)
                        writer.uint32(/* id 9, wireType 2 =*/74).string(message.postHookMessages[i]);
                if (message.preHookMessage != null && message.preHookMessage.length)
                    for (var i = 0; i < message.preHookMessage.length; ++i)
                        writer.uint32(/* id 10, wireType 2 =*/82).string(message.preHookMessage[i]);
                if (message.postHookMessage != null && message.postHookMessage.length)
                    for (var i = 0; i < message.postHookMessage.length; ++i)
                        writer.uint32(/* id 11, wireType 2 =*/90).string(message.postHookMessage[i]);
                if (message.preHookScreenshots != null && message.preHookScreenshots.length)
                    for (var i = 0; i < message.preHookScreenshots.length; ++i)
                        writer.uint32(/* id 12, wireType 2 =*/98).bytes(message.preHookScreenshots[i]);
                if (message.postHookScreenshots != null && message.postHookScreenshots.length)
                    for (var i = 0; i < message.postHookScreenshots.length; ++i)
                        writer.uint32(/* id 13, wireType 2 =*/106).bytes(message.postHookScreenshots[i]);
                if (message.itemCount != null && message.hasOwnProperty("itemCount"))
                    writer.uint32(/* id 14, wireType 0 =*/112).int64(message.itemCount);
                if (message.preHookScreenshotFiles != null && message.preHookScreenshotFiles.length)
                    for (var i = 0; i < message.preHookScreenshotFiles.length; ++i)
                        writer.uint32(/* id 15, wireType 2 =*/122).string(message.preHookScreenshotFiles[i]);
                if (message.postHookScreenshotFiles != null && message.postHookScreenshotFiles.length)
                    for (var i = 0; i < message.postHookScreenshotFiles.length; ++i)
                        writer.uint32(/* id 16, wireType 2 =*/130).string(message.postHookScreenshotFiles[i]);
                return writer;
            };

            /**
             * Encodes the specified ProtoSpec message, length delimited. Does not implicitly {@link gauge.messages.ProtoSpec.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gauge.messages.ProtoSpec
             * @static
             * @param {gauge.messages.IProtoSpec} message ProtoSpec message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ProtoSpec.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ProtoSpec message from the specified reader or buffer.
             * @function decode
             * @memberof gauge.messages.ProtoSpec
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gauge.messages.ProtoSpec} ProtoSpec
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ProtoSpec.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gauge.messages.ProtoSpec();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.specHeading = reader.string();
                        break;
                    case 2:
                        if (!(message.items && message.items.length))
                            message.items = [];
                        message.items.push($root.gauge.messages.ProtoItem.decode(reader, reader.uint32()));
                        break;
                    case 3:
                        message.isTableDriven = reader.bool();
                        break;
                    case 4:
                        if (!(message.preHookFailures && message.preHookFailures.length))
                            message.preHookFailures = [];
                        message.preHookFailures.push($root.gauge.messages.ProtoHookFailure.decode(reader, reader.uint32()));
                        break;
                    case 5:
                        if (!(message.postHookFailures && message.postHookFailures.length))
                            message.postHookFailures = [];
                        message.postHookFailures.push($root.gauge.messages.ProtoHookFailure.decode(reader, reader.uint32()));
                        break;
                    case 6:
                        message.fileName = reader.string();
                        break;
                    case 7:
                        if (!(message.tags && message.tags.length))
                            message.tags = [];
                        message.tags.push(reader.string());
                        break;
                    case 8:
                        if (!(message.preHookMessages && message.preHookMessages.length))
                            message.preHookMessages = [];
                        message.preHookMessages.push(reader.string());
                        break;
                    case 9:
                        if (!(message.postHookMessages && message.postHookMessages.length))
                            message.postHookMessages = [];
                        message.postHookMessages.push(reader.string());
                        break;
                    case 10:
                        if (!(message.preHookMessage && message.preHookMessage.length))
                            message.preHookMessage = [];
                        message.preHookMessage.push(reader.string());
                        break;
                    case 11:
                        if (!(message.postHookMessage && message.postHookMessage.length))
                            message.postHookMessage = [];
                        message.postHookMessage.push(reader.string());
                        break;
                    case 12:
                        if (!(message.preHookScreenshots && message.preHookScreenshots.length))
                            message.preHookScreenshots = [];
                        message.preHookScreenshots.push(reader.bytes());
                        break;
                    case 13:
                        if (!(message.postHookScreenshots && message.postHookScreenshots.length))
                            message.postHookScreenshots = [];
                        message.postHookScreenshots.push(reader.bytes());
                        break;
                    case 14:
                        message.itemCount = reader.int64();
                        break;
                    case 15:
                        if (!(message.preHookScreenshotFiles && message.preHookScreenshotFiles.length))
                            message.preHookScreenshotFiles = [];
                        message.preHookScreenshotFiles.push(reader.string());
                        break;
                    case 16:
                        if (!(message.postHookScreenshotFiles && message.postHookScreenshotFiles.length))
                            message.postHookScreenshotFiles = [];
                        message.postHookScreenshotFiles.push(reader.string());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ProtoSpec message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gauge.messages.ProtoSpec
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gauge.messages.ProtoSpec} ProtoSpec
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ProtoSpec.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ProtoSpec message.
             * @function verify
             * @memberof gauge.messages.ProtoSpec
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ProtoSpec.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.specHeading != null && message.hasOwnProperty("specHeading"))
                    if (!$util.isString(message.specHeading))
                        return "specHeading: string expected";
                if (message.items != null && message.hasOwnProperty("items")) {
                    if (!Array.isArray(message.items))
                        return "items: array expected";
                    for (var i = 0; i < message.items.length; ++i) {
                        var error = $root.gauge.messages.ProtoItem.verify(message.items[i]);
                        if (error)
                            return "items." + error;
                    }
                }
                if (message.isTableDriven != null && message.hasOwnProperty("isTableDriven"))
                    if (typeof message.isTableDriven !== "boolean")
                        return "isTableDriven: boolean expected";
                if (message.preHookFailures != null && message.hasOwnProperty("preHookFailures")) {
                    if (!Array.isArray(message.preHookFailures))
                        return "preHookFailures: array expected";
                    for (var i = 0; i < message.preHookFailures.length; ++i) {
                        var error = $root.gauge.messages.ProtoHookFailure.verify(message.preHookFailures[i]);
                        if (error)
                            return "preHookFailures." + error;
                    }
                }
                if (message.postHookFailures != null && message.hasOwnProperty("postHookFailures")) {
                    if (!Array.isArray(message.postHookFailures))
                        return "postHookFailures: array expected";
                    for (var i = 0; i < message.postHookFailures.length; ++i) {
                        var error = $root.gauge.messages.ProtoHookFailure.verify(message.postHookFailures[i]);
                        if (error)
                            return "postHookFailures." + error;
                    }
                }
                if (message.fileName != null && message.hasOwnProperty("fileName"))
                    if (!$util.isString(message.fileName))
                        return "fileName: string expected";
                if (message.tags != null && message.hasOwnProperty("tags")) {
                    if (!Array.isArray(message.tags))
                        return "tags: array expected";
                    for (var i = 0; i < message.tags.length; ++i)
                        if (!$util.isString(message.tags[i]))
                            return "tags: string[] expected";
                }
                if (message.preHookMessages != null && message.hasOwnProperty("preHookMessages")) {
                    if (!Array.isArray(message.preHookMessages))
                        return "preHookMessages: array expected";
                    for (var i = 0; i < message.preHookMessages.length; ++i)
                        if (!$util.isString(message.preHookMessages[i]))
                            return "preHookMessages: string[] expected";
                }
                if (message.postHookMessages != null && message.hasOwnProperty("postHookMessages")) {
                    if (!Array.isArray(message.postHookMessages))
                        return "postHookMessages: array expected";
                    for (var i = 0; i < message.postHookMessages.length; ++i)
                        if (!$util.isString(message.postHookMessages[i]))
                            return "postHookMessages: string[] expected";
                }
                if (message.preHookMessage != null && message.hasOwnProperty("preHookMessage")) {
                    if (!Array.isArray(message.preHookMessage))
                        return "preHookMessage: array expected";
                    for (var i = 0; i < message.preHookMessage.length; ++i)
                        if (!$util.isString(message.preHookMessage[i]))
                            return "preHookMessage: string[] expected";
                }
                if (message.postHookMessage != null && message.hasOwnProperty("postHookMessage")) {
                    if (!Array.isArray(message.postHookMessage))
                        return "postHookMessage: array expected";
                    for (var i = 0; i < message.postHookMessage.length; ++i)
                        if (!$util.isString(message.postHookMessage[i]))
                            return "postHookMessage: string[] expected";
                }
                if (message.preHookScreenshots != null && message.hasOwnProperty("preHookScreenshots")) {
                    if (!Array.isArray(message.preHookScreenshots))
                        return "preHookScreenshots: array expected";
                    for (var i = 0; i < message.preHookScreenshots.length; ++i)
                        if (!(message.preHookScreenshots[i] && typeof message.preHookScreenshots[i].length === "number" || $util.isString(message.preHookScreenshots[i])))
                            return "preHookScreenshots: buffer[] expected";
                }
                if (message.postHookScreenshots != null && message.hasOwnProperty("postHookScreenshots")) {
                    if (!Array.isArray(message.postHookScreenshots))
                        return "postHookScreenshots: array expected";
                    for (var i = 0; i < message.postHookScreenshots.length; ++i)
                        if (!(message.postHookScreenshots[i] && typeof message.postHookScreenshots[i].length === "number" || $util.isString(message.postHookScreenshots[i])))
                            return "postHookScreenshots: buffer[] expected";
                }
                if (message.itemCount != null && message.hasOwnProperty("itemCount"))
                    if (!$util.isInteger(message.itemCount) && !(message.itemCount && $util.isInteger(message.itemCount.low) && $util.isInteger(message.itemCount.high)))
                        return "itemCount: integer|Long expected";
                if (message.preHookScreenshotFiles != null && message.hasOwnProperty("preHookScreenshotFiles")) {
                    if (!Array.isArray(message.preHookScreenshotFiles))
                        return "preHookScreenshotFiles: array expected";
                    for (var i = 0; i < message.preHookScreenshotFiles.length; ++i)
                        if (!$util.isString(message.preHookScreenshotFiles[i]))
                            return "preHookScreenshotFiles: string[] expected";
                }
                if (message.postHookScreenshotFiles != null && message.hasOwnProperty("postHookScreenshotFiles")) {
                    if (!Array.isArray(message.postHookScreenshotFiles))
                        return "postHookScreenshotFiles: array expected";
                    for (var i = 0; i < message.postHookScreenshotFiles.length; ++i)
                        if (!$util.isString(message.postHookScreenshotFiles[i]))
                            return "postHookScreenshotFiles: string[] expected";
                }
                return null;
            };

            /**
             * Creates a ProtoSpec message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gauge.messages.ProtoSpec
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gauge.messages.ProtoSpec} ProtoSpec
             */
            ProtoSpec.fromObject = function fromObject(object) {
                if (object instanceof $root.gauge.messages.ProtoSpec)
                    return object;
                var message = new $root.gauge.messages.ProtoSpec();
                if (object.specHeading != null)
                    message.specHeading = String(object.specHeading);
                if (object.items) {
                    if (!Array.isArray(object.items))
                        throw TypeError(".gauge.messages.ProtoSpec.items: array expected");
                    message.items = [];
                    for (var i = 0; i < object.items.length; ++i) {
                        if (typeof object.items[i] !== "object")
                            throw TypeError(".gauge.messages.ProtoSpec.items: object expected");
                        message.items[i] = $root.gauge.messages.ProtoItem.fromObject(object.items[i]);
                    }
                }
                if (object.isTableDriven != null)
                    message.isTableDriven = Boolean(object.isTableDriven);
                if (object.preHookFailures) {
                    if (!Array.isArray(object.preHookFailures))
                        throw TypeError(".gauge.messages.ProtoSpec.preHookFailures: array expected");
                    message.preHookFailures = [];
                    for (var i = 0; i < object.preHookFailures.length; ++i) {
                        if (typeof object.preHookFailures[i] !== "object")
                            throw TypeError(".gauge.messages.ProtoSpec.preHookFailures: object expected");
                        message.preHookFailures[i] = $root.gauge.messages.ProtoHookFailure.fromObject(object.preHookFailures[i]);
                    }
                }
                if (object.postHookFailures) {
                    if (!Array.isArray(object.postHookFailures))
                        throw TypeError(".gauge.messages.ProtoSpec.postHookFailures: array expected");
                    message.postHookFailures = [];
                    for (var i = 0; i < object.postHookFailures.length; ++i) {
                        if (typeof object.postHookFailures[i] !== "object")
                            throw TypeError(".gauge.messages.ProtoSpec.postHookFailures: object expected");
                        message.postHookFailures[i] = $root.gauge.messages.ProtoHookFailure.fromObject(object.postHookFailures[i]);
                    }
                }
                if (object.fileName != null)
                    message.fileName = String(object.fileName);
                if (object.tags) {
                    if (!Array.isArray(object.tags))
                        throw TypeError(".gauge.messages.ProtoSpec.tags: array expected");
                    message.tags = [];
                    for (var i = 0; i < object.tags.length; ++i)
                        message.tags[i] = String(object.tags[i]);
                }
                if (object.preHookMessages) {
                    if (!Array.isArray(object.preHookMessages))
                        throw TypeError(".gauge.messages.ProtoSpec.preHookMessages: array expected");
                    message.preHookMessages = [];
                    for (var i = 0; i < object.preHookMessages.length; ++i)
                        message.preHookMessages[i] = String(object.preHookMessages[i]);
                }
                if (object.postHookMessages) {
                    if (!Array.isArray(object.postHookMessages))
                        throw TypeError(".gauge.messages.ProtoSpec.postHookMessages: array expected");
                    message.postHookMessages = [];
                    for (var i = 0; i < object.postHookMessages.length; ++i)
                        message.postHookMessages[i] = String(object.postHookMessages[i]);
                }
                if (object.preHookMessage) {
                    if (!Array.isArray(object.preHookMessage))
                        throw TypeError(".gauge.messages.ProtoSpec.preHookMessage: array expected");
                    message.preHookMessage = [];
                    for (var i = 0; i < object.preHookMessage.length; ++i)
                        message.preHookMessage[i] = String(object.preHookMessage[i]);
                }
                if (object.postHookMessage) {
                    if (!Array.isArray(object.postHookMessage))
                        throw TypeError(".gauge.messages.ProtoSpec.postHookMessage: array expected");
                    message.postHookMessage = [];
                    for (var i = 0; i < object.postHookMessage.length; ++i)
                        message.postHookMessage[i] = String(object.postHookMessage[i]);
                }
                if (object.preHookScreenshots) {
                    if (!Array.isArray(object.preHookScreenshots))
                        throw TypeError(".gauge.messages.ProtoSpec.preHookScreenshots: array expected");
                    message.preHookScreenshots = [];
                    for (var i = 0; i < object.preHookScreenshots.length; ++i)
                        if (typeof object.preHookScreenshots[i] === "string")
                            $util.base64.decode(object.preHookScreenshots[i], message.preHookScreenshots[i] = $util.newBuffer($util.base64.length(object.preHookScreenshots[i])), 0);
                        else if (object.preHookScreenshots[i].length)
                            message.preHookScreenshots[i] = object.preHookScreenshots[i];
                }
                if (object.postHookScreenshots) {
                    if (!Array.isArray(object.postHookScreenshots))
                        throw TypeError(".gauge.messages.ProtoSpec.postHookScreenshots: array expected");
                    message.postHookScreenshots = [];
                    for (var i = 0; i < object.postHookScreenshots.length; ++i)
                        if (typeof object.postHookScreenshots[i] === "string")
                            $util.base64.decode(object.postHookScreenshots[i], message.postHookScreenshots[i] = $util.newBuffer($util.base64.length(object.postHookScreenshots[i])), 0);
                        else if (object.postHookScreenshots[i].length)
                            message.postHookScreenshots[i] = object.postHookScreenshots[i];
                }
                if (object.itemCount != null)
                    if ($util.Long)
                        (message.itemCount = $util.Long.fromValue(object.itemCount)).unsigned = false;
                    else if (typeof object.itemCount === "string")
                        message.itemCount = parseInt(object.itemCount, 10);
                    else if (typeof object.itemCount === "number")
                        message.itemCount = object.itemCount;
                    else if (typeof object.itemCount === "object")
                        message.itemCount = new $util.LongBits(object.itemCount.low >>> 0, object.itemCount.high >>> 0).toNumber();
                if (object.preHookScreenshotFiles) {
                    if (!Array.isArray(object.preHookScreenshotFiles))
                        throw TypeError(".gauge.messages.ProtoSpec.preHookScreenshotFiles: array expected");
                    message.preHookScreenshotFiles = [];
                    for (var i = 0; i < object.preHookScreenshotFiles.length; ++i)
                        message.preHookScreenshotFiles[i] = String(object.preHookScreenshotFiles[i]);
                }
                if (object.postHookScreenshotFiles) {
                    if (!Array.isArray(object.postHookScreenshotFiles))
                        throw TypeError(".gauge.messages.ProtoSpec.postHookScreenshotFiles: array expected");
                    message.postHookScreenshotFiles = [];
                    for (var i = 0; i < object.postHookScreenshotFiles.length; ++i)
                        message.postHookScreenshotFiles[i] = String(object.postHookScreenshotFiles[i]);
                }
                return message;
            };

            /**
             * Creates a plain object from a ProtoSpec message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gauge.messages.ProtoSpec
             * @static
             * @param {gauge.messages.ProtoSpec} message ProtoSpec
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ProtoSpec.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults) {
                    object.items = [];
                    object.preHookFailures = [];
                    object.postHookFailures = [];
                    object.tags = [];
                    object.preHookMessages = [];
                    object.postHookMessages = [];
                    object.preHookMessage = [];
                    object.postHookMessage = [];
                    object.preHookScreenshots = [];
                    object.postHookScreenshots = [];
                    object.preHookScreenshotFiles = [];
                    object.postHookScreenshotFiles = [];
                }
                if (options.defaults) {
                    object.specHeading = "";
                    object.isTableDriven = false;
                    object.fileName = "";
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.itemCount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.itemCount = options.longs === String ? "0" : 0;
                }
                if (message.specHeading != null && message.hasOwnProperty("specHeading"))
                    object.specHeading = message.specHeading;
                if (message.items && message.items.length) {
                    object.items = [];
                    for (var j = 0; j < message.items.length; ++j)
                        object.items[j] = $root.gauge.messages.ProtoItem.toObject(message.items[j], options);
                }
                if (message.isTableDriven != null && message.hasOwnProperty("isTableDriven"))
                    object.isTableDriven = message.isTableDriven;
                if (message.preHookFailures && message.preHookFailures.length) {
                    object.preHookFailures = [];
                    for (var j = 0; j < message.preHookFailures.length; ++j)
                        object.preHookFailures[j] = $root.gauge.messages.ProtoHookFailure.toObject(message.preHookFailures[j], options);
                }
                if (message.postHookFailures && message.postHookFailures.length) {
                    object.postHookFailures = [];
                    for (var j = 0; j < message.postHookFailures.length; ++j)
                        object.postHookFailures[j] = $root.gauge.messages.ProtoHookFailure.toObject(message.postHookFailures[j], options);
                }
                if (message.fileName != null && message.hasOwnProperty("fileName"))
                    object.fileName = message.fileName;
                if (message.tags && message.tags.length) {
                    object.tags = [];
                    for (var j = 0; j < message.tags.length; ++j)
                        object.tags[j] = message.tags[j];
                }
                if (message.preHookMessages && message.preHookMessages.length) {
                    object.preHookMessages = [];
                    for (var j = 0; j < message.preHookMessages.length; ++j)
                        object.preHookMessages[j] = message.preHookMessages[j];
                }
                if (message.postHookMessages && message.postHookMessages.length) {
                    object.postHookMessages = [];
                    for (var j = 0; j < message.postHookMessages.length; ++j)
                        object.postHookMessages[j] = message.postHookMessages[j];
                }
                if (message.preHookMessage && message.preHookMessage.length) {
                    object.preHookMessage = [];
                    for (var j = 0; j < message.preHookMessage.length; ++j)
                        object.preHookMessage[j] = message.preHookMessage[j];
                }
                if (message.postHookMessage && message.postHookMessage.length) {
                    object.postHookMessage = [];
                    for (var j = 0; j < message.postHookMessage.length; ++j)
                        object.postHookMessage[j] = message.postHookMessage[j];
                }
                if (message.preHookScreenshots && message.preHookScreenshots.length) {
                    object.preHookScreenshots = [];
                    for (var j = 0; j < message.preHookScreenshots.length; ++j)
                        object.preHookScreenshots[j] = options.bytes === String ? $util.base64.encode(message.preHookScreenshots[j], 0, message.preHookScreenshots[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.preHookScreenshots[j]) : message.preHookScreenshots[j];
                }
                if (message.postHookScreenshots && message.postHookScreenshots.length) {
                    object.postHookScreenshots = [];
                    for (var j = 0; j < message.postHookScreenshots.length; ++j)
                        object.postHookScreenshots[j] = options.bytes === String ? $util.base64.encode(message.postHookScreenshots[j], 0, message.postHookScreenshots[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.postHookScreenshots[j]) : message.postHookScreenshots[j];
                }
                if (message.itemCount != null && message.hasOwnProperty("itemCount"))
                    if (typeof message.itemCount === "number")
                        object.itemCount = options.longs === String ? String(message.itemCount) : message.itemCount;
                    else
                        object.itemCount = options.longs === String ? $util.Long.prototype.toString.call(message.itemCount) : options.longs === Number ? new $util.LongBits(message.itemCount.low >>> 0, message.itemCount.high >>> 0).toNumber() : message.itemCount;
                if (message.preHookScreenshotFiles && message.preHookScreenshotFiles.length) {
                    object.preHookScreenshotFiles = [];
                    for (var j = 0; j < message.preHookScreenshotFiles.length; ++j)
                        object.preHookScreenshotFiles[j] = message.preHookScreenshotFiles[j];
                }
                if (message.postHookScreenshotFiles && message.postHookScreenshotFiles.length) {
                    object.postHookScreenshotFiles = [];
                    for (var j = 0; j < message.postHookScreenshotFiles.length; ++j)
                        object.postHookScreenshotFiles[j] = message.postHookScreenshotFiles[j];
                }
                return object;
            };

            /**
             * Converts this ProtoSpec to JSON.
             * @function toJSON
             * @memberof gauge.messages.ProtoSpec
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ProtoSpec.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ProtoSpec;
        })();

        messages.ProtoItem = (function() {

            /**
             * Properties of a ProtoItem.
             * @memberof gauge.messages
             * @interface IProtoItem
             * @property {gauge.messages.ProtoItem.ItemType|null} [itemType] Itemtype of the current ProtoItem
             * @property {gauge.messages.IProtoStep|null} [step] Holds the Step definition. Valid only if ItemType = Step
             * @property {gauge.messages.IProtoConcept|null} [concept] Holds the Concept definition. Valid only if ItemType = Concept
             * @property {gauge.messages.IProtoScenario|null} [scenario] Holds the Scenario definition. Valid only if ItemType = Scenario
             * @property {gauge.messages.IProtoTableDrivenScenario|null} [tableDrivenScenario] Holds the TableDrivenScenario definition. Valid only if ItemType = TableDrivenScenario
             * @property {gauge.messages.IProtoComment|null} [comment] Holds the Comment definition. Valid only if ItemType = Comment
             * @property {gauge.messages.IProtoTable|null} [table] Holds the Table definition. Valid only if ItemType = Table
             * @property {gauge.messages.IProtoTags|null} [tags] Holds the Tags definition. Valid only if ItemType = Tags
             * @property {string|null} [fileName] Holds the Filename that the item belongs to
             */

            /**
             * Constructs a new ProtoItem.
             * @memberof gauge.messages
             * @classdesc Container for all valid Items under a Specification.
             * @implements IProtoItem
             * @constructor
             * @param {gauge.messages.IProtoItem=} [properties] Properties to set
             */
            function ProtoItem(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Itemtype of the current ProtoItem
             * @member {gauge.messages.ProtoItem.ItemType} itemType
             * @memberof gauge.messages.ProtoItem
             * @instance
             */
            ProtoItem.prototype.itemType = 0;

            /**
             * Holds the Step definition. Valid only if ItemType = Step
             * @member {gauge.messages.IProtoStep|null|undefined} step
             * @memberof gauge.messages.ProtoItem
             * @instance
             */
            ProtoItem.prototype.step = null;

            /**
             * Holds the Concept definition. Valid only if ItemType = Concept
             * @member {gauge.messages.IProtoConcept|null|undefined} concept
             * @memberof gauge.messages.ProtoItem
             * @instance
             */
            ProtoItem.prototype.concept = null;

            /**
             * Holds the Scenario definition. Valid only if ItemType = Scenario
             * @member {gauge.messages.IProtoScenario|null|undefined} scenario
             * @memberof gauge.messages.ProtoItem
             * @instance
             */
            ProtoItem.prototype.scenario = null;

            /**
             * Holds the TableDrivenScenario definition. Valid only if ItemType = TableDrivenScenario
             * @member {gauge.messages.IProtoTableDrivenScenario|null|undefined} tableDrivenScenario
             * @memberof gauge.messages.ProtoItem
             * @instance
             */
            ProtoItem.prototype.tableDrivenScenario = null;

            /**
             * Holds the Comment definition. Valid only if ItemType = Comment
             * @member {gauge.messages.IProtoComment|null|undefined} comment
             * @memberof gauge.messages.ProtoItem
             * @instance
             */
            ProtoItem.prototype.comment = null;

            /**
             * Holds the Table definition. Valid only if ItemType = Table
             * @member {gauge.messages.IProtoTable|null|undefined} table
             * @memberof gauge.messages.ProtoItem
             * @instance
             */
            ProtoItem.prototype.table = null;

            /**
             * Holds the Tags definition. Valid only if ItemType = Tags
             * @member {gauge.messages.IProtoTags|null|undefined} tags
             * @memberof gauge.messages.ProtoItem
             * @instance
             */
            ProtoItem.prototype.tags = null;

            /**
             * Holds the Filename that the item belongs to
             * @member {string} fileName
             * @memberof gauge.messages.ProtoItem
             * @instance
             */
            ProtoItem.prototype.fileName = "";

            /**
             * Creates a new ProtoItem instance using the specified properties.
             * @function create
             * @memberof gauge.messages.ProtoItem
             * @static
             * @param {gauge.messages.IProtoItem=} [properties] Properties to set
             * @returns {gauge.messages.ProtoItem} ProtoItem instance
             */
            ProtoItem.create = function create(properties) {
                return new ProtoItem(properties);
            };

            /**
             * Encodes the specified ProtoItem message. Does not implicitly {@link gauge.messages.ProtoItem.verify|verify} messages.
             * @function encode
             * @memberof gauge.messages.ProtoItem
             * @static
             * @param {gauge.messages.IProtoItem} message ProtoItem message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ProtoItem.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.itemType != null && message.hasOwnProperty("itemType"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.itemType);
                if (message.step != null && message.hasOwnProperty("step"))
                    $root.gauge.messages.ProtoStep.encode(message.step, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.concept != null && message.hasOwnProperty("concept"))
                    $root.gauge.messages.ProtoConcept.encode(message.concept, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.scenario != null && message.hasOwnProperty("scenario"))
                    $root.gauge.messages.ProtoScenario.encode(message.scenario, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.tableDrivenScenario != null && message.hasOwnProperty("tableDrivenScenario"))
                    $root.gauge.messages.ProtoTableDrivenScenario.encode(message.tableDrivenScenario, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.comment != null && message.hasOwnProperty("comment"))
                    $root.gauge.messages.ProtoComment.encode(message.comment, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.table != null && message.hasOwnProperty("table"))
                    $root.gauge.messages.ProtoTable.encode(message.table, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                if (message.tags != null && message.hasOwnProperty("tags"))
                    $root.gauge.messages.ProtoTags.encode(message.tags, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                if (message.fileName != null && message.hasOwnProperty("fileName"))
                    writer.uint32(/* id 9, wireType 2 =*/74).string(message.fileName);
                return writer;
            };

            /**
             * Encodes the specified ProtoItem message, length delimited. Does not implicitly {@link gauge.messages.ProtoItem.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gauge.messages.ProtoItem
             * @static
             * @param {gauge.messages.IProtoItem} message ProtoItem message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ProtoItem.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ProtoItem message from the specified reader or buffer.
             * @function decode
             * @memberof gauge.messages.ProtoItem
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gauge.messages.ProtoItem} ProtoItem
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ProtoItem.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gauge.messages.ProtoItem();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.itemType = reader.int32();
                        break;
                    case 2:
                        message.step = $root.gauge.messages.ProtoStep.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.concept = $root.gauge.messages.ProtoConcept.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.scenario = $root.gauge.messages.ProtoScenario.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.tableDrivenScenario = $root.gauge.messages.ProtoTableDrivenScenario.decode(reader, reader.uint32());
                        break;
                    case 6:
                        message.comment = $root.gauge.messages.ProtoComment.decode(reader, reader.uint32());
                        break;
                    case 7:
                        message.table = $root.gauge.messages.ProtoTable.decode(reader, reader.uint32());
                        break;
                    case 8:
                        message.tags = $root.gauge.messages.ProtoTags.decode(reader, reader.uint32());
                        break;
                    case 9:
                        message.fileName = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ProtoItem message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gauge.messages.ProtoItem
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gauge.messages.ProtoItem} ProtoItem
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ProtoItem.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ProtoItem message.
             * @function verify
             * @memberof gauge.messages.ProtoItem
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ProtoItem.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.itemType != null && message.hasOwnProperty("itemType"))
                    switch (message.itemType) {
                    default:
                        return "itemType: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                        break;
                    }
                if (message.step != null && message.hasOwnProperty("step")) {
                    var error = $root.gauge.messages.ProtoStep.verify(message.step);
                    if (error)
                        return "step." + error;
                }
                if (message.concept != null && message.hasOwnProperty("concept")) {
                    var error = $root.gauge.messages.ProtoConcept.verify(message.concept);
                    if (error)
                        return "concept." + error;
                }
                if (message.scenario != null && message.hasOwnProperty("scenario")) {
                    var error = $root.gauge.messages.ProtoScenario.verify(message.scenario);
                    if (error)
                        return "scenario." + error;
                }
                if (message.tableDrivenScenario != null && message.hasOwnProperty("tableDrivenScenario")) {
                    var error = $root.gauge.messages.ProtoTableDrivenScenario.verify(message.tableDrivenScenario);
                    if (error)
                        return "tableDrivenScenario." + error;
                }
                if (message.comment != null && message.hasOwnProperty("comment")) {
                    var error = $root.gauge.messages.ProtoComment.verify(message.comment);
                    if (error)
                        return "comment." + error;
                }
                if (message.table != null && message.hasOwnProperty("table")) {
                    var error = $root.gauge.messages.ProtoTable.verify(message.table);
                    if (error)
                        return "table." + error;
                }
                if (message.tags != null && message.hasOwnProperty("tags")) {
                    var error = $root.gauge.messages.ProtoTags.verify(message.tags);
                    if (error)
                        return "tags." + error;
                }
                if (message.fileName != null && message.hasOwnProperty("fileName"))
                    if (!$util.isString(message.fileName))
                        return "fileName: string expected";
                return null;
            };

            /**
             * Creates a ProtoItem message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gauge.messages.ProtoItem
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gauge.messages.ProtoItem} ProtoItem
             */
            ProtoItem.fromObject = function fromObject(object) {
                if (object instanceof $root.gauge.messages.ProtoItem)
                    return object;
                var message = new $root.gauge.messages.ProtoItem();
                switch (object.itemType) {
                case "Step":
                case 0:
                    message.itemType = 0;
                    break;
                case "Comment":
                case 1:
                    message.itemType = 1;
                    break;
                case "Concept":
                case 2:
                    message.itemType = 2;
                    break;
                case "Scenario":
                case 3:
                    message.itemType = 3;
                    break;
                case "TableDrivenScenario":
                case 4:
                    message.itemType = 4;
                    break;
                case "Table":
                case 5:
                    message.itemType = 5;
                    break;
                case "Tags":
                case 6:
                    message.itemType = 6;
                    break;
                }
                if (object.step != null) {
                    if (typeof object.step !== "object")
                        throw TypeError(".gauge.messages.ProtoItem.step: object expected");
                    message.step = $root.gauge.messages.ProtoStep.fromObject(object.step);
                }
                if (object.concept != null) {
                    if (typeof object.concept !== "object")
                        throw TypeError(".gauge.messages.ProtoItem.concept: object expected");
                    message.concept = $root.gauge.messages.ProtoConcept.fromObject(object.concept);
                }
                if (object.scenario != null) {
                    if (typeof object.scenario !== "object")
                        throw TypeError(".gauge.messages.ProtoItem.scenario: object expected");
                    message.scenario = $root.gauge.messages.ProtoScenario.fromObject(object.scenario);
                }
                if (object.tableDrivenScenario != null) {
                    if (typeof object.tableDrivenScenario !== "object")
                        throw TypeError(".gauge.messages.ProtoItem.tableDrivenScenario: object expected");
                    message.tableDrivenScenario = $root.gauge.messages.ProtoTableDrivenScenario.fromObject(object.tableDrivenScenario);
                }
                if (object.comment != null) {
                    if (typeof object.comment !== "object")
                        throw TypeError(".gauge.messages.ProtoItem.comment: object expected");
                    message.comment = $root.gauge.messages.ProtoComment.fromObject(object.comment);
                }
                if (object.table != null) {
                    if (typeof object.table !== "object")
                        throw TypeError(".gauge.messages.ProtoItem.table: object expected");
                    message.table = $root.gauge.messages.ProtoTable.fromObject(object.table);
                }
                if (object.tags != null) {
                    if (typeof object.tags !== "object")
                        throw TypeError(".gauge.messages.ProtoItem.tags: object expected");
                    message.tags = $root.gauge.messages.ProtoTags.fromObject(object.tags);
                }
                if (object.fileName != null)
                    message.fileName = String(object.fileName);
                return message;
            };

            /**
             * Creates a plain object from a ProtoItem message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gauge.messages.ProtoItem
             * @static
             * @param {gauge.messages.ProtoItem} message ProtoItem
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ProtoItem.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.itemType = options.enums === String ? "Step" : 0;
                    object.step = null;
                    object.concept = null;
                    object.scenario = null;
                    object.tableDrivenScenario = null;
                    object.comment = null;
                    object.table = null;
                    object.tags = null;
                    object.fileName = "";
                }
                if (message.itemType != null && message.hasOwnProperty("itemType"))
                    object.itemType = options.enums === String ? $root.gauge.messages.ProtoItem.ItemType[message.itemType] : message.itemType;
                if (message.step != null && message.hasOwnProperty("step"))
                    object.step = $root.gauge.messages.ProtoStep.toObject(message.step, options);
                if (message.concept != null && message.hasOwnProperty("concept"))
                    object.concept = $root.gauge.messages.ProtoConcept.toObject(message.concept, options);
                if (message.scenario != null && message.hasOwnProperty("scenario"))
                    object.scenario = $root.gauge.messages.ProtoScenario.toObject(message.scenario, options);
                if (message.tableDrivenScenario != null && message.hasOwnProperty("tableDrivenScenario"))
                    object.tableDrivenScenario = $root.gauge.messages.ProtoTableDrivenScenario.toObject(message.tableDrivenScenario, options);
                if (message.comment != null && message.hasOwnProperty("comment"))
                    object.comment = $root.gauge.messages.ProtoComment.toObject(message.comment, options);
                if (message.table != null && message.hasOwnProperty("table"))
                    object.table = $root.gauge.messages.ProtoTable.toObject(message.table, options);
                if (message.tags != null && message.hasOwnProperty("tags"))
                    object.tags = $root.gauge.messages.ProtoTags.toObject(message.tags, options);
                if (message.fileName != null && message.hasOwnProperty("fileName"))
                    object.fileName = message.fileName;
                return object;
            };

            /**
             * Converts this ProtoItem to JSON.
             * @function toJSON
             * @memberof gauge.messages.ProtoItem
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ProtoItem.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Enumerates various item types that the proto item can contain. Valid types are: Step, Comment, Concept, Scenario, TableDrivenScenario, Table, Tags
             * @name gauge.messages.ProtoItem.ItemType
             * @enum {string}
             * @property {number} Step=0 Step value
             * @property {number} Comment=1 Comment value
             * @property {number} Concept=2 Concept value
             * @property {number} Scenario=3 Scenario value
             * @property {number} TableDrivenScenario=4 TableDrivenScenario value
             * @property {number} Table=5 Table value
             * @property {number} Tags=6 Tags value
             */
            ProtoItem.ItemType = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "Step"] = 0;
                values[valuesById[1] = "Comment"] = 1;
                values[valuesById[2] = "Concept"] = 2;
                values[valuesById[3] = "Scenario"] = 3;
                values[valuesById[4] = "TableDrivenScenario"] = 4;
                values[valuesById[5] = "Table"] = 5;
                values[valuesById[6] = "Tags"] = 6;
                return values;
            })();

            return ProtoItem;
        })();

        /**
         * Execution Status
         * @name gauge.messages.ExecutionStatus
         * @enum {string}
         * @property {number} NOTEXECUTED=0 NOTEXECUTED value
         * @property {number} PASSED=1 PASSED value
         * @property {number} FAILED=2 FAILED value
         * @property {number} SKIPPED=3 SKIPPED value
         */
        messages.ExecutionStatus = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "NOTEXECUTED"] = 0;
            values[valuesById[1] = "PASSED"] = 1;
            values[valuesById[2] = "FAILED"] = 2;
            values[valuesById[3] = "SKIPPED"] = 3;
            return values;
        })();

        messages.ProtoScenario = (function() {

            /**
             * Properties of a ProtoScenario.
             * @memberof gauge.messages
             * @interface IProtoScenario
             * @property {string|null} [scenarioHeading] Heading of the given Scenario
             * @property {boolean|null} [failed] Flag to indicate if the Scenario execution failed
             * @property {Array.<gauge.messages.IProtoItem>|null} [contexts] Collection of Context steps. The Context steps are executed before every run.
             * @property {Array.<gauge.messages.IProtoItem>|null} [scenarioItems] Collection of Items under a scenario. These could be Steps, Comments, Tags, TableDrivenScenarios or Tables
             * @property {gauge.messages.IProtoHookFailure|null} [preHookFailure] Contains a 'before' hook failure message. This happens when the `before_scenario` hook has an error.
             * @property {gauge.messages.IProtoHookFailure|null} [postHookFailure] Contains a 'after' hook failure message. This happens when the `after_scenario` hook has an error.
             * @property {Array.<string>|null} [tags] Contains a list of tags that are defined at the specification level. Scenario tags are not present here.
             * @property {number|Long|null} [executionTime] Holds the time taken for executing this scenario.
             * @property {boolean|null} [skipped] Flag to indicate if the Scenario execution is skipped
             * @property {Array.<string>|null} [skipErrors] Holds the error messages for skipping scenario from execution
             * @property {string|null} [ID] Holds the unique Identifier of a scenario.
             * @property {Array.<gauge.messages.IProtoItem>|null} [tearDownSteps] Collection of Teardown steps. The Teardown steps are executed after every run.
             * @property {gauge.messages.ISpan|null} [span] Span(start, end) of scenario
             * @property {gauge.messages.ExecutionStatus|null} [executionStatus] Execution status for the scenario
             * @property {Array.<string>|null} [preHookMessages] Additional information at pre hook exec time to be available on reports
             * @property {Array.<string>|null} [postHookMessages] Additional information at post hook exec time to be available on reports
             * @property {Array.<string>|null} [preHookMessage] [DEPRECATED, use preHookMessages] Additional information at pre hook exec time to be available on reports
             * @property {Array.<string>|null} [postHookMessage] [DEPRECATED, use postHookMessages] Additional information at post hook exec time to be available on reports
             * @property {Array.<Uint8Array>|null} [preHookScreenshots] [DEPRECATED, use preHookScreenshotFiles] Capture Screenshot at pre hook exec time to be available on reports
             * @property {Array.<Uint8Array>|null} [postHookScreenshots] [DEPRECATED, use postHookScreenshotFiles] Capture Screenshot at post hook exec time to be available on reports
             * @property {Array.<string>|null} [preHookScreenshotFiles] Screenshots captured on pre hook exec time to be available on reports
             * @property {Array.<string>|null} [postHookScreenshotFiles] Screenshots captured on post hook exec time to be available on reports
             */

            /**
             * Constructs a new ProtoScenario.
             * @memberof gauge.messages
             * @classdesc A proto object representing a Scenario
             * @implements IProtoScenario
             * @constructor
             * @param {gauge.messages.IProtoScenario=} [properties] Properties to set
             */
            function ProtoScenario(properties) {
                this.contexts = [];
                this.scenarioItems = [];
                this.tags = [];
                this.skipErrors = [];
                this.tearDownSteps = [];
                this.preHookMessages = [];
                this.postHookMessages = [];
                this.preHookMessage = [];
                this.postHookMessage = [];
                this.preHookScreenshots = [];
                this.postHookScreenshots = [];
                this.preHookScreenshotFiles = [];
                this.postHookScreenshotFiles = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Heading of the given Scenario
             * @member {string} scenarioHeading
             * @memberof gauge.messages.ProtoScenario
             * @instance
             */
            ProtoScenario.prototype.scenarioHeading = "";

            /**
             * Flag to indicate if the Scenario execution failed
             * @member {boolean} failed
             * @memberof gauge.messages.ProtoScenario
             * @instance
             */
            ProtoScenario.prototype.failed = false;

            /**
             * Collection of Context steps. The Context steps are executed before every run.
             * @member {Array.<gauge.messages.IProtoItem>} contexts
             * @memberof gauge.messages.ProtoScenario
             * @instance
             */
            ProtoScenario.prototype.contexts = $util.emptyArray;

            /**
             * Collection of Items under a scenario. These could be Steps, Comments, Tags, TableDrivenScenarios or Tables
             * @member {Array.<gauge.messages.IProtoItem>} scenarioItems
             * @memberof gauge.messages.ProtoScenario
             * @instance
             */
            ProtoScenario.prototype.scenarioItems = $util.emptyArray;

            /**
             * Contains a 'before' hook failure message. This happens when the `before_scenario` hook has an error.
             * @member {gauge.messages.IProtoHookFailure|null|undefined} preHookFailure
             * @memberof gauge.messages.ProtoScenario
             * @instance
             */
            ProtoScenario.prototype.preHookFailure = null;

            /**
             * Contains a 'after' hook failure message. This happens when the `after_scenario` hook has an error.
             * @member {gauge.messages.IProtoHookFailure|null|undefined} postHookFailure
             * @memberof gauge.messages.ProtoScenario
             * @instance
             */
            ProtoScenario.prototype.postHookFailure = null;

            /**
             * Contains a list of tags that are defined at the specification level. Scenario tags are not present here.
             * @member {Array.<string>} tags
             * @memberof gauge.messages.ProtoScenario
             * @instance
             */
            ProtoScenario.prototype.tags = $util.emptyArray;

            /**
             * Holds the time taken for executing this scenario.
             * @member {number|Long} executionTime
             * @memberof gauge.messages.ProtoScenario
             * @instance
             */
            ProtoScenario.prototype.executionTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Flag to indicate if the Scenario execution is skipped
             * @member {boolean} skipped
             * @memberof gauge.messages.ProtoScenario
             * @instance
             */
            ProtoScenario.prototype.skipped = false;

            /**
             * Holds the error messages for skipping scenario from execution
             * @member {Array.<string>} skipErrors
             * @memberof gauge.messages.ProtoScenario
             * @instance
             */
            ProtoScenario.prototype.skipErrors = $util.emptyArray;

            /**
             * Holds the unique Identifier of a scenario.
             * @member {string} ID
             * @memberof gauge.messages.ProtoScenario
             * @instance
             */
            ProtoScenario.prototype.ID = "";

            /**
             * Collection of Teardown steps. The Teardown steps are executed after every run.
             * @member {Array.<gauge.messages.IProtoItem>} tearDownSteps
             * @memberof gauge.messages.ProtoScenario
             * @instance
             */
            ProtoScenario.prototype.tearDownSteps = $util.emptyArray;

            /**
             * Span(start, end) of scenario
             * @member {gauge.messages.ISpan|null|undefined} span
             * @memberof gauge.messages.ProtoScenario
             * @instance
             */
            ProtoScenario.prototype.span = null;

            /**
             * Execution status for the scenario
             * @member {gauge.messages.ExecutionStatus} executionStatus
             * @memberof gauge.messages.ProtoScenario
             * @instance
             */
            ProtoScenario.prototype.executionStatus = 0;

            /**
             * Additional information at pre hook exec time to be available on reports
             * @member {Array.<string>} preHookMessages
             * @memberof gauge.messages.ProtoScenario
             * @instance
             */
            ProtoScenario.prototype.preHookMessages = $util.emptyArray;

            /**
             * Additional information at post hook exec time to be available on reports
             * @member {Array.<string>} postHookMessages
             * @memberof gauge.messages.ProtoScenario
             * @instance
             */
            ProtoScenario.prototype.postHookMessages = $util.emptyArray;

            /**
             * [DEPRECATED, use preHookMessages] Additional information at pre hook exec time to be available on reports
             * @member {Array.<string>} preHookMessage
             * @memberof gauge.messages.ProtoScenario
             * @instance
             */
            ProtoScenario.prototype.preHookMessage = $util.emptyArray;

            /**
             * [DEPRECATED, use postHookMessages] Additional information at post hook exec time to be available on reports
             * @member {Array.<string>} postHookMessage
             * @memberof gauge.messages.ProtoScenario
             * @instance
             */
            ProtoScenario.prototype.postHookMessage = $util.emptyArray;

            /**
             * [DEPRECATED, use preHookScreenshotFiles] Capture Screenshot at pre hook exec time to be available on reports
             * @member {Array.<Uint8Array>} preHookScreenshots
             * @memberof gauge.messages.ProtoScenario
             * @instance
             */
            ProtoScenario.prototype.preHookScreenshots = $util.emptyArray;

            /**
             * [DEPRECATED, use postHookScreenshotFiles] Capture Screenshot at post hook exec time to be available on reports
             * @member {Array.<Uint8Array>} postHookScreenshots
             * @memberof gauge.messages.ProtoScenario
             * @instance
             */
            ProtoScenario.prototype.postHookScreenshots = $util.emptyArray;

            /**
             * Screenshots captured on pre hook exec time to be available on reports
             * @member {Array.<string>} preHookScreenshotFiles
             * @memberof gauge.messages.ProtoScenario
             * @instance
             */
            ProtoScenario.prototype.preHookScreenshotFiles = $util.emptyArray;

            /**
             * Screenshots captured on post hook exec time to be available on reports
             * @member {Array.<string>} postHookScreenshotFiles
             * @memberof gauge.messages.ProtoScenario
             * @instance
             */
            ProtoScenario.prototype.postHookScreenshotFiles = $util.emptyArray;

            /**
             * Creates a new ProtoScenario instance using the specified properties.
             * @function create
             * @memberof gauge.messages.ProtoScenario
             * @static
             * @param {gauge.messages.IProtoScenario=} [properties] Properties to set
             * @returns {gauge.messages.ProtoScenario} ProtoScenario instance
             */
            ProtoScenario.create = function create(properties) {
                return new ProtoScenario(properties);
            };

            /**
             * Encodes the specified ProtoScenario message. Does not implicitly {@link gauge.messages.ProtoScenario.verify|verify} messages.
             * @function encode
             * @memberof gauge.messages.ProtoScenario
             * @static
             * @param {gauge.messages.IProtoScenario} message ProtoScenario message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ProtoScenario.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.scenarioHeading != null && message.hasOwnProperty("scenarioHeading"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.scenarioHeading);
                if (message.failed != null && message.hasOwnProperty("failed"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.failed);
                if (message.contexts != null && message.contexts.length)
                    for (var i = 0; i < message.contexts.length; ++i)
                        $root.gauge.messages.ProtoItem.encode(message.contexts[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.scenarioItems != null && message.scenarioItems.length)
                    for (var i = 0; i < message.scenarioItems.length; ++i)
                        $root.gauge.messages.ProtoItem.encode(message.scenarioItems[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.preHookFailure != null && message.hasOwnProperty("preHookFailure"))
                    $root.gauge.messages.ProtoHookFailure.encode(message.preHookFailure, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.postHookFailure != null && message.hasOwnProperty("postHookFailure"))
                    $root.gauge.messages.ProtoHookFailure.encode(message.postHookFailure, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.tags != null && message.tags.length)
                    for (var i = 0; i < message.tags.length; ++i)
                        writer.uint32(/* id 7, wireType 2 =*/58).string(message.tags[i]);
                if (message.executionTime != null && message.hasOwnProperty("executionTime"))
                    writer.uint32(/* id 8, wireType 0 =*/64).int64(message.executionTime);
                if (message.skipped != null && message.hasOwnProperty("skipped"))
                    writer.uint32(/* id 9, wireType 0 =*/72).bool(message.skipped);
                if (message.skipErrors != null && message.skipErrors.length)
                    for (var i = 0; i < message.skipErrors.length; ++i)
                        writer.uint32(/* id 10, wireType 2 =*/82).string(message.skipErrors[i]);
                if (message.ID != null && message.hasOwnProperty("ID"))
                    writer.uint32(/* id 11, wireType 2 =*/90).string(message.ID);
                if (message.tearDownSteps != null && message.tearDownSteps.length)
                    for (var i = 0; i < message.tearDownSteps.length; ++i)
                        $root.gauge.messages.ProtoItem.encode(message.tearDownSteps[i], writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
                if (message.span != null && message.hasOwnProperty("span"))
                    $root.gauge.messages.Span.encode(message.span, writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
                if (message.executionStatus != null && message.hasOwnProperty("executionStatus"))
                    writer.uint32(/* id 14, wireType 0 =*/112).int32(message.executionStatus);
                if (message.preHookMessages != null && message.preHookMessages.length)
                    for (var i = 0; i < message.preHookMessages.length; ++i)
                        writer.uint32(/* id 15, wireType 2 =*/122).string(message.preHookMessages[i]);
                if (message.postHookMessages != null && message.postHookMessages.length)
                    for (var i = 0; i < message.postHookMessages.length; ++i)
                        writer.uint32(/* id 16, wireType 2 =*/130).string(message.postHookMessages[i]);
                if (message.preHookMessage != null && message.preHookMessage.length)
                    for (var i = 0; i < message.preHookMessage.length; ++i)
                        writer.uint32(/* id 17, wireType 2 =*/138).string(message.preHookMessage[i]);
                if (message.postHookMessage != null && message.postHookMessage.length)
                    for (var i = 0; i < message.postHookMessage.length; ++i)
                        writer.uint32(/* id 18, wireType 2 =*/146).string(message.postHookMessage[i]);
                if (message.preHookScreenshots != null && message.preHookScreenshots.length)
                    for (var i = 0; i < message.preHookScreenshots.length; ++i)
                        writer.uint32(/* id 19, wireType 2 =*/154).bytes(message.preHookScreenshots[i]);
                if (message.postHookScreenshots != null && message.postHookScreenshots.length)
                    for (var i = 0; i < message.postHookScreenshots.length; ++i)
                        writer.uint32(/* id 20, wireType 2 =*/162).bytes(message.postHookScreenshots[i]);
                if (message.preHookScreenshotFiles != null && message.preHookScreenshotFiles.length)
                    for (var i = 0; i < message.preHookScreenshotFiles.length; ++i)
                        writer.uint32(/* id 21, wireType 2 =*/170).string(message.preHookScreenshotFiles[i]);
                if (message.postHookScreenshotFiles != null && message.postHookScreenshotFiles.length)
                    for (var i = 0; i < message.postHookScreenshotFiles.length; ++i)
                        writer.uint32(/* id 22, wireType 2 =*/178).string(message.postHookScreenshotFiles[i]);
                return writer;
            };

            /**
             * Encodes the specified ProtoScenario message, length delimited. Does not implicitly {@link gauge.messages.ProtoScenario.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gauge.messages.ProtoScenario
             * @static
             * @param {gauge.messages.IProtoScenario} message ProtoScenario message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ProtoScenario.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ProtoScenario message from the specified reader or buffer.
             * @function decode
             * @memberof gauge.messages.ProtoScenario
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gauge.messages.ProtoScenario} ProtoScenario
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ProtoScenario.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gauge.messages.ProtoScenario();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.scenarioHeading = reader.string();
                        break;
                    case 2:
                        message.failed = reader.bool();
                        break;
                    case 3:
                        if (!(message.contexts && message.contexts.length))
                            message.contexts = [];
                        message.contexts.push($root.gauge.messages.ProtoItem.decode(reader, reader.uint32()));
                        break;
                    case 4:
                        if (!(message.scenarioItems && message.scenarioItems.length))
                            message.scenarioItems = [];
                        message.scenarioItems.push($root.gauge.messages.ProtoItem.decode(reader, reader.uint32()));
                        break;
                    case 5:
                        message.preHookFailure = $root.gauge.messages.ProtoHookFailure.decode(reader, reader.uint32());
                        break;
                    case 6:
                        message.postHookFailure = $root.gauge.messages.ProtoHookFailure.decode(reader, reader.uint32());
                        break;
                    case 7:
                        if (!(message.tags && message.tags.length))
                            message.tags = [];
                        message.tags.push(reader.string());
                        break;
                    case 8:
                        message.executionTime = reader.int64();
                        break;
                    case 9:
                        message.skipped = reader.bool();
                        break;
                    case 10:
                        if (!(message.skipErrors && message.skipErrors.length))
                            message.skipErrors = [];
                        message.skipErrors.push(reader.string());
                        break;
                    case 11:
                        message.ID = reader.string();
                        break;
                    case 12:
                        if (!(message.tearDownSteps && message.tearDownSteps.length))
                            message.tearDownSteps = [];
                        message.tearDownSteps.push($root.gauge.messages.ProtoItem.decode(reader, reader.uint32()));
                        break;
                    case 13:
                        message.span = $root.gauge.messages.Span.decode(reader, reader.uint32());
                        break;
                    case 14:
                        message.executionStatus = reader.int32();
                        break;
                    case 15:
                        if (!(message.preHookMessages && message.preHookMessages.length))
                            message.preHookMessages = [];
                        message.preHookMessages.push(reader.string());
                        break;
                    case 16:
                        if (!(message.postHookMessages && message.postHookMessages.length))
                            message.postHookMessages = [];
                        message.postHookMessages.push(reader.string());
                        break;
                    case 17:
                        if (!(message.preHookMessage && message.preHookMessage.length))
                            message.preHookMessage = [];
                        message.preHookMessage.push(reader.string());
                        break;
                    case 18:
                        if (!(message.postHookMessage && message.postHookMessage.length))
                            message.postHookMessage = [];
                        message.postHookMessage.push(reader.string());
                        break;
                    case 19:
                        if (!(message.preHookScreenshots && message.preHookScreenshots.length))
                            message.preHookScreenshots = [];
                        message.preHookScreenshots.push(reader.bytes());
                        break;
                    case 20:
                        if (!(message.postHookScreenshots && message.postHookScreenshots.length))
                            message.postHookScreenshots = [];
                        message.postHookScreenshots.push(reader.bytes());
                        break;
                    case 21:
                        if (!(message.preHookScreenshotFiles && message.preHookScreenshotFiles.length))
                            message.preHookScreenshotFiles = [];
                        message.preHookScreenshotFiles.push(reader.string());
                        break;
                    case 22:
                        if (!(message.postHookScreenshotFiles && message.postHookScreenshotFiles.length))
                            message.postHookScreenshotFiles = [];
                        message.postHookScreenshotFiles.push(reader.string());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ProtoScenario message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gauge.messages.ProtoScenario
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gauge.messages.ProtoScenario} ProtoScenario
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ProtoScenario.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ProtoScenario message.
             * @function verify
             * @memberof gauge.messages.ProtoScenario
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ProtoScenario.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.scenarioHeading != null && message.hasOwnProperty("scenarioHeading"))
                    if (!$util.isString(message.scenarioHeading))
                        return "scenarioHeading: string expected";
                if (message.failed != null && message.hasOwnProperty("failed"))
                    if (typeof message.failed !== "boolean")
                        return "failed: boolean expected";
                if (message.contexts != null && message.hasOwnProperty("contexts")) {
                    if (!Array.isArray(message.contexts))
                        return "contexts: array expected";
                    for (var i = 0; i < message.contexts.length; ++i) {
                        var error = $root.gauge.messages.ProtoItem.verify(message.contexts[i]);
                        if (error)
                            return "contexts." + error;
                    }
                }
                if (message.scenarioItems != null && message.hasOwnProperty("scenarioItems")) {
                    if (!Array.isArray(message.scenarioItems))
                        return "scenarioItems: array expected";
                    for (var i = 0; i < message.scenarioItems.length; ++i) {
                        var error = $root.gauge.messages.ProtoItem.verify(message.scenarioItems[i]);
                        if (error)
                            return "scenarioItems." + error;
                    }
                }
                if (message.preHookFailure != null && message.hasOwnProperty("preHookFailure")) {
                    var error = $root.gauge.messages.ProtoHookFailure.verify(message.preHookFailure);
                    if (error)
                        return "preHookFailure." + error;
                }
                if (message.postHookFailure != null && message.hasOwnProperty("postHookFailure")) {
                    var error = $root.gauge.messages.ProtoHookFailure.verify(message.postHookFailure);
                    if (error)
                        return "postHookFailure." + error;
                }
                if (message.tags != null && message.hasOwnProperty("tags")) {
                    if (!Array.isArray(message.tags))
                        return "tags: array expected";
                    for (var i = 0; i < message.tags.length; ++i)
                        if (!$util.isString(message.tags[i]))
                            return "tags: string[] expected";
                }
                if (message.executionTime != null && message.hasOwnProperty("executionTime"))
                    if (!$util.isInteger(message.executionTime) && !(message.executionTime && $util.isInteger(message.executionTime.low) && $util.isInteger(message.executionTime.high)))
                        return "executionTime: integer|Long expected";
                if (message.skipped != null && message.hasOwnProperty("skipped"))
                    if (typeof message.skipped !== "boolean")
                        return "skipped: boolean expected";
                if (message.skipErrors != null && message.hasOwnProperty("skipErrors")) {
                    if (!Array.isArray(message.skipErrors))
                        return "skipErrors: array expected";
                    for (var i = 0; i < message.skipErrors.length; ++i)
                        if (!$util.isString(message.skipErrors[i]))
                            return "skipErrors: string[] expected";
                }
                if (message.ID != null && message.hasOwnProperty("ID"))
                    if (!$util.isString(message.ID))
                        return "ID: string expected";
                if (message.tearDownSteps != null && message.hasOwnProperty("tearDownSteps")) {
                    if (!Array.isArray(message.tearDownSteps))
                        return "tearDownSteps: array expected";
                    for (var i = 0; i < message.tearDownSteps.length; ++i) {
                        var error = $root.gauge.messages.ProtoItem.verify(message.tearDownSteps[i]);
                        if (error)
                            return "tearDownSteps." + error;
                    }
                }
                if (message.span != null && message.hasOwnProperty("span")) {
                    var error = $root.gauge.messages.Span.verify(message.span);
                    if (error)
                        return "span." + error;
                }
                if (message.executionStatus != null && message.hasOwnProperty("executionStatus"))
                    switch (message.executionStatus) {
                    default:
                        return "executionStatus: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                        break;
                    }
                if (message.preHookMessages != null && message.hasOwnProperty("preHookMessages")) {
                    if (!Array.isArray(message.preHookMessages))
                        return "preHookMessages: array expected";
                    for (var i = 0; i < message.preHookMessages.length; ++i)
                        if (!$util.isString(message.preHookMessages[i]))
                            return "preHookMessages: string[] expected";
                }
                if (message.postHookMessages != null && message.hasOwnProperty("postHookMessages")) {
                    if (!Array.isArray(message.postHookMessages))
                        return "postHookMessages: array expected";
                    for (var i = 0; i < message.postHookMessages.length; ++i)
                        if (!$util.isString(message.postHookMessages[i]))
                            return "postHookMessages: string[] expected";
                }
                if (message.preHookMessage != null && message.hasOwnProperty("preHookMessage")) {
                    if (!Array.isArray(message.preHookMessage))
                        return "preHookMessage: array expected";
                    for (var i = 0; i < message.preHookMessage.length; ++i)
                        if (!$util.isString(message.preHookMessage[i]))
                            return "preHookMessage: string[] expected";
                }
                if (message.postHookMessage != null && message.hasOwnProperty("postHookMessage")) {
                    if (!Array.isArray(message.postHookMessage))
                        return "postHookMessage: array expected";
                    for (var i = 0; i < message.postHookMessage.length; ++i)
                        if (!$util.isString(message.postHookMessage[i]))
                            return "postHookMessage: string[] expected";
                }
                if (message.preHookScreenshots != null && message.hasOwnProperty("preHookScreenshots")) {
                    if (!Array.isArray(message.preHookScreenshots))
                        return "preHookScreenshots: array expected";
                    for (var i = 0; i < message.preHookScreenshots.length; ++i)
                        if (!(message.preHookScreenshots[i] && typeof message.preHookScreenshots[i].length === "number" || $util.isString(message.preHookScreenshots[i])))
                            return "preHookScreenshots: buffer[] expected";
                }
                if (message.postHookScreenshots != null && message.hasOwnProperty("postHookScreenshots")) {
                    if (!Array.isArray(message.postHookScreenshots))
                        return "postHookScreenshots: array expected";
                    for (var i = 0; i < message.postHookScreenshots.length; ++i)
                        if (!(message.postHookScreenshots[i] && typeof message.postHookScreenshots[i].length === "number" || $util.isString(message.postHookScreenshots[i])))
                            return "postHookScreenshots: buffer[] expected";
                }
                if (message.preHookScreenshotFiles != null && message.hasOwnProperty("preHookScreenshotFiles")) {
                    if (!Array.isArray(message.preHookScreenshotFiles))
                        return "preHookScreenshotFiles: array expected";
                    for (var i = 0; i < message.preHookScreenshotFiles.length; ++i)
                        if (!$util.isString(message.preHookScreenshotFiles[i]))
                            return "preHookScreenshotFiles: string[] expected";
                }
                if (message.postHookScreenshotFiles != null && message.hasOwnProperty("postHookScreenshotFiles")) {
                    if (!Array.isArray(message.postHookScreenshotFiles))
                        return "postHookScreenshotFiles: array expected";
                    for (var i = 0; i < message.postHookScreenshotFiles.length; ++i)
                        if (!$util.isString(message.postHookScreenshotFiles[i]))
                            return "postHookScreenshotFiles: string[] expected";
                }
                return null;
            };

            /**
             * Creates a ProtoScenario message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gauge.messages.ProtoScenario
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gauge.messages.ProtoScenario} ProtoScenario
             */
            ProtoScenario.fromObject = function fromObject(object) {
                if (object instanceof $root.gauge.messages.ProtoScenario)
                    return object;
                var message = new $root.gauge.messages.ProtoScenario();
                if (object.scenarioHeading != null)
                    message.scenarioHeading = String(object.scenarioHeading);
                if (object.failed != null)
                    message.failed = Boolean(object.failed);
                if (object.contexts) {
                    if (!Array.isArray(object.contexts))
                        throw TypeError(".gauge.messages.ProtoScenario.contexts: array expected");
                    message.contexts = [];
                    for (var i = 0; i < object.contexts.length; ++i) {
                        if (typeof object.contexts[i] !== "object")
                            throw TypeError(".gauge.messages.ProtoScenario.contexts: object expected");
                        message.contexts[i] = $root.gauge.messages.ProtoItem.fromObject(object.contexts[i]);
                    }
                }
                if (object.scenarioItems) {
                    if (!Array.isArray(object.scenarioItems))
                        throw TypeError(".gauge.messages.ProtoScenario.scenarioItems: array expected");
                    message.scenarioItems = [];
                    for (var i = 0; i < object.scenarioItems.length; ++i) {
                        if (typeof object.scenarioItems[i] !== "object")
                            throw TypeError(".gauge.messages.ProtoScenario.scenarioItems: object expected");
                        message.scenarioItems[i] = $root.gauge.messages.ProtoItem.fromObject(object.scenarioItems[i]);
                    }
                }
                if (object.preHookFailure != null) {
                    if (typeof object.preHookFailure !== "object")
                        throw TypeError(".gauge.messages.ProtoScenario.preHookFailure: object expected");
                    message.preHookFailure = $root.gauge.messages.ProtoHookFailure.fromObject(object.preHookFailure);
                }
                if (object.postHookFailure != null) {
                    if (typeof object.postHookFailure !== "object")
                        throw TypeError(".gauge.messages.ProtoScenario.postHookFailure: object expected");
                    message.postHookFailure = $root.gauge.messages.ProtoHookFailure.fromObject(object.postHookFailure);
                }
                if (object.tags) {
                    if (!Array.isArray(object.tags))
                        throw TypeError(".gauge.messages.ProtoScenario.tags: array expected");
                    message.tags = [];
                    for (var i = 0; i < object.tags.length; ++i)
                        message.tags[i] = String(object.tags[i]);
                }
                if (object.executionTime != null)
                    if ($util.Long)
                        (message.executionTime = $util.Long.fromValue(object.executionTime)).unsigned = false;
                    else if (typeof object.executionTime === "string")
                        message.executionTime = parseInt(object.executionTime, 10);
                    else if (typeof object.executionTime === "number")
                        message.executionTime = object.executionTime;
                    else if (typeof object.executionTime === "object")
                        message.executionTime = new $util.LongBits(object.executionTime.low >>> 0, object.executionTime.high >>> 0).toNumber();
                if (object.skipped != null)
                    message.skipped = Boolean(object.skipped);
                if (object.skipErrors) {
                    if (!Array.isArray(object.skipErrors))
                        throw TypeError(".gauge.messages.ProtoScenario.skipErrors: array expected");
                    message.skipErrors = [];
                    for (var i = 0; i < object.skipErrors.length; ++i)
                        message.skipErrors[i] = String(object.skipErrors[i]);
                }
                if (object.ID != null)
                    message.ID = String(object.ID);
                if (object.tearDownSteps) {
                    if (!Array.isArray(object.tearDownSteps))
                        throw TypeError(".gauge.messages.ProtoScenario.tearDownSteps: array expected");
                    message.tearDownSteps = [];
                    for (var i = 0; i < object.tearDownSteps.length; ++i) {
                        if (typeof object.tearDownSteps[i] !== "object")
                            throw TypeError(".gauge.messages.ProtoScenario.tearDownSteps: object expected");
                        message.tearDownSteps[i] = $root.gauge.messages.ProtoItem.fromObject(object.tearDownSteps[i]);
                    }
                }
                if (object.span != null) {
                    if (typeof object.span !== "object")
                        throw TypeError(".gauge.messages.ProtoScenario.span: object expected");
                    message.span = $root.gauge.messages.Span.fromObject(object.span);
                }
                switch (object.executionStatus) {
                case "NOTEXECUTED":
                case 0:
                    message.executionStatus = 0;
                    break;
                case "PASSED":
                case 1:
                    message.executionStatus = 1;
                    break;
                case "FAILED":
                case 2:
                    message.executionStatus = 2;
                    break;
                case "SKIPPED":
                case 3:
                    message.executionStatus = 3;
                    break;
                }
                if (object.preHookMessages) {
                    if (!Array.isArray(object.preHookMessages))
                        throw TypeError(".gauge.messages.ProtoScenario.preHookMessages: array expected");
                    message.preHookMessages = [];
                    for (var i = 0; i < object.preHookMessages.length; ++i)
                        message.preHookMessages[i] = String(object.preHookMessages[i]);
                }
                if (object.postHookMessages) {
                    if (!Array.isArray(object.postHookMessages))
                        throw TypeError(".gauge.messages.ProtoScenario.postHookMessages: array expected");
                    message.postHookMessages = [];
                    for (var i = 0; i < object.postHookMessages.length; ++i)
                        message.postHookMessages[i] = String(object.postHookMessages[i]);
                }
                if (object.preHookMessage) {
                    if (!Array.isArray(object.preHookMessage))
                        throw TypeError(".gauge.messages.ProtoScenario.preHookMessage: array expected");
                    message.preHookMessage = [];
                    for (var i = 0; i < object.preHookMessage.length; ++i)
                        message.preHookMessage[i] = String(object.preHookMessage[i]);
                }
                if (object.postHookMessage) {
                    if (!Array.isArray(object.postHookMessage))
                        throw TypeError(".gauge.messages.ProtoScenario.postHookMessage: array expected");
                    message.postHookMessage = [];
                    for (var i = 0; i < object.postHookMessage.length; ++i)
                        message.postHookMessage[i] = String(object.postHookMessage[i]);
                }
                if (object.preHookScreenshots) {
                    if (!Array.isArray(object.preHookScreenshots))
                        throw TypeError(".gauge.messages.ProtoScenario.preHookScreenshots: array expected");
                    message.preHookScreenshots = [];
                    for (var i = 0; i < object.preHookScreenshots.length; ++i)
                        if (typeof object.preHookScreenshots[i] === "string")
                            $util.base64.decode(object.preHookScreenshots[i], message.preHookScreenshots[i] = $util.newBuffer($util.base64.length(object.preHookScreenshots[i])), 0);
                        else if (object.preHookScreenshots[i].length)
                            message.preHookScreenshots[i] = object.preHookScreenshots[i];
                }
                if (object.postHookScreenshots) {
                    if (!Array.isArray(object.postHookScreenshots))
                        throw TypeError(".gauge.messages.ProtoScenario.postHookScreenshots: array expected");
                    message.postHookScreenshots = [];
                    for (var i = 0; i < object.postHookScreenshots.length; ++i)
                        if (typeof object.postHookScreenshots[i] === "string")
                            $util.base64.decode(object.postHookScreenshots[i], message.postHookScreenshots[i] = $util.newBuffer($util.base64.length(object.postHookScreenshots[i])), 0);
                        else if (object.postHookScreenshots[i].length)
                            message.postHookScreenshots[i] = object.postHookScreenshots[i];
                }
                if (object.preHookScreenshotFiles) {
                    if (!Array.isArray(object.preHookScreenshotFiles))
                        throw TypeError(".gauge.messages.ProtoScenario.preHookScreenshotFiles: array expected");
                    message.preHookScreenshotFiles = [];
                    for (var i = 0; i < object.preHookScreenshotFiles.length; ++i)
                        message.preHookScreenshotFiles[i] = String(object.preHookScreenshotFiles[i]);
                }
                if (object.postHookScreenshotFiles) {
                    if (!Array.isArray(object.postHookScreenshotFiles))
                        throw TypeError(".gauge.messages.ProtoScenario.postHookScreenshotFiles: array expected");
                    message.postHookScreenshotFiles = [];
                    for (var i = 0; i < object.postHookScreenshotFiles.length; ++i)
                        message.postHookScreenshotFiles[i] = String(object.postHookScreenshotFiles[i]);
                }
                return message;
            };

            /**
             * Creates a plain object from a ProtoScenario message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gauge.messages.ProtoScenario
             * @static
             * @param {gauge.messages.ProtoScenario} message ProtoScenario
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ProtoScenario.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults) {
                    object.contexts = [];
                    object.scenarioItems = [];
                    object.tags = [];
                    object.skipErrors = [];
                    object.tearDownSteps = [];
                    object.preHookMessages = [];
                    object.postHookMessages = [];
                    object.preHookMessage = [];
                    object.postHookMessage = [];
                    object.preHookScreenshots = [];
                    object.postHookScreenshots = [];
                    object.preHookScreenshotFiles = [];
                    object.postHookScreenshotFiles = [];
                }
                if (options.defaults) {
                    object.scenarioHeading = "";
                    object.failed = false;
                    object.preHookFailure = null;
                    object.postHookFailure = null;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.executionTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.executionTime = options.longs === String ? "0" : 0;
                    object.skipped = false;
                    object.ID = "";
                    object.span = null;
                    object.executionStatus = options.enums === String ? "NOTEXECUTED" : 0;
                }
                if (message.scenarioHeading != null && message.hasOwnProperty("scenarioHeading"))
                    object.scenarioHeading = message.scenarioHeading;
                if (message.failed != null && message.hasOwnProperty("failed"))
                    object.failed = message.failed;
                if (message.contexts && message.contexts.length) {
                    object.contexts = [];
                    for (var j = 0; j < message.contexts.length; ++j)
                        object.contexts[j] = $root.gauge.messages.ProtoItem.toObject(message.contexts[j], options);
                }
                if (message.scenarioItems && message.scenarioItems.length) {
                    object.scenarioItems = [];
                    for (var j = 0; j < message.scenarioItems.length; ++j)
                        object.scenarioItems[j] = $root.gauge.messages.ProtoItem.toObject(message.scenarioItems[j], options);
                }
                if (message.preHookFailure != null && message.hasOwnProperty("preHookFailure"))
                    object.preHookFailure = $root.gauge.messages.ProtoHookFailure.toObject(message.preHookFailure, options);
                if (message.postHookFailure != null && message.hasOwnProperty("postHookFailure"))
                    object.postHookFailure = $root.gauge.messages.ProtoHookFailure.toObject(message.postHookFailure, options);
                if (message.tags && message.tags.length) {
                    object.tags = [];
                    for (var j = 0; j < message.tags.length; ++j)
                        object.tags[j] = message.tags[j];
                }
                if (message.executionTime != null && message.hasOwnProperty("executionTime"))
                    if (typeof message.executionTime === "number")
                        object.executionTime = options.longs === String ? String(message.executionTime) : message.executionTime;
                    else
                        object.executionTime = options.longs === String ? $util.Long.prototype.toString.call(message.executionTime) : options.longs === Number ? new $util.LongBits(message.executionTime.low >>> 0, message.executionTime.high >>> 0).toNumber() : message.executionTime;
                if (message.skipped != null && message.hasOwnProperty("skipped"))
                    object.skipped = message.skipped;
                if (message.skipErrors && message.skipErrors.length) {
                    object.skipErrors = [];
                    for (var j = 0; j < message.skipErrors.length; ++j)
                        object.skipErrors[j] = message.skipErrors[j];
                }
                if (message.ID != null && message.hasOwnProperty("ID"))
                    object.ID = message.ID;
                if (message.tearDownSteps && message.tearDownSteps.length) {
                    object.tearDownSteps = [];
                    for (var j = 0; j < message.tearDownSteps.length; ++j)
                        object.tearDownSteps[j] = $root.gauge.messages.ProtoItem.toObject(message.tearDownSteps[j], options);
                }
                if (message.span != null && message.hasOwnProperty("span"))
                    object.span = $root.gauge.messages.Span.toObject(message.span, options);
                if (message.executionStatus != null && message.hasOwnProperty("executionStatus"))
                    object.executionStatus = options.enums === String ? $root.gauge.messages.ExecutionStatus[message.executionStatus] : message.executionStatus;
                if (message.preHookMessages && message.preHookMessages.length) {
                    object.preHookMessages = [];
                    for (var j = 0; j < message.preHookMessages.length; ++j)
                        object.preHookMessages[j] = message.preHookMessages[j];
                }
                if (message.postHookMessages && message.postHookMessages.length) {
                    object.postHookMessages = [];
                    for (var j = 0; j < message.postHookMessages.length; ++j)
                        object.postHookMessages[j] = message.postHookMessages[j];
                }
                if (message.preHookMessage && message.preHookMessage.length) {
                    object.preHookMessage = [];
                    for (var j = 0; j < message.preHookMessage.length; ++j)
                        object.preHookMessage[j] = message.preHookMessage[j];
                }
                if (message.postHookMessage && message.postHookMessage.length) {
                    object.postHookMessage = [];
                    for (var j = 0; j < message.postHookMessage.length; ++j)
                        object.postHookMessage[j] = message.postHookMessage[j];
                }
                if (message.preHookScreenshots && message.preHookScreenshots.length) {
                    object.preHookScreenshots = [];
                    for (var j = 0; j < message.preHookScreenshots.length; ++j)
                        object.preHookScreenshots[j] = options.bytes === String ? $util.base64.encode(message.preHookScreenshots[j], 0, message.preHookScreenshots[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.preHookScreenshots[j]) : message.preHookScreenshots[j];
                }
                if (message.postHookScreenshots && message.postHookScreenshots.length) {
                    object.postHookScreenshots = [];
                    for (var j = 0; j < message.postHookScreenshots.length; ++j)
                        object.postHookScreenshots[j] = options.bytes === String ? $util.base64.encode(message.postHookScreenshots[j], 0, message.postHookScreenshots[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.postHookScreenshots[j]) : message.postHookScreenshots[j];
                }
                if (message.preHookScreenshotFiles && message.preHookScreenshotFiles.length) {
                    object.preHookScreenshotFiles = [];
                    for (var j = 0; j < message.preHookScreenshotFiles.length; ++j)
                        object.preHookScreenshotFiles[j] = message.preHookScreenshotFiles[j];
                }
                if (message.postHookScreenshotFiles && message.postHookScreenshotFiles.length) {
                    object.postHookScreenshotFiles = [];
                    for (var j = 0; j < message.postHookScreenshotFiles.length; ++j)
                        object.postHookScreenshotFiles[j] = message.postHookScreenshotFiles[j];
                }
                return object;
            };

            /**
             * Converts this ProtoScenario to JSON.
             * @function toJSON
             * @memberof gauge.messages.ProtoScenario
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ProtoScenario.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ProtoScenario;
        })();

        messages.Span = (function() {

            /**
             * Properties of a Span.
             * @memberof gauge.messages
             * @interface ISpan
             * @property {number|Long|null} [start] Span start
             * @property {number|Long|null} [end] Span end
             * @property {number|Long|null} [startChar] Span startChar
             * @property {number|Long|null} [endChar] Span endChar
             */

            /**
             * Constructs a new Span.
             * @memberof gauge.messages
             * @classdesc A proto object representing a Span of content
             * @implements ISpan
             * @constructor
             * @param {gauge.messages.ISpan=} [properties] Properties to set
             */
            function Span(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Span start.
             * @member {number|Long} start
             * @memberof gauge.messages.Span
             * @instance
             */
            Span.prototype.start = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Span end.
             * @member {number|Long} end
             * @memberof gauge.messages.Span
             * @instance
             */
            Span.prototype.end = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Span startChar.
             * @member {number|Long} startChar
             * @memberof gauge.messages.Span
             * @instance
             */
            Span.prototype.startChar = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Span endChar.
             * @member {number|Long} endChar
             * @memberof gauge.messages.Span
             * @instance
             */
            Span.prototype.endChar = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new Span instance using the specified properties.
             * @function create
             * @memberof gauge.messages.Span
             * @static
             * @param {gauge.messages.ISpan=} [properties] Properties to set
             * @returns {gauge.messages.Span} Span instance
             */
            Span.create = function create(properties) {
                return new Span(properties);
            };

            /**
             * Encodes the specified Span message. Does not implicitly {@link gauge.messages.Span.verify|verify} messages.
             * @function encode
             * @memberof gauge.messages.Span
             * @static
             * @param {gauge.messages.ISpan} message Span message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Span.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.start != null && message.hasOwnProperty("start"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int64(message.start);
                if (message.end != null && message.hasOwnProperty("end"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.end);
                if (message.startChar != null && message.hasOwnProperty("startChar"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int64(message.startChar);
                if (message.endChar != null && message.hasOwnProperty("endChar"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int64(message.endChar);
                return writer;
            };

            /**
             * Encodes the specified Span message, length delimited. Does not implicitly {@link gauge.messages.Span.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gauge.messages.Span
             * @static
             * @param {gauge.messages.ISpan} message Span message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Span.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Span message from the specified reader or buffer.
             * @function decode
             * @memberof gauge.messages.Span
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gauge.messages.Span} Span
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Span.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gauge.messages.Span();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.start = reader.int64();
                        break;
                    case 2:
                        message.end = reader.int64();
                        break;
                    case 3:
                        message.startChar = reader.int64();
                        break;
                    case 4:
                        message.endChar = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Span message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gauge.messages.Span
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gauge.messages.Span} Span
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Span.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Span message.
             * @function verify
             * @memberof gauge.messages.Span
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Span.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.start != null && message.hasOwnProperty("start"))
                    if (!$util.isInteger(message.start) && !(message.start && $util.isInteger(message.start.low) && $util.isInteger(message.start.high)))
                        return "start: integer|Long expected";
                if (message.end != null && message.hasOwnProperty("end"))
                    if (!$util.isInteger(message.end) && !(message.end && $util.isInteger(message.end.low) && $util.isInteger(message.end.high)))
                        return "end: integer|Long expected";
                if (message.startChar != null && message.hasOwnProperty("startChar"))
                    if (!$util.isInteger(message.startChar) && !(message.startChar && $util.isInteger(message.startChar.low) && $util.isInteger(message.startChar.high)))
                        return "startChar: integer|Long expected";
                if (message.endChar != null && message.hasOwnProperty("endChar"))
                    if (!$util.isInteger(message.endChar) && !(message.endChar && $util.isInteger(message.endChar.low) && $util.isInteger(message.endChar.high)))
                        return "endChar: integer|Long expected";
                return null;
            };

            /**
             * Creates a Span message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gauge.messages.Span
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gauge.messages.Span} Span
             */
            Span.fromObject = function fromObject(object) {
                if (object instanceof $root.gauge.messages.Span)
                    return object;
                var message = new $root.gauge.messages.Span();
                if (object.start != null)
                    if ($util.Long)
                        (message.start = $util.Long.fromValue(object.start)).unsigned = false;
                    else if (typeof object.start === "string")
                        message.start = parseInt(object.start, 10);
                    else if (typeof object.start === "number")
                        message.start = object.start;
                    else if (typeof object.start === "object")
                        message.start = new $util.LongBits(object.start.low >>> 0, object.start.high >>> 0).toNumber();
                if (object.end != null)
                    if ($util.Long)
                        (message.end = $util.Long.fromValue(object.end)).unsigned = false;
                    else if (typeof object.end === "string")
                        message.end = parseInt(object.end, 10);
                    else if (typeof object.end === "number")
                        message.end = object.end;
                    else if (typeof object.end === "object")
                        message.end = new $util.LongBits(object.end.low >>> 0, object.end.high >>> 0).toNumber();
                if (object.startChar != null)
                    if ($util.Long)
                        (message.startChar = $util.Long.fromValue(object.startChar)).unsigned = false;
                    else if (typeof object.startChar === "string")
                        message.startChar = parseInt(object.startChar, 10);
                    else if (typeof object.startChar === "number")
                        message.startChar = object.startChar;
                    else if (typeof object.startChar === "object")
                        message.startChar = new $util.LongBits(object.startChar.low >>> 0, object.startChar.high >>> 0).toNumber();
                if (object.endChar != null)
                    if ($util.Long)
                        (message.endChar = $util.Long.fromValue(object.endChar)).unsigned = false;
                    else if (typeof object.endChar === "string")
                        message.endChar = parseInt(object.endChar, 10);
                    else if (typeof object.endChar === "number")
                        message.endChar = object.endChar;
                    else if (typeof object.endChar === "object")
                        message.endChar = new $util.LongBits(object.endChar.low >>> 0, object.endChar.high >>> 0).toNumber();
                return message;
            };

            /**
             * Creates a plain object from a Span message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gauge.messages.Span
             * @static
             * @param {gauge.messages.Span} message Span
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Span.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.start = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.start = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.end = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.end = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.startChar = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.startChar = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.endChar = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.endChar = options.longs === String ? "0" : 0;
                }
                if (message.start != null && message.hasOwnProperty("start"))
                    if (typeof message.start === "number")
                        object.start = options.longs === String ? String(message.start) : message.start;
                    else
                        object.start = options.longs === String ? $util.Long.prototype.toString.call(message.start) : options.longs === Number ? new $util.LongBits(message.start.low >>> 0, message.start.high >>> 0).toNumber() : message.start;
                if (message.end != null && message.hasOwnProperty("end"))
                    if (typeof message.end === "number")
                        object.end = options.longs === String ? String(message.end) : message.end;
                    else
                        object.end = options.longs === String ? $util.Long.prototype.toString.call(message.end) : options.longs === Number ? new $util.LongBits(message.end.low >>> 0, message.end.high >>> 0).toNumber() : message.end;
                if (message.startChar != null && message.hasOwnProperty("startChar"))
                    if (typeof message.startChar === "number")
                        object.startChar = options.longs === String ? String(message.startChar) : message.startChar;
                    else
                        object.startChar = options.longs === String ? $util.Long.prototype.toString.call(message.startChar) : options.longs === Number ? new $util.LongBits(message.startChar.low >>> 0, message.startChar.high >>> 0).toNumber() : message.startChar;
                if (message.endChar != null && message.hasOwnProperty("endChar"))
                    if (typeof message.endChar === "number")
                        object.endChar = options.longs === String ? String(message.endChar) : message.endChar;
                    else
                        object.endChar = options.longs === String ? $util.Long.prototype.toString.call(message.endChar) : options.longs === Number ? new $util.LongBits(message.endChar.low >>> 0, message.endChar.high >>> 0).toNumber() : message.endChar;
                return object;
            };

            /**
             * Converts this Span to JSON.
             * @function toJSON
             * @memberof gauge.messages.Span
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Span.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Span;
        })();

        messages.ProtoTableDrivenScenario = (function() {

            /**
             * Properties of a ProtoTableDrivenScenario.
             * @memberof gauge.messages
             * @interface IProtoTableDrivenScenario
             * @property {gauge.messages.IProtoScenario|null} [scenario] Scenario under Table driven execution
             * @property {number|null} [tableRowIndex] Row Index of data table against which the current scenario is executed
             * @property {number|null} [scenarioTableRowIndex] Row Index of scenario data table against which the current scenario is executed
             * @property {boolean|null} [isSpecTableDriven] Executed against a spec data table
             * @property {boolean|null} [isScenarioTableDriven] Executed against a scenario data table
             * @property {gauge.messages.IProtoTable|null} [scenarioDataTable] Holds the scenario data table
             * @property {gauge.messages.IProtoTable|null} [scenarioTableRow] Hold the row of scenario data table.
             */

            /**
             * Constructs a new ProtoTableDrivenScenario.
             * @memberof gauge.messages
             * @classdesc A proto object representing a TableDrivenScenario
             * @implements IProtoTableDrivenScenario
             * @constructor
             * @param {gauge.messages.IProtoTableDrivenScenario=} [properties] Properties to set
             */
            function ProtoTableDrivenScenario(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Scenario under Table driven execution
             * @member {gauge.messages.IProtoScenario|null|undefined} scenario
             * @memberof gauge.messages.ProtoTableDrivenScenario
             * @instance
             */
            ProtoTableDrivenScenario.prototype.scenario = null;

            /**
             * Row Index of data table against which the current scenario is executed
             * @member {number} tableRowIndex
             * @memberof gauge.messages.ProtoTableDrivenScenario
             * @instance
             */
            ProtoTableDrivenScenario.prototype.tableRowIndex = 0;

            /**
             * Row Index of scenario data table against which the current scenario is executed
             * @member {number} scenarioTableRowIndex
             * @memberof gauge.messages.ProtoTableDrivenScenario
             * @instance
             */
            ProtoTableDrivenScenario.prototype.scenarioTableRowIndex = 0;

            /**
             * Executed against a spec data table
             * @member {boolean} isSpecTableDriven
             * @memberof gauge.messages.ProtoTableDrivenScenario
             * @instance
             */
            ProtoTableDrivenScenario.prototype.isSpecTableDriven = false;

            /**
             * Executed against a scenario data table
             * @member {boolean} isScenarioTableDriven
             * @memberof gauge.messages.ProtoTableDrivenScenario
             * @instance
             */
            ProtoTableDrivenScenario.prototype.isScenarioTableDriven = false;

            /**
             * Holds the scenario data table
             * @member {gauge.messages.IProtoTable|null|undefined} scenarioDataTable
             * @memberof gauge.messages.ProtoTableDrivenScenario
             * @instance
             */
            ProtoTableDrivenScenario.prototype.scenarioDataTable = null;

            /**
             * Hold the row of scenario data table.
             * @member {gauge.messages.IProtoTable|null|undefined} scenarioTableRow
             * @memberof gauge.messages.ProtoTableDrivenScenario
             * @instance
             */
            ProtoTableDrivenScenario.prototype.scenarioTableRow = null;

            /**
             * Creates a new ProtoTableDrivenScenario instance using the specified properties.
             * @function create
             * @memberof gauge.messages.ProtoTableDrivenScenario
             * @static
             * @param {gauge.messages.IProtoTableDrivenScenario=} [properties] Properties to set
             * @returns {gauge.messages.ProtoTableDrivenScenario} ProtoTableDrivenScenario instance
             */
            ProtoTableDrivenScenario.create = function create(properties) {
                return new ProtoTableDrivenScenario(properties);
            };

            /**
             * Encodes the specified ProtoTableDrivenScenario message. Does not implicitly {@link gauge.messages.ProtoTableDrivenScenario.verify|verify} messages.
             * @function encode
             * @memberof gauge.messages.ProtoTableDrivenScenario
             * @static
             * @param {gauge.messages.IProtoTableDrivenScenario} message ProtoTableDrivenScenario message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ProtoTableDrivenScenario.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.scenario != null && message.hasOwnProperty("scenario"))
                    $root.gauge.messages.ProtoScenario.encode(message.scenario, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.tableRowIndex != null && message.hasOwnProperty("tableRowIndex"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.tableRowIndex);
                if (message.scenarioTableRowIndex != null && message.hasOwnProperty("scenarioTableRowIndex"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.scenarioTableRowIndex);
                if (message.isSpecTableDriven != null && message.hasOwnProperty("isSpecTableDriven"))
                    writer.uint32(/* id 4, wireType 0 =*/32).bool(message.isSpecTableDriven);
                if (message.isScenarioTableDriven != null && message.hasOwnProperty("isScenarioTableDriven"))
                    writer.uint32(/* id 5, wireType 0 =*/40).bool(message.isScenarioTableDriven);
                if (message.scenarioDataTable != null && message.hasOwnProperty("scenarioDataTable"))
                    $root.gauge.messages.ProtoTable.encode(message.scenarioDataTable, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.scenarioTableRow != null && message.hasOwnProperty("scenarioTableRow"))
                    $root.gauge.messages.ProtoTable.encode(message.scenarioTableRow, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ProtoTableDrivenScenario message, length delimited. Does not implicitly {@link gauge.messages.ProtoTableDrivenScenario.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gauge.messages.ProtoTableDrivenScenario
             * @static
             * @param {gauge.messages.IProtoTableDrivenScenario} message ProtoTableDrivenScenario message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ProtoTableDrivenScenario.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ProtoTableDrivenScenario message from the specified reader or buffer.
             * @function decode
             * @memberof gauge.messages.ProtoTableDrivenScenario
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gauge.messages.ProtoTableDrivenScenario} ProtoTableDrivenScenario
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ProtoTableDrivenScenario.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gauge.messages.ProtoTableDrivenScenario();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.scenario = $root.gauge.messages.ProtoScenario.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.tableRowIndex = reader.int32();
                        break;
                    case 3:
                        message.scenarioTableRowIndex = reader.int32();
                        break;
                    case 4:
                        message.isSpecTableDriven = reader.bool();
                        break;
                    case 5:
                        message.isScenarioTableDriven = reader.bool();
                        break;
                    case 6:
                        message.scenarioDataTable = $root.gauge.messages.ProtoTable.decode(reader, reader.uint32());
                        break;
                    case 7:
                        message.scenarioTableRow = $root.gauge.messages.ProtoTable.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ProtoTableDrivenScenario message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gauge.messages.ProtoTableDrivenScenario
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gauge.messages.ProtoTableDrivenScenario} ProtoTableDrivenScenario
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ProtoTableDrivenScenario.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ProtoTableDrivenScenario message.
             * @function verify
             * @memberof gauge.messages.ProtoTableDrivenScenario
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ProtoTableDrivenScenario.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.scenario != null && message.hasOwnProperty("scenario")) {
                    var error = $root.gauge.messages.ProtoScenario.verify(message.scenario);
                    if (error)
                        return "scenario." + error;
                }
                if (message.tableRowIndex != null && message.hasOwnProperty("tableRowIndex"))
                    if (!$util.isInteger(message.tableRowIndex))
                        return "tableRowIndex: integer expected";
                if (message.scenarioTableRowIndex != null && message.hasOwnProperty("scenarioTableRowIndex"))
                    if (!$util.isInteger(message.scenarioTableRowIndex))
                        return "scenarioTableRowIndex: integer expected";
                if (message.isSpecTableDriven != null && message.hasOwnProperty("isSpecTableDriven"))
                    if (typeof message.isSpecTableDriven !== "boolean")
                        return "isSpecTableDriven: boolean expected";
                if (message.isScenarioTableDriven != null && message.hasOwnProperty("isScenarioTableDriven"))
                    if (typeof message.isScenarioTableDriven !== "boolean")
                        return "isScenarioTableDriven: boolean expected";
                if (message.scenarioDataTable != null && message.hasOwnProperty("scenarioDataTable")) {
                    var error = $root.gauge.messages.ProtoTable.verify(message.scenarioDataTable);
                    if (error)
                        return "scenarioDataTable." + error;
                }
                if (message.scenarioTableRow != null && message.hasOwnProperty("scenarioTableRow")) {
                    var error = $root.gauge.messages.ProtoTable.verify(message.scenarioTableRow);
                    if (error)
                        return "scenarioTableRow." + error;
                }
                return null;
            };

            /**
             * Creates a ProtoTableDrivenScenario message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gauge.messages.ProtoTableDrivenScenario
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gauge.messages.ProtoTableDrivenScenario} ProtoTableDrivenScenario
             */
            ProtoTableDrivenScenario.fromObject = function fromObject(object) {
                if (object instanceof $root.gauge.messages.ProtoTableDrivenScenario)
                    return object;
                var message = new $root.gauge.messages.ProtoTableDrivenScenario();
                if (object.scenario != null) {
                    if (typeof object.scenario !== "object")
                        throw TypeError(".gauge.messages.ProtoTableDrivenScenario.scenario: object expected");
                    message.scenario = $root.gauge.messages.ProtoScenario.fromObject(object.scenario);
                }
                if (object.tableRowIndex != null)
                    message.tableRowIndex = object.tableRowIndex | 0;
                if (object.scenarioTableRowIndex != null)
                    message.scenarioTableRowIndex = object.scenarioTableRowIndex | 0;
                if (object.isSpecTableDriven != null)
                    message.isSpecTableDriven = Boolean(object.isSpecTableDriven);
                if (object.isScenarioTableDriven != null)
                    message.isScenarioTableDriven = Boolean(object.isScenarioTableDriven);
                if (object.scenarioDataTable != null) {
                    if (typeof object.scenarioDataTable !== "object")
                        throw TypeError(".gauge.messages.ProtoTableDrivenScenario.scenarioDataTable: object expected");
                    message.scenarioDataTable = $root.gauge.messages.ProtoTable.fromObject(object.scenarioDataTable);
                }
                if (object.scenarioTableRow != null) {
                    if (typeof object.scenarioTableRow !== "object")
                        throw TypeError(".gauge.messages.ProtoTableDrivenScenario.scenarioTableRow: object expected");
                    message.scenarioTableRow = $root.gauge.messages.ProtoTable.fromObject(object.scenarioTableRow);
                }
                return message;
            };

            /**
             * Creates a plain object from a ProtoTableDrivenScenario message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gauge.messages.ProtoTableDrivenScenario
             * @static
             * @param {gauge.messages.ProtoTableDrivenScenario} message ProtoTableDrivenScenario
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ProtoTableDrivenScenario.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.scenario = null;
                    object.tableRowIndex = 0;
                    object.scenarioTableRowIndex = 0;
                    object.isSpecTableDriven = false;
                    object.isScenarioTableDriven = false;
                    object.scenarioDataTable = null;
                    object.scenarioTableRow = null;
                }
                if (message.scenario != null && message.hasOwnProperty("scenario"))
                    object.scenario = $root.gauge.messages.ProtoScenario.toObject(message.scenario, options);
                if (message.tableRowIndex != null && message.hasOwnProperty("tableRowIndex"))
                    object.tableRowIndex = message.tableRowIndex;
                if (message.scenarioTableRowIndex != null && message.hasOwnProperty("scenarioTableRowIndex"))
                    object.scenarioTableRowIndex = message.scenarioTableRowIndex;
                if (message.isSpecTableDriven != null && message.hasOwnProperty("isSpecTableDriven"))
                    object.isSpecTableDriven = message.isSpecTableDriven;
                if (message.isScenarioTableDriven != null && message.hasOwnProperty("isScenarioTableDriven"))
                    object.isScenarioTableDriven = message.isScenarioTableDriven;
                if (message.scenarioDataTable != null && message.hasOwnProperty("scenarioDataTable"))
                    object.scenarioDataTable = $root.gauge.messages.ProtoTable.toObject(message.scenarioDataTable, options);
                if (message.scenarioTableRow != null && message.hasOwnProperty("scenarioTableRow"))
                    object.scenarioTableRow = $root.gauge.messages.ProtoTable.toObject(message.scenarioTableRow, options);
                return object;
            };

            /**
             * Converts this ProtoTableDrivenScenario to JSON.
             * @function toJSON
             * @memberof gauge.messages.ProtoTableDrivenScenario
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ProtoTableDrivenScenario.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ProtoTableDrivenScenario;
        })();

        messages.ProtoStep = (function() {

            /**
             * Properties of a ProtoStep.
             * @memberof gauge.messages
             * @interface IProtoStep
             * @property {string|null} [actualText] Holds the raw text of the Step as defined in the spec file. This contains the actual parameter values.
             * @property {string|null} [parsedText] Contains the parsed text of the Step. This will have placeholders for the parameters.
             * @property {Array.<gauge.messages.IFragment>|null} [fragments] Collection of a list of fragments for a Step. A fragment could be either text or parameter.
             * @property {gauge.messages.IProtoStepExecutionResult|null} [stepExecutionResult] Holds the result from the execution.
             * @property {Array.<string>|null} [preHookMessages] Additional information at pre hook exec time to be available on reports
             * @property {Array.<string>|null} [postHookMessages] Additional information at post hook exec time to be available on reports
             * @property {Array.<Uint8Array>|null} [preHookScreenshots] [DEPRECATED, use preHookScreenshotFiles] Capture Screenshot at pre hook exec time to be available on reports
             * @property {Array.<Uint8Array>|null} [postHookScreenshots] [DEPRECATED, use postHookScreenshotFiles] Capture Screenshot at post hook exec time to be available on reports
             * @property {Array.<string>|null} [preHookScreenshotFiles] Screenshots captured on pre hook exec time to be available on reports
             * @property {Array.<string>|null} [postHookScreenshotFiles] Screenshots captured on post hook exec time to be available on reports
             */

            /**
             * Constructs a new ProtoStep.
             * @memberof gauge.messages
             * @classdesc A proto object representing a Step
             * @implements IProtoStep
             * @constructor
             * @param {gauge.messages.IProtoStep=} [properties] Properties to set
             */
            function ProtoStep(properties) {
                this.fragments = [];
                this.preHookMessages = [];
                this.postHookMessages = [];
                this.preHookScreenshots = [];
                this.postHookScreenshots = [];
                this.preHookScreenshotFiles = [];
                this.postHookScreenshotFiles = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Holds the raw text of the Step as defined in the spec file. This contains the actual parameter values.
             * @member {string} actualText
             * @memberof gauge.messages.ProtoStep
             * @instance
             */
            ProtoStep.prototype.actualText = "";

            /**
             * Contains the parsed text of the Step. This will have placeholders for the parameters.
             * @member {string} parsedText
             * @memberof gauge.messages.ProtoStep
             * @instance
             */
            ProtoStep.prototype.parsedText = "";

            /**
             * Collection of a list of fragments for a Step. A fragment could be either text or parameter.
             * @member {Array.<gauge.messages.IFragment>} fragments
             * @memberof gauge.messages.ProtoStep
             * @instance
             */
            ProtoStep.prototype.fragments = $util.emptyArray;

            /**
             * Holds the result from the execution.
             * @member {gauge.messages.IProtoStepExecutionResult|null|undefined} stepExecutionResult
             * @memberof gauge.messages.ProtoStep
             * @instance
             */
            ProtoStep.prototype.stepExecutionResult = null;

            /**
             * Additional information at pre hook exec time to be available on reports
             * @member {Array.<string>} preHookMessages
             * @memberof gauge.messages.ProtoStep
             * @instance
             */
            ProtoStep.prototype.preHookMessages = $util.emptyArray;

            /**
             * Additional information at post hook exec time to be available on reports
             * @member {Array.<string>} postHookMessages
             * @memberof gauge.messages.ProtoStep
             * @instance
             */
            ProtoStep.prototype.postHookMessages = $util.emptyArray;

            /**
             * [DEPRECATED, use preHookScreenshotFiles] Capture Screenshot at pre hook exec time to be available on reports
             * @member {Array.<Uint8Array>} preHookScreenshots
             * @memberof gauge.messages.ProtoStep
             * @instance
             */
            ProtoStep.prototype.preHookScreenshots = $util.emptyArray;

            /**
             * [DEPRECATED, use postHookScreenshotFiles] Capture Screenshot at post hook exec time to be available on reports
             * @member {Array.<Uint8Array>} postHookScreenshots
             * @memberof gauge.messages.ProtoStep
             * @instance
             */
            ProtoStep.prototype.postHookScreenshots = $util.emptyArray;

            /**
             * Screenshots captured on pre hook exec time to be available on reports
             * @member {Array.<string>} preHookScreenshotFiles
             * @memberof gauge.messages.ProtoStep
             * @instance
             */
            ProtoStep.prototype.preHookScreenshotFiles = $util.emptyArray;

            /**
             * Screenshots captured on post hook exec time to be available on reports
             * @member {Array.<string>} postHookScreenshotFiles
             * @memberof gauge.messages.ProtoStep
             * @instance
             */
            ProtoStep.prototype.postHookScreenshotFiles = $util.emptyArray;

            /**
             * Creates a new ProtoStep instance using the specified properties.
             * @function create
             * @memberof gauge.messages.ProtoStep
             * @static
             * @param {gauge.messages.IProtoStep=} [properties] Properties to set
             * @returns {gauge.messages.ProtoStep} ProtoStep instance
             */
            ProtoStep.create = function create(properties) {
                return new ProtoStep(properties);
            };

            /**
             * Encodes the specified ProtoStep message. Does not implicitly {@link gauge.messages.ProtoStep.verify|verify} messages.
             * @function encode
             * @memberof gauge.messages.ProtoStep
             * @static
             * @param {gauge.messages.IProtoStep} message ProtoStep message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ProtoStep.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.actualText != null && message.hasOwnProperty("actualText"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.actualText);
                if (message.parsedText != null && message.hasOwnProperty("parsedText"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.parsedText);
                if (message.fragments != null && message.fragments.length)
                    for (var i = 0; i < message.fragments.length; ++i)
                        $root.gauge.messages.Fragment.encode(message.fragments[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.stepExecutionResult != null && message.hasOwnProperty("stepExecutionResult"))
                    $root.gauge.messages.ProtoStepExecutionResult.encode(message.stepExecutionResult, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.preHookMessages != null && message.preHookMessages.length)
                    for (var i = 0; i < message.preHookMessages.length; ++i)
                        writer.uint32(/* id 5, wireType 2 =*/42).string(message.preHookMessages[i]);
                if (message.postHookMessages != null && message.postHookMessages.length)
                    for (var i = 0; i < message.postHookMessages.length; ++i)
                        writer.uint32(/* id 6, wireType 2 =*/50).string(message.postHookMessages[i]);
                if (message.preHookScreenshots != null && message.preHookScreenshots.length)
                    for (var i = 0; i < message.preHookScreenshots.length; ++i)
                        writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.preHookScreenshots[i]);
                if (message.postHookScreenshots != null && message.postHookScreenshots.length)
                    for (var i = 0; i < message.postHookScreenshots.length; ++i)
                        writer.uint32(/* id 8, wireType 2 =*/66).bytes(message.postHookScreenshots[i]);
                if (message.preHookScreenshotFiles != null && message.preHookScreenshotFiles.length)
                    for (var i = 0; i < message.preHookScreenshotFiles.length; ++i)
                        writer.uint32(/* id 9, wireType 2 =*/74).string(message.preHookScreenshotFiles[i]);
                if (message.postHookScreenshotFiles != null && message.postHookScreenshotFiles.length)
                    for (var i = 0; i < message.postHookScreenshotFiles.length; ++i)
                        writer.uint32(/* id 10, wireType 2 =*/82).string(message.postHookScreenshotFiles[i]);
                return writer;
            };

            /**
             * Encodes the specified ProtoStep message, length delimited. Does not implicitly {@link gauge.messages.ProtoStep.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gauge.messages.ProtoStep
             * @static
             * @param {gauge.messages.IProtoStep} message ProtoStep message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ProtoStep.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ProtoStep message from the specified reader or buffer.
             * @function decode
             * @memberof gauge.messages.ProtoStep
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gauge.messages.ProtoStep} ProtoStep
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ProtoStep.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gauge.messages.ProtoStep();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.actualText = reader.string();
                        break;
                    case 2:
                        message.parsedText = reader.string();
                        break;
                    case 3:
                        if (!(message.fragments && message.fragments.length))
                            message.fragments = [];
                        message.fragments.push($root.gauge.messages.Fragment.decode(reader, reader.uint32()));
                        break;
                    case 4:
                        message.stepExecutionResult = $root.gauge.messages.ProtoStepExecutionResult.decode(reader, reader.uint32());
                        break;
                    case 5:
                        if (!(message.preHookMessages && message.preHookMessages.length))
                            message.preHookMessages = [];
                        message.preHookMessages.push(reader.string());
                        break;
                    case 6:
                        if (!(message.postHookMessages && message.postHookMessages.length))
                            message.postHookMessages = [];
                        message.postHookMessages.push(reader.string());
                        break;
                    case 7:
                        if (!(message.preHookScreenshots && message.preHookScreenshots.length))
                            message.preHookScreenshots = [];
                        message.preHookScreenshots.push(reader.bytes());
                        break;
                    case 8:
                        if (!(message.postHookScreenshots && message.postHookScreenshots.length))
                            message.postHookScreenshots = [];
                        message.postHookScreenshots.push(reader.bytes());
                        break;
                    case 9:
                        if (!(message.preHookScreenshotFiles && message.preHookScreenshotFiles.length))
                            message.preHookScreenshotFiles = [];
                        message.preHookScreenshotFiles.push(reader.string());
                        break;
                    case 10:
                        if (!(message.postHookScreenshotFiles && message.postHookScreenshotFiles.length))
                            message.postHookScreenshotFiles = [];
                        message.postHookScreenshotFiles.push(reader.string());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ProtoStep message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gauge.messages.ProtoStep
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gauge.messages.ProtoStep} ProtoStep
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ProtoStep.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ProtoStep message.
             * @function verify
             * @memberof gauge.messages.ProtoStep
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ProtoStep.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.actualText != null && message.hasOwnProperty("actualText"))
                    if (!$util.isString(message.actualText))
                        return "actualText: string expected";
                if (message.parsedText != null && message.hasOwnProperty("parsedText"))
                    if (!$util.isString(message.parsedText))
                        return "parsedText: string expected";
                if (message.fragments != null && message.hasOwnProperty("fragments")) {
                    if (!Array.isArray(message.fragments))
                        return "fragments: array expected";
                    for (var i = 0; i < message.fragments.length; ++i) {
                        var error = $root.gauge.messages.Fragment.verify(message.fragments[i]);
                        if (error)
                            return "fragments." + error;
                    }
                }
                if (message.stepExecutionResult != null && message.hasOwnProperty("stepExecutionResult")) {
                    var error = $root.gauge.messages.ProtoStepExecutionResult.verify(message.stepExecutionResult);
                    if (error)
                        return "stepExecutionResult." + error;
                }
                if (message.preHookMessages != null && message.hasOwnProperty("preHookMessages")) {
                    if (!Array.isArray(message.preHookMessages))
                        return "preHookMessages: array expected";
                    for (var i = 0; i < message.preHookMessages.length; ++i)
                        if (!$util.isString(message.preHookMessages[i]))
                            return "preHookMessages: string[] expected";
                }
                if (message.postHookMessages != null && message.hasOwnProperty("postHookMessages")) {
                    if (!Array.isArray(message.postHookMessages))
                        return "postHookMessages: array expected";
                    for (var i = 0; i < message.postHookMessages.length; ++i)
                        if (!$util.isString(message.postHookMessages[i]))
                            return "postHookMessages: string[] expected";
                }
                if (message.preHookScreenshots != null && message.hasOwnProperty("preHookScreenshots")) {
                    if (!Array.isArray(message.preHookScreenshots))
                        return "preHookScreenshots: array expected";
                    for (var i = 0; i < message.preHookScreenshots.length; ++i)
                        if (!(message.preHookScreenshots[i] && typeof message.preHookScreenshots[i].length === "number" || $util.isString(message.preHookScreenshots[i])))
                            return "preHookScreenshots: buffer[] expected";
                }
                if (message.postHookScreenshots != null && message.hasOwnProperty("postHookScreenshots")) {
                    if (!Array.isArray(message.postHookScreenshots))
                        return "postHookScreenshots: array expected";
                    for (var i = 0; i < message.postHookScreenshots.length; ++i)
                        if (!(message.postHookScreenshots[i] && typeof message.postHookScreenshots[i].length === "number" || $util.isString(message.postHookScreenshots[i])))
                            return "postHookScreenshots: buffer[] expected";
                }
                if (message.preHookScreenshotFiles != null && message.hasOwnProperty("preHookScreenshotFiles")) {
                    if (!Array.isArray(message.preHookScreenshotFiles))
                        return "preHookScreenshotFiles: array expected";
                    for (var i = 0; i < message.preHookScreenshotFiles.length; ++i)
                        if (!$util.isString(message.preHookScreenshotFiles[i]))
                            return "preHookScreenshotFiles: string[] expected";
                }
                if (message.postHookScreenshotFiles != null && message.hasOwnProperty("postHookScreenshotFiles")) {
                    if (!Array.isArray(message.postHookScreenshotFiles))
                        return "postHookScreenshotFiles: array expected";
                    for (var i = 0; i < message.postHookScreenshotFiles.length; ++i)
                        if (!$util.isString(message.postHookScreenshotFiles[i]))
                            return "postHookScreenshotFiles: string[] expected";
                }
                return null;
            };

            /**
             * Creates a ProtoStep message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gauge.messages.ProtoStep
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gauge.messages.ProtoStep} ProtoStep
             */
            ProtoStep.fromObject = function fromObject(object) {
                if (object instanceof $root.gauge.messages.ProtoStep)
                    return object;
                var message = new $root.gauge.messages.ProtoStep();
                if (object.actualText != null)
                    message.actualText = String(object.actualText);
                if (object.parsedText != null)
                    message.parsedText = String(object.parsedText);
                if (object.fragments) {
                    if (!Array.isArray(object.fragments))
                        throw TypeError(".gauge.messages.ProtoStep.fragments: array expected");
                    message.fragments = [];
                    for (var i = 0; i < object.fragments.length; ++i) {
                        if (typeof object.fragments[i] !== "object")
                            throw TypeError(".gauge.messages.ProtoStep.fragments: object expected");
                        message.fragments[i] = $root.gauge.messages.Fragment.fromObject(object.fragments[i]);
                    }
                }
                if (object.stepExecutionResult != null) {
                    if (typeof object.stepExecutionResult !== "object")
                        throw TypeError(".gauge.messages.ProtoStep.stepExecutionResult: object expected");
                    message.stepExecutionResult = $root.gauge.messages.ProtoStepExecutionResult.fromObject(object.stepExecutionResult);
                }
                if (object.preHookMessages) {
                    if (!Array.isArray(object.preHookMessages))
                        throw TypeError(".gauge.messages.ProtoStep.preHookMessages: array expected");
                    message.preHookMessages = [];
                    for (var i = 0; i < object.preHookMessages.length; ++i)
                        message.preHookMessages[i] = String(object.preHookMessages[i]);
                }
                if (object.postHookMessages) {
                    if (!Array.isArray(object.postHookMessages))
                        throw TypeError(".gauge.messages.ProtoStep.postHookMessages: array expected");
                    message.postHookMessages = [];
                    for (var i = 0; i < object.postHookMessages.length; ++i)
                        message.postHookMessages[i] = String(object.postHookMessages[i]);
                }
                if (object.preHookScreenshots) {
                    if (!Array.isArray(object.preHookScreenshots))
                        throw TypeError(".gauge.messages.ProtoStep.preHookScreenshots: array expected");
                    message.preHookScreenshots = [];
                    for (var i = 0; i < object.preHookScreenshots.length; ++i)
                        if (typeof object.preHookScreenshots[i] === "string")
                            $util.base64.decode(object.preHookScreenshots[i], message.preHookScreenshots[i] = $util.newBuffer($util.base64.length(object.preHookScreenshots[i])), 0);
                        else if (object.preHookScreenshots[i].length)
                            message.preHookScreenshots[i] = object.preHookScreenshots[i];
                }
                if (object.postHookScreenshots) {
                    if (!Array.isArray(object.postHookScreenshots))
                        throw TypeError(".gauge.messages.ProtoStep.postHookScreenshots: array expected");
                    message.postHookScreenshots = [];
                    for (var i = 0; i < object.postHookScreenshots.length; ++i)
                        if (typeof object.postHookScreenshots[i] === "string")
                            $util.base64.decode(object.postHookScreenshots[i], message.postHookScreenshots[i] = $util.newBuffer($util.base64.length(object.postHookScreenshots[i])), 0);
                        else if (object.postHookScreenshots[i].length)
                            message.postHookScreenshots[i] = object.postHookScreenshots[i];
                }
                if (object.preHookScreenshotFiles) {
                    if (!Array.isArray(object.preHookScreenshotFiles))
                        throw TypeError(".gauge.messages.ProtoStep.preHookScreenshotFiles: array expected");
                    message.preHookScreenshotFiles = [];
                    for (var i = 0; i < object.preHookScreenshotFiles.length; ++i)
                        message.preHookScreenshotFiles[i] = String(object.preHookScreenshotFiles[i]);
                }
                if (object.postHookScreenshotFiles) {
                    if (!Array.isArray(object.postHookScreenshotFiles))
                        throw TypeError(".gauge.messages.ProtoStep.postHookScreenshotFiles: array expected");
                    message.postHookScreenshotFiles = [];
                    for (var i = 0; i < object.postHookScreenshotFiles.length; ++i)
                        message.postHookScreenshotFiles[i] = String(object.postHookScreenshotFiles[i]);
                }
                return message;
            };

            /**
             * Creates a plain object from a ProtoStep message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gauge.messages.ProtoStep
             * @static
             * @param {gauge.messages.ProtoStep} message ProtoStep
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ProtoStep.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults) {
                    object.fragments = [];
                    object.preHookMessages = [];
                    object.postHookMessages = [];
                    object.preHookScreenshots = [];
                    object.postHookScreenshots = [];
                    object.preHookScreenshotFiles = [];
                    object.postHookScreenshotFiles = [];
                }
                if (options.defaults) {
                    object.actualText = "";
                    object.parsedText = "";
                    object.stepExecutionResult = null;
                }
                if (message.actualText != null && message.hasOwnProperty("actualText"))
                    object.actualText = message.actualText;
                if (message.parsedText != null && message.hasOwnProperty("parsedText"))
                    object.parsedText = message.parsedText;
                if (message.fragments && message.fragments.length) {
                    object.fragments = [];
                    for (var j = 0; j < message.fragments.length; ++j)
                        object.fragments[j] = $root.gauge.messages.Fragment.toObject(message.fragments[j], options);
                }
                if (message.stepExecutionResult != null && message.hasOwnProperty("stepExecutionResult"))
                    object.stepExecutionResult = $root.gauge.messages.ProtoStepExecutionResult.toObject(message.stepExecutionResult, options);
                if (message.preHookMessages && message.preHookMessages.length) {
                    object.preHookMessages = [];
                    for (var j = 0; j < message.preHookMessages.length; ++j)
                        object.preHookMessages[j] = message.preHookMessages[j];
                }
                if (message.postHookMessages && message.postHookMessages.length) {
                    object.postHookMessages = [];
                    for (var j = 0; j < message.postHookMessages.length; ++j)
                        object.postHookMessages[j] = message.postHookMessages[j];
                }
                if (message.preHookScreenshots && message.preHookScreenshots.length) {
                    object.preHookScreenshots = [];
                    for (var j = 0; j < message.preHookScreenshots.length; ++j)
                        object.preHookScreenshots[j] = options.bytes === String ? $util.base64.encode(message.preHookScreenshots[j], 0, message.preHookScreenshots[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.preHookScreenshots[j]) : message.preHookScreenshots[j];
                }
                if (message.postHookScreenshots && message.postHookScreenshots.length) {
                    object.postHookScreenshots = [];
                    for (var j = 0; j < message.postHookScreenshots.length; ++j)
                        object.postHookScreenshots[j] = options.bytes === String ? $util.base64.encode(message.postHookScreenshots[j], 0, message.postHookScreenshots[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.postHookScreenshots[j]) : message.postHookScreenshots[j];
                }
                if (message.preHookScreenshotFiles && message.preHookScreenshotFiles.length) {
                    object.preHookScreenshotFiles = [];
                    for (var j = 0; j < message.preHookScreenshotFiles.length; ++j)
                        object.preHookScreenshotFiles[j] = message.preHookScreenshotFiles[j];
                }
                if (message.postHookScreenshotFiles && message.postHookScreenshotFiles.length) {
                    object.postHookScreenshotFiles = [];
                    for (var j = 0; j < message.postHookScreenshotFiles.length; ++j)
                        object.postHookScreenshotFiles[j] = message.postHookScreenshotFiles[j];
                }
                return object;
            };

            /**
             * Converts this ProtoStep to JSON.
             * @function toJSON
             * @memberof gauge.messages.ProtoStep
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ProtoStep.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ProtoStep;
        })();

        messages.ProtoConcept = (function() {

            /**
             * Properties of a ProtoConcept.
             * @memberof gauge.messages
             * @interface IProtoConcept
             * @property {gauge.messages.IProtoStep|null} [conceptStep] Represents the Step value of a Concept.
             * @property {Array.<gauge.messages.IProtoItem>|null} [steps] Collection of Steps in the given concepts.
             * @property {gauge.messages.IProtoStepExecutionResult|null} [conceptExecutionResult] Holds the execution result.
             */

            /**
             * Constructs a new ProtoConcept.
             * @memberof gauge.messages
             * @classdesc A proto object representing a Concept
             * @implements IProtoConcept
             * @constructor
             * @param {gauge.messages.IProtoConcept=} [properties] Properties to set
             */
            function ProtoConcept(properties) {
                this.steps = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Represents the Step value of a Concept.
             * @member {gauge.messages.IProtoStep|null|undefined} conceptStep
             * @memberof gauge.messages.ProtoConcept
             * @instance
             */
            ProtoConcept.prototype.conceptStep = null;

            /**
             * Collection of Steps in the given concepts.
             * @member {Array.<gauge.messages.IProtoItem>} steps
             * @memberof gauge.messages.ProtoConcept
             * @instance
             */
            ProtoConcept.prototype.steps = $util.emptyArray;

            /**
             * Holds the execution result.
             * @member {gauge.messages.IProtoStepExecutionResult|null|undefined} conceptExecutionResult
             * @memberof gauge.messages.ProtoConcept
             * @instance
             */
            ProtoConcept.prototype.conceptExecutionResult = null;

            /**
             * Creates a new ProtoConcept instance using the specified properties.
             * @function create
             * @memberof gauge.messages.ProtoConcept
             * @static
             * @param {gauge.messages.IProtoConcept=} [properties] Properties to set
             * @returns {gauge.messages.ProtoConcept} ProtoConcept instance
             */
            ProtoConcept.create = function create(properties) {
                return new ProtoConcept(properties);
            };

            /**
             * Encodes the specified ProtoConcept message. Does not implicitly {@link gauge.messages.ProtoConcept.verify|verify} messages.
             * @function encode
             * @memberof gauge.messages.ProtoConcept
             * @static
             * @param {gauge.messages.IProtoConcept} message ProtoConcept message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ProtoConcept.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.conceptStep != null && message.hasOwnProperty("conceptStep"))
                    $root.gauge.messages.ProtoStep.encode(message.conceptStep, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.steps != null && message.steps.length)
                    for (var i = 0; i < message.steps.length; ++i)
                        $root.gauge.messages.ProtoItem.encode(message.steps[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.conceptExecutionResult != null && message.hasOwnProperty("conceptExecutionResult"))
                    $root.gauge.messages.ProtoStepExecutionResult.encode(message.conceptExecutionResult, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ProtoConcept message, length delimited. Does not implicitly {@link gauge.messages.ProtoConcept.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gauge.messages.ProtoConcept
             * @static
             * @param {gauge.messages.IProtoConcept} message ProtoConcept message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ProtoConcept.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ProtoConcept message from the specified reader or buffer.
             * @function decode
             * @memberof gauge.messages.ProtoConcept
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gauge.messages.ProtoConcept} ProtoConcept
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ProtoConcept.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gauge.messages.ProtoConcept();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.conceptStep = $root.gauge.messages.ProtoStep.decode(reader, reader.uint32());
                        break;
                    case 2:
                        if (!(message.steps && message.steps.length))
                            message.steps = [];
                        message.steps.push($root.gauge.messages.ProtoItem.decode(reader, reader.uint32()));
                        break;
                    case 3:
                        message.conceptExecutionResult = $root.gauge.messages.ProtoStepExecutionResult.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ProtoConcept message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gauge.messages.ProtoConcept
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gauge.messages.ProtoConcept} ProtoConcept
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ProtoConcept.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ProtoConcept message.
             * @function verify
             * @memberof gauge.messages.ProtoConcept
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ProtoConcept.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.conceptStep != null && message.hasOwnProperty("conceptStep")) {
                    var error = $root.gauge.messages.ProtoStep.verify(message.conceptStep);
                    if (error)
                        return "conceptStep." + error;
                }
                if (message.steps != null && message.hasOwnProperty("steps")) {
                    if (!Array.isArray(message.steps))
                        return "steps: array expected";
                    for (var i = 0; i < message.steps.length; ++i) {
                        var error = $root.gauge.messages.ProtoItem.verify(message.steps[i]);
                        if (error)
                            return "steps." + error;
                    }
                }
                if (message.conceptExecutionResult != null && message.hasOwnProperty("conceptExecutionResult")) {
                    var error = $root.gauge.messages.ProtoStepExecutionResult.verify(message.conceptExecutionResult);
                    if (error)
                        return "conceptExecutionResult." + error;
                }
                return null;
            };

            /**
             * Creates a ProtoConcept message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gauge.messages.ProtoConcept
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gauge.messages.ProtoConcept} ProtoConcept
             */
            ProtoConcept.fromObject = function fromObject(object) {
                if (object instanceof $root.gauge.messages.ProtoConcept)
                    return object;
                var message = new $root.gauge.messages.ProtoConcept();
                if (object.conceptStep != null) {
                    if (typeof object.conceptStep !== "object")
                        throw TypeError(".gauge.messages.ProtoConcept.conceptStep: object expected");
                    message.conceptStep = $root.gauge.messages.ProtoStep.fromObject(object.conceptStep);
                }
                if (object.steps) {
                    if (!Array.isArray(object.steps))
                        throw TypeError(".gauge.messages.ProtoConcept.steps: array expected");
                    message.steps = [];
                    for (var i = 0; i < object.steps.length; ++i) {
                        if (typeof object.steps[i] !== "object")
                            throw TypeError(".gauge.messages.ProtoConcept.steps: object expected");
                        message.steps[i] = $root.gauge.messages.ProtoItem.fromObject(object.steps[i]);
                    }
                }
                if (object.conceptExecutionResult != null) {
                    if (typeof object.conceptExecutionResult !== "object")
                        throw TypeError(".gauge.messages.ProtoConcept.conceptExecutionResult: object expected");
                    message.conceptExecutionResult = $root.gauge.messages.ProtoStepExecutionResult.fromObject(object.conceptExecutionResult);
                }
                return message;
            };

            /**
             * Creates a plain object from a ProtoConcept message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gauge.messages.ProtoConcept
             * @static
             * @param {gauge.messages.ProtoConcept} message ProtoConcept
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ProtoConcept.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.steps = [];
                if (options.defaults) {
                    object.conceptStep = null;
                    object.conceptExecutionResult = null;
                }
                if (message.conceptStep != null && message.hasOwnProperty("conceptStep"))
                    object.conceptStep = $root.gauge.messages.ProtoStep.toObject(message.conceptStep, options);
                if (message.steps && message.steps.length) {
                    object.steps = [];
                    for (var j = 0; j < message.steps.length; ++j)
                        object.steps[j] = $root.gauge.messages.ProtoItem.toObject(message.steps[j], options);
                }
                if (message.conceptExecutionResult != null && message.hasOwnProperty("conceptExecutionResult"))
                    object.conceptExecutionResult = $root.gauge.messages.ProtoStepExecutionResult.toObject(message.conceptExecutionResult, options);
                return object;
            };

            /**
             * Converts this ProtoConcept to JSON.
             * @function toJSON
             * @memberof gauge.messages.ProtoConcept
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ProtoConcept.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ProtoConcept;
        })();

        messages.ProtoTags = (function() {

            /**
             * Properties of a ProtoTags.
             * @memberof gauge.messages
             * @interface IProtoTags
             * @property {Array.<string>|null} [tags] A collection of Tags
             */

            /**
             * Constructs a new ProtoTags.
             * @memberof gauge.messages
             * @classdesc A proto object representing Tags
             * @implements IProtoTags
             * @constructor
             * @param {gauge.messages.IProtoTags=} [properties] Properties to set
             */
            function ProtoTags(properties) {
                this.tags = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * A collection of Tags
             * @member {Array.<string>} tags
             * @memberof gauge.messages.ProtoTags
             * @instance
             */
            ProtoTags.prototype.tags = $util.emptyArray;

            /**
             * Creates a new ProtoTags instance using the specified properties.
             * @function create
             * @memberof gauge.messages.ProtoTags
             * @static
             * @param {gauge.messages.IProtoTags=} [properties] Properties to set
             * @returns {gauge.messages.ProtoTags} ProtoTags instance
             */
            ProtoTags.create = function create(properties) {
                return new ProtoTags(properties);
            };

            /**
             * Encodes the specified ProtoTags message. Does not implicitly {@link gauge.messages.ProtoTags.verify|verify} messages.
             * @function encode
             * @memberof gauge.messages.ProtoTags
             * @static
             * @param {gauge.messages.IProtoTags} message ProtoTags message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ProtoTags.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.tags != null && message.tags.length)
                    for (var i = 0; i < message.tags.length; ++i)
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.tags[i]);
                return writer;
            };

            /**
             * Encodes the specified ProtoTags message, length delimited. Does not implicitly {@link gauge.messages.ProtoTags.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gauge.messages.ProtoTags
             * @static
             * @param {gauge.messages.IProtoTags} message ProtoTags message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ProtoTags.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ProtoTags message from the specified reader or buffer.
             * @function decode
             * @memberof gauge.messages.ProtoTags
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gauge.messages.ProtoTags} ProtoTags
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ProtoTags.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gauge.messages.ProtoTags();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.tags && message.tags.length))
                            message.tags = [];
                        message.tags.push(reader.string());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ProtoTags message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gauge.messages.ProtoTags
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gauge.messages.ProtoTags} ProtoTags
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ProtoTags.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ProtoTags message.
             * @function verify
             * @memberof gauge.messages.ProtoTags
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ProtoTags.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.tags != null && message.hasOwnProperty("tags")) {
                    if (!Array.isArray(message.tags))
                        return "tags: array expected";
                    for (var i = 0; i < message.tags.length; ++i)
                        if (!$util.isString(message.tags[i]))
                            return "tags: string[] expected";
                }
                return null;
            };

            /**
             * Creates a ProtoTags message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gauge.messages.ProtoTags
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gauge.messages.ProtoTags} ProtoTags
             */
            ProtoTags.fromObject = function fromObject(object) {
                if (object instanceof $root.gauge.messages.ProtoTags)
                    return object;
                var message = new $root.gauge.messages.ProtoTags();
                if (object.tags) {
                    if (!Array.isArray(object.tags))
                        throw TypeError(".gauge.messages.ProtoTags.tags: array expected");
                    message.tags = [];
                    for (var i = 0; i < object.tags.length; ++i)
                        message.tags[i] = String(object.tags[i]);
                }
                return message;
            };

            /**
             * Creates a plain object from a ProtoTags message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gauge.messages.ProtoTags
             * @static
             * @param {gauge.messages.ProtoTags} message ProtoTags
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ProtoTags.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.tags = [];
                if (message.tags && message.tags.length) {
                    object.tags = [];
                    for (var j = 0; j < message.tags.length; ++j)
                        object.tags[j] = message.tags[j];
                }
                return object;
            };

            /**
             * Converts this ProtoTags to JSON.
             * @function toJSON
             * @memberof gauge.messages.ProtoTags
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ProtoTags.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ProtoTags;
        })();

        messages.Fragment = (function() {

            /**
             * Properties of a Fragment.
             * @memberof gauge.messages
             * @interface IFragment
             * @property {gauge.messages.Fragment.FragmentType|null} [fragmentType] Type of Fragment, valid values are Text, Parameter
             * @property {string|null} [text] Text part of the Fragment, valid only if FragmentType=Text
             * @property {gauge.messages.IParameter|null} [parameter] Parameter part of the Fragment, valid only if FragmentType=Parameter
             */

            /**
             * Constructs a new Fragment.
             * @memberof gauge.messages
             * @classdesc Fragments, put together make up A Step
             * @implements IFragment
             * @constructor
             * @param {gauge.messages.IFragment=} [properties] Properties to set
             */
            function Fragment(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Type of Fragment, valid values are Text, Parameter
             * @member {gauge.messages.Fragment.FragmentType} fragmentType
             * @memberof gauge.messages.Fragment
             * @instance
             */
            Fragment.prototype.fragmentType = 0;

            /**
             * Text part of the Fragment, valid only if FragmentType=Text
             * @member {string} text
             * @memberof gauge.messages.Fragment
             * @instance
             */
            Fragment.prototype.text = "";

            /**
             * Parameter part of the Fragment, valid only if FragmentType=Parameter
             * @member {gauge.messages.IParameter|null|undefined} parameter
             * @memberof gauge.messages.Fragment
             * @instance
             */
            Fragment.prototype.parameter = null;

            /**
             * Creates a new Fragment instance using the specified properties.
             * @function create
             * @memberof gauge.messages.Fragment
             * @static
             * @param {gauge.messages.IFragment=} [properties] Properties to set
             * @returns {gauge.messages.Fragment} Fragment instance
             */
            Fragment.create = function create(properties) {
                return new Fragment(properties);
            };

            /**
             * Encodes the specified Fragment message. Does not implicitly {@link gauge.messages.Fragment.verify|verify} messages.
             * @function encode
             * @memberof gauge.messages.Fragment
             * @static
             * @param {gauge.messages.IFragment} message Fragment message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Fragment.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.fragmentType != null && message.hasOwnProperty("fragmentType"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.fragmentType);
                if (message.text != null && message.hasOwnProperty("text"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.text);
                if (message.parameter != null && message.hasOwnProperty("parameter"))
                    $root.gauge.messages.Parameter.encode(message.parameter, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Fragment message, length delimited. Does not implicitly {@link gauge.messages.Fragment.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gauge.messages.Fragment
             * @static
             * @param {gauge.messages.IFragment} message Fragment message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Fragment.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Fragment message from the specified reader or buffer.
             * @function decode
             * @memberof gauge.messages.Fragment
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gauge.messages.Fragment} Fragment
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Fragment.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gauge.messages.Fragment();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.fragmentType = reader.int32();
                        break;
                    case 2:
                        message.text = reader.string();
                        break;
                    case 3:
                        message.parameter = $root.gauge.messages.Parameter.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Fragment message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gauge.messages.Fragment
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gauge.messages.Fragment} Fragment
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Fragment.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Fragment message.
             * @function verify
             * @memberof gauge.messages.Fragment
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Fragment.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.fragmentType != null && message.hasOwnProperty("fragmentType"))
                    switch (message.fragmentType) {
                    default:
                        return "fragmentType: enum value expected";
                    case 0:
                    case 1:
                        break;
                    }
                if (message.text != null && message.hasOwnProperty("text"))
                    if (!$util.isString(message.text))
                        return "text: string expected";
                if (message.parameter != null && message.hasOwnProperty("parameter")) {
                    var error = $root.gauge.messages.Parameter.verify(message.parameter);
                    if (error)
                        return "parameter." + error;
                }
                return null;
            };

            /**
             * Creates a Fragment message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gauge.messages.Fragment
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gauge.messages.Fragment} Fragment
             */
            Fragment.fromObject = function fromObject(object) {
                if (object instanceof $root.gauge.messages.Fragment)
                    return object;
                var message = new $root.gauge.messages.Fragment();
                switch (object.fragmentType) {
                case "Text":
                case 0:
                    message.fragmentType = 0;
                    break;
                case "Parameter":
                case 1:
                    message.fragmentType = 1;
                    break;
                }
                if (object.text != null)
                    message.text = String(object.text);
                if (object.parameter != null) {
                    if (typeof object.parameter !== "object")
                        throw TypeError(".gauge.messages.Fragment.parameter: object expected");
                    message.parameter = $root.gauge.messages.Parameter.fromObject(object.parameter);
                }
                return message;
            };

            /**
             * Creates a plain object from a Fragment message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gauge.messages.Fragment
             * @static
             * @param {gauge.messages.Fragment} message Fragment
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Fragment.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.fragmentType = options.enums === String ? "Text" : 0;
                    object.text = "";
                    object.parameter = null;
                }
                if (message.fragmentType != null && message.hasOwnProperty("fragmentType"))
                    object.fragmentType = options.enums === String ? $root.gauge.messages.Fragment.FragmentType[message.fragmentType] : message.fragmentType;
                if (message.text != null && message.hasOwnProperty("text"))
                    object.text = message.text;
                if (message.parameter != null && message.hasOwnProperty("parameter"))
                    object.parameter = $root.gauge.messages.Parameter.toObject(message.parameter, options);
                return object;
            };

            /**
             * Converts this Fragment to JSON.
             * @function toJSON
             * @memberof gauge.messages.Fragment
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Fragment.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Enum representing the types of Fragment
             * @name gauge.messages.Fragment.FragmentType
             * @enum {string}
             * @property {number} Text=0 Fragment is a Text part
             * @property {number} Parameter=1 Fragment is a Parameter part
             */
            Fragment.FragmentType = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "Text"] = 0;
                values[valuesById[1] = "Parameter"] = 1;
                return values;
            })();

            return Fragment;
        })();

        messages.Parameter = (function() {

            /**
             * Properties of a Parameter.
             * @memberof gauge.messages
             * @interface IParameter
             * @property {gauge.messages.Parameter.ParameterType|null} [parameterType] Type of the Parameter. Valid values: Static, Dynamic, Special_String, Special_Table, Table
             * @property {string|null} [value] Holds the value of the parameter
             * @property {string|null} [name] Holds the name of the parameter, used as Key to lookup the value.
             * @property {gauge.messages.IProtoTable|null} [table] Holds the table value, if parameterType=Table or Special_Table
             */

            /**
             * Constructs a new Parameter.
             * @memberof gauge.messages
             * @classdesc A proto object representing Fragment.
             * @implements IParameter
             * @constructor
             * @param {gauge.messages.IParameter=} [properties] Properties to set
             */
            function Parameter(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Type of the Parameter. Valid values: Static, Dynamic, Special_String, Special_Table, Table
             * @member {gauge.messages.Parameter.ParameterType} parameterType
             * @memberof gauge.messages.Parameter
             * @instance
             */
            Parameter.prototype.parameterType = 0;

            /**
             * Holds the value of the parameter
             * @member {string} value
             * @memberof gauge.messages.Parameter
             * @instance
             */
            Parameter.prototype.value = "";

            /**
             * Holds the name of the parameter, used as Key to lookup the value.
             * @member {string} name
             * @memberof gauge.messages.Parameter
             * @instance
             */
            Parameter.prototype.name = "";

            /**
             * Holds the table value, if parameterType=Table or Special_Table
             * @member {gauge.messages.IProtoTable|null|undefined} table
             * @memberof gauge.messages.Parameter
             * @instance
             */
            Parameter.prototype.table = null;

            /**
             * Creates a new Parameter instance using the specified properties.
             * @function create
             * @memberof gauge.messages.Parameter
             * @static
             * @param {gauge.messages.IParameter=} [properties] Properties to set
             * @returns {gauge.messages.Parameter} Parameter instance
             */
            Parameter.create = function create(properties) {
                return new Parameter(properties);
            };

            /**
             * Encodes the specified Parameter message. Does not implicitly {@link gauge.messages.Parameter.verify|verify} messages.
             * @function encode
             * @memberof gauge.messages.Parameter
             * @static
             * @param {gauge.messages.IParameter} message Parameter message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Parameter.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.parameterType != null && message.hasOwnProperty("parameterType"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.parameterType);
                if (message.value != null && message.hasOwnProperty("value"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.value);
                if (message.name != null && message.hasOwnProperty("name"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.name);
                if (message.table != null && message.hasOwnProperty("table"))
                    $root.gauge.messages.ProtoTable.encode(message.table, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Parameter message, length delimited. Does not implicitly {@link gauge.messages.Parameter.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gauge.messages.Parameter
             * @static
             * @param {gauge.messages.IParameter} message Parameter message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Parameter.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Parameter message from the specified reader or buffer.
             * @function decode
             * @memberof gauge.messages.Parameter
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gauge.messages.Parameter} Parameter
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Parameter.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gauge.messages.Parameter();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.parameterType = reader.int32();
                        break;
                    case 2:
                        message.value = reader.string();
                        break;
                    case 3:
                        message.name = reader.string();
                        break;
                    case 4:
                        message.table = $root.gauge.messages.ProtoTable.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Parameter message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gauge.messages.Parameter
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gauge.messages.Parameter} Parameter
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Parameter.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Parameter message.
             * @function verify
             * @memberof gauge.messages.Parameter
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Parameter.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.parameterType != null && message.hasOwnProperty("parameterType"))
                    switch (message.parameterType) {
                    default:
                        return "parameterType: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                        break;
                    }
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!$util.isString(message.value))
                        return "value: string expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.table != null && message.hasOwnProperty("table")) {
                    var error = $root.gauge.messages.ProtoTable.verify(message.table);
                    if (error)
                        return "table." + error;
                }
                return null;
            };

            /**
             * Creates a Parameter message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gauge.messages.Parameter
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gauge.messages.Parameter} Parameter
             */
            Parameter.fromObject = function fromObject(object) {
                if (object instanceof $root.gauge.messages.Parameter)
                    return object;
                var message = new $root.gauge.messages.Parameter();
                switch (object.parameterType) {
                case "Static":
                case 0:
                    message.parameterType = 0;
                    break;
                case "Dynamic":
                case 1:
                    message.parameterType = 1;
                    break;
                case "Special_String":
                case 2:
                    message.parameterType = 2;
                    break;
                case "Special_Table":
                case 3:
                    message.parameterType = 3;
                    break;
                case "Table":
                case 4:
                    message.parameterType = 4;
                    break;
                }
                if (object.value != null)
                    message.value = String(object.value);
                if (object.name != null)
                    message.name = String(object.name);
                if (object.table != null) {
                    if (typeof object.table !== "object")
                        throw TypeError(".gauge.messages.Parameter.table: object expected");
                    message.table = $root.gauge.messages.ProtoTable.fromObject(object.table);
                }
                return message;
            };

            /**
             * Creates a plain object from a Parameter message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gauge.messages.Parameter
             * @static
             * @param {gauge.messages.Parameter} message Parameter
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Parameter.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.parameterType = options.enums === String ? "Static" : 0;
                    object.value = "";
                    object.name = "";
                    object.table = null;
                }
                if (message.parameterType != null && message.hasOwnProperty("parameterType"))
                    object.parameterType = options.enums === String ? $root.gauge.messages.Parameter.ParameterType[message.parameterType] : message.parameterType;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = message.value;
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.table != null && message.hasOwnProperty("table"))
                    object.table = $root.gauge.messages.ProtoTable.toObject(message.table, options);
                return object;
            };

            /**
             * Converts this Parameter to JSON.
             * @function toJSON
             * @memberof gauge.messages.Parameter
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Parameter.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Enum representing types of Parameter.
             * @name gauge.messages.Parameter.ParameterType
             * @enum {string}
             * @property {number} Static=0 Static value
             * @property {number} Dynamic=1 Dynamic value
             * @property {number} Special_String=2 Special_String value
             * @property {number} Special_Table=3 Special_Table value
             * @property {number} Table=4 Table value
             */
            Parameter.ParameterType = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "Static"] = 0;
                values[valuesById[1] = "Dynamic"] = 1;
                values[valuesById[2] = "Special_String"] = 2;
                values[valuesById[3] = "Special_Table"] = 3;
                values[valuesById[4] = "Table"] = 4;
                return values;
            })();

            return Parameter;
        })();

        messages.ProtoComment = (function() {

            /**
             * Properties of a ProtoComment.
             * @memberof gauge.messages
             * @interface IProtoComment
             * @property {string|null} [text] Text representing the Comment.
             */

            /**
             * Constructs a new ProtoComment.
             * @memberof gauge.messages
             * @classdesc A proto object representing Comment.
             * @implements IProtoComment
             * @constructor
             * @param {gauge.messages.IProtoComment=} [properties] Properties to set
             */
            function ProtoComment(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Text representing the Comment.
             * @member {string} text
             * @memberof gauge.messages.ProtoComment
             * @instance
             */
            ProtoComment.prototype.text = "";

            /**
             * Creates a new ProtoComment instance using the specified properties.
             * @function create
             * @memberof gauge.messages.ProtoComment
             * @static
             * @param {gauge.messages.IProtoComment=} [properties] Properties to set
             * @returns {gauge.messages.ProtoComment} ProtoComment instance
             */
            ProtoComment.create = function create(properties) {
                return new ProtoComment(properties);
            };

            /**
             * Encodes the specified ProtoComment message. Does not implicitly {@link gauge.messages.ProtoComment.verify|verify} messages.
             * @function encode
             * @memberof gauge.messages.ProtoComment
             * @static
             * @param {gauge.messages.IProtoComment} message ProtoComment message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ProtoComment.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.text != null && message.hasOwnProperty("text"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.text);
                return writer;
            };

            /**
             * Encodes the specified ProtoComment message, length delimited. Does not implicitly {@link gauge.messages.ProtoComment.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gauge.messages.ProtoComment
             * @static
             * @param {gauge.messages.IProtoComment} message ProtoComment message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ProtoComment.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ProtoComment message from the specified reader or buffer.
             * @function decode
             * @memberof gauge.messages.ProtoComment
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gauge.messages.ProtoComment} ProtoComment
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ProtoComment.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gauge.messages.ProtoComment();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.text = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ProtoComment message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gauge.messages.ProtoComment
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gauge.messages.ProtoComment} ProtoComment
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ProtoComment.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ProtoComment message.
             * @function verify
             * @memberof gauge.messages.ProtoComment
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ProtoComment.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.text != null && message.hasOwnProperty("text"))
                    if (!$util.isString(message.text))
                        return "text: string expected";
                return null;
            };

            /**
             * Creates a ProtoComment message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gauge.messages.ProtoComment
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gauge.messages.ProtoComment} ProtoComment
             */
            ProtoComment.fromObject = function fromObject(object) {
                if (object instanceof $root.gauge.messages.ProtoComment)
                    return object;
                var message = new $root.gauge.messages.ProtoComment();
                if (object.text != null)
                    message.text = String(object.text);
                return message;
            };

            /**
             * Creates a plain object from a ProtoComment message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gauge.messages.ProtoComment
             * @static
             * @param {gauge.messages.ProtoComment} message ProtoComment
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ProtoComment.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.text = "";
                if (message.text != null && message.hasOwnProperty("text"))
                    object.text = message.text;
                return object;
            };

            /**
             * Converts this ProtoComment to JSON.
             * @function toJSON
             * @memberof gauge.messages.ProtoComment
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ProtoComment.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ProtoComment;
        })();

        messages.ProtoTable = (function() {

            /**
             * Properties of a ProtoTable.
             * @memberof gauge.messages
             * @interface IProtoTable
             * @property {gauge.messages.IProtoTableRow|null} [headers] Contains the Headers for the table
             * @property {Array.<gauge.messages.IProtoTableRow>|null} [rows] Contains the Rows for the table
             */

            /**
             * Constructs a new ProtoTable.
             * @memberof gauge.messages
             * @classdesc A proto object representing Table.
             * @implements IProtoTable
             * @constructor
             * @param {gauge.messages.IProtoTable=} [properties] Properties to set
             */
            function ProtoTable(properties) {
                this.rows = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Contains the Headers for the table
             * @member {gauge.messages.IProtoTableRow|null|undefined} headers
             * @memberof gauge.messages.ProtoTable
             * @instance
             */
            ProtoTable.prototype.headers = null;

            /**
             * Contains the Rows for the table
             * @member {Array.<gauge.messages.IProtoTableRow>} rows
             * @memberof gauge.messages.ProtoTable
             * @instance
             */
            ProtoTable.prototype.rows = $util.emptyArray;

            /**
             * Creates a new ProtoTable instance using the specified properties.
             * @function create
             * @memberof gauge.messages.ProtoTable
             * @static
             * @param {gauge.messages.IProtoTable=} [properties] Properties to set
             * @returns {gauge.messages.ProtoTable} ProtoTable instance
             */
            ProtoTable.create = function create(properties) {
                return new ProtoTable(properties);
            };

            /**
             * Encodes the specified ProtoTable message. Does not implicitly {@link gauge.messages.ProtoTable.verify|verify} messages.
             * @function encode
             * @memberof gauge.messages.ProtoTable
             * @static
             * @param {gauge.messages.IProtoTable} message ProtoTable message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ProtoTable.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.headers != null && message.hasOwnProperty("headers"))
                    $root.gauge.messages.ProtoTableRow.encode(message.headers, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.rows != null && message.rows.length)
                    for (var i = 0; i < message.rows.length; ++i)
                        $root.gauge.messages.ProtoTableRow.encode(message.rows[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ProtoTable message, length delimited. Does not implicitly {@link gauge.messages.ProtoTable.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gauge.messages.ProtoTable
             * @static
             * @param {gauge.messages.IProtoTable} message ProtoTable message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ProtoTable.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ProtoTable message from the specified reader or buffer.
             * @function decode
             * @memberof gauge.messages.ProtoTable
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gauge.messages.ProtoTable} ProtoTable
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ProtoTable.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gauge.messages.ProtoTable();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.headers = $root.gauge.messages.ProtoTableRow.decode(reader, reader.uint32());
                        break;
                    case 2:
                        if (!(message.rows && message.rows.length))
                            message.rows = [];
                        message.rows.push($root.gauge.messages.ProtoTableRow.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ProtoTable message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gauge.messages.ProtoTable
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gauge.messages.ProtoTable} ProtoTable
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ProtoTable.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ProtoTable message.
             * @function verify
             * @memberof gauge.messages.ProtoTable
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ProtoTable.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.headers != null && message.hasOwnProperty("headers")) {
                    var error = $root.gauge.messages.ProtoTableRow.verify(message.headers);
                    if (error)
                        return "headers." + error;
                }
                if (message.rows != null && message.hasOwnProperty("rows")) {
                    if (!Array.isArray(message.rows))
                        return "rows: array expected";
                    for (var i = 0; i < message.rows.length; ++i) {
                        var error = $root.gauge.messages.ProtoTableRow.verify(message.rows[i]);
                        if (error)
                            return "rows." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a ProtoTable message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gauge.messages.ProtoTable
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gauge.messages.ProtoTable} ProtoTable
             */
            ProtoTable.fromObject = function fromObject(object) {
                if (object instanceof $root.gauge.messages.ProtoTable)
                    return object;
                var message = new $root.gauge.messages.ProtoTable();
                if (object.headers != null) {
                    if (typeof object.headers !== "object")
                        throw TypeError(".gauge.messages.ProtoTable.headers: object expected");
                    message.headers = $root.gauge.messages.ProtoTableRow.fromObject(object.headers);
                }
                if (object.rows) {
                    if (!Array.isArray(object.rows))
                        throw TypeError(".gauge.messages.ProtoTable.rows: array expected");
                    message.rows = [];
                    for (var i = 0; i < object.rows.length; ++i) {
                        if (typeof object.rows[i] !== "object")
                            throw TypeError(".gauge.messages.ProtoTable.rows: object expected");
                        message.rows[i] = $root.gauge.messages.ProtoTableRow.fromObject(object.rows[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a ProtoTable message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gauge.messages.ProtoTable
             * @static
             * @param {gauge.messages.ProtoTable} message ProtoTable
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ProtoTable.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.rows = [];
                if (options.defaults)
                    object.headers = null;
                if (message.headers != null && message.hasOwnProperty("headers"))
                    object.headers = $root.gauge.messages.ProtoTableRow.toObject(message.headers, options);
                if (message.rows && message.rows.length) {
                    object.rows = [];
                    for (var j = 0; j < message.rows.length; ++j)
                        object.rows[j] = $root.gauge.messages.ProtoTableRow.toObject(message.rows[j], options);
                }
                return object;
            };

            /**
             * Converts this ProtoTable to JSON.
             * @function toJSON
             * @memberof gauge.messages.ProtoTable
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ProtoTable.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ProtoTable;
        })();

        messages.ProtoTableRow = (function() {

            /**
             * Properties of a ProtoTableRow.
             * @memberof gauge.messages
             * @interface IProtoTableRow
             * @property {Array.<string>|null} [cells] Represents the cells of a given table
             */

            /**
             * Constructs a new ProtoTableRow.
             * @memberof gauge.messages
             * @classdesc A proto object representing Table.
             * @implements IProtoTableRow
             * @constructor
             * @param {gauge.messages.IProtoTableRow=} [properties] Properties to set
             */
            function ProtoTableRow(properties) {
                this.cells = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Represents the cells of a given table
             * @member {Array.<string>} cells
             * @memberof gauge.messages.ProtoTableRow
             * @instance
             */
            ProtoTableRow.prototype.cells = $util.emptyArray;

            /**
             * Creates a new ProtoTableRow instance using the specified properties.
             * @function create
             * @memberof gauge.messages.ProtoTableRow
             * @static
             * @param {gauge.messages.IProtoTableRow=} [properties] Properties to set
             * @returns {gauge.messages.ProtoTableRow} ProtoTableRow instance
             */
            ProtoTableRow.create = function create(properties) {
                return new ProtoTableRow(properties);
            };

            /**
             * Encodes the specified ProtoTableRow message. Does not implicitly {@link gauge.messages.ProtoTableRow.verify|verify} messages.
             * @function encode
             * @memberof gauge.messages.ProtoTableRow
             * @static
             * @param {gauge.messages.IProtoTableRow} message ProtoTableRow message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ProtoTableRow.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.cells != null && message.cells.length)
                    for (var i = 0; i < message.cells.length; ++i)
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.cells[i]);
                return writer;
            };

            /**
             * Encodes the specified ProtoTableRow message, length delimited. Does not implicitly {@link gauge.messages.ProtoTableRow.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gauge.messages.ProtoTableRow
             * @static
             * @param {gauge.messages.IProtoTableRow} message ProtoTableRow message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ProtoTableRow.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ProtoTableRow message from the specified reader or buffer.
             * @function decode
             * @memberof gauge.messages.ProtoTableRow
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gauge.messages.ProtoTableRow} ProtoTableRow
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ProtoTableRow.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gauge.messages.ProtoTableRow();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.cells && message.cells.length))
                            message.cells = [];
                        message.cells.push(reader.string());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ProtoTableRow message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gauge.messages.ProtoTableRow
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gauge.messages.ProtoTableRow} ProtoTableRow
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ProtoTableRow.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ProtoTableRow message.
             * @function verify
             * @memberof gauge.messages.ProtoTableRow
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ProtoTableRow.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.cells != null && message.hasOwnProperty("cells")) {
                    if (!Array.isArray(message.cells))
                        return "cells: array expected";
                    for (var i = 0; i < message.cells.length; ++i)
                        if (!$util.isString(message.cells[i]))
                            return "cells: string[] expected";
                }
                return null;
            };

            /**
             * Creates a ProtoTableRow message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gauge.messages.ProtoTableRow
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gauge.messages.ProtoTableRow} ProtoTableRow
             */
            ProtoTableRow.fromObject = function fromObject(object) {
                if (object instanceof $root.gauge.messages.ProtoTableRow)
                    return object;
                var message = new $root.gauge.messages.ProtoTableRow();
                if (object.cells) {
                    if (!Array.isArray(object.cells))
                        throw TypeError(".gauge.messages.ProtoTableRow.cells: array expected");
                    message.cells = [];
                    for (var i = 0; i < object.cells.length; ++i)
                        message.cells[i] = String(object.cells[i]);
                }
                return message;
            };

            /**
             * Creates a plain object from a ProtoTableRow message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gauge.messages.ProtoTableRow
             * @static
             * @param {gauge.messages.ProtoTableRow} message ProtoTableRow
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ProtoTableRow.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.cells = [];
                if (message.cells && message.cells.length) {
                    object.cells = [];
                    for (var j = 0; j < message.cells.length; ++j)
                        object.cells[j] = message.cells[j];
                }
                return object;
            };

            /**
             * Converts this ProtoTableRow to JSON.
             * @function toJSON
             * @memberof gauge.messages.ProtoTableRow
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ProtoTableRow.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ProtoTableRow;
        })();

        messages.ProtoStepExecutionResult = (function() {

            /**
             * Properties of a ProtoStepExecutionResult.
             * @memberof gauge.messages
             * @interface IProtoStepExecutionResult
             * @property {gauge.messages.IProtoExecutionResult|null} [executionResult] The actual result of the execution
             * @property {gauge.messages.IProtoHookFailure|null} [preHookFailure] Contains a 'before' hook failure message. This happens when the `before_step` hook has an error.
             * @property {gauge.messages.IProtoHookFailure|null} [postHookFailure] Contains a 'after' hook failure message. This happens when the `after_step` hook has an error.
             * @property {boolean|null} [skipped] ProtoStepExecutionResult skipped
             * @property {string|null} [skippedReason] ProtoStepExecutionResult skippedReason
             */

            /**
             * Constructs a new ProtoStepExecutionResult.
             * @memberof gauge.messages
             * @classdesc A proto object representing Step Execution result
             * @implements IProtoStepExecutionResult
             * @constructor
             * @param {gauge.messages.IProtoStepExecutionResult=} [properties] Properties to set
             */
            function ProtoStepExecutionResult(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * The actual result of the execution
             * @member {gauge.messages.IProtoExecutionResult|null|undefined} executionResult
             * @memberof gauge.messages.ProtoStepExecutionResult
             * @instance
             */
            ProtoStepExecutionResult.prototype.executionResult = null;

            /**
             * Contains a 'before' hook failure message. This happens when the `before_step` hook has an error.
             * @member {gauge.messages.IProtoHookFailure|null|undefined} preHookFailure
             * @memberof gauge.messages.ProtoStepExecutionResult
             * @instance
             */
            ProtoStepExecutionResult.prototype.preHookFailure = null;

            /**
             * Contains a 'after' hook failure message. This happens when the `after_step` hook has an error.
             * @member {gauge.messages.IProtoHookFailure|null|undefined} postHookFailure
             * @memberof gauge.messages.ProtoStepExecutionResult
             * @instance
             */
            ProtoStepExecutionResult.prototype.postHookFailure = null;

            /**
             * ProtoStepExecutionResult skipped.
             * @member {boolean} skipped
             * @memberof gauge.messages.ProtoStepExecutionResult
             * @instance
             */
            ProtoStepExecutionResult.prototype.skipped = false;

            /**
             * ProtoStepExecutionResult skippedReason.
             * @member {string} skippedReason
             * @memberof gauge.messages.ProtoStepExecutionResult
             * @instance
             */
            ProtoStepExecutionResult.prototype.skippedReason = "";

            /**
             * Creates a new ProtoStepExecutionResult instance using the specified properties.
             * @function create
             * @memberof gauge.messages.ProtoStepExecutionResult
             * @static
             * @param {gauge.messages.IProtoStepExecutionResult=} [properties] Properties to set
             * @returns {gauge.messages.ProtoStepExecutionResult} ProtoStepExecutionResult instance
             */
            ProtoStepExecutionResult.create = function create(properties) {
                return new ProtoStepExecutionResult(properties);
            };

            /**
             * Encodes the specified ProtoStepExecutionResult message. Does not implicitly {@link gauge.messages.ProtoStepExecutionResult.verify|verify} messages.
             * @function encode
             * @memberof gauge.messages.ProtoStepExecutionResult
             * @static
             * @param {gauge.messages.IProtoStepExecutionResult} message ProtoStepExecutionResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ProtoStepExecutionResult.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.executionResult != null && message.hasOwnProperty("executionResult"))
                    $root.gauge.messages.ProtoExecutionResult.encode(message.executionResult, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.preHookFailure != null && message.hasOwnProperty("preHookFailure"))
                    $root.gauge.messages.ProtoHookFailure.encode(message.preHookFailure, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.postHookFailure != null && message.hasOwnProperty("postHookFailure"))
                    $root.gauge.messages.ProtoHookFailure.encode(message.postHookFailure, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.skipped != null && message.hasOwnProperty("skipped"))
                    writer.uint32(/* id 4, wireType 0 =*/32).bool(message.skipped);
                if (message.skippedReason != null && message.hasOwnProperty("skippedReason"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.skippedReason);
                return writer;
            };

            /**
             * Encodes the specified ProtoStepExecutionResult message, length delimited. Does not implicitly {@link gauge.messages.ProtoStepExecutionResult.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gauge.messages.ProtoStepExecutionResult
             * @static
             * @param {gauge.messages.IProtoStepExecutionResult} message ProtoStepExecutionResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ProtoStepExecutionResult.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ProtoStepExecutionResult message from the specified reader or buffer.
             * @function decode
             * @memberof gauge.messages.ProtoStepExecutionResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gauge.messages.ProtoStepExecutionResult} ProtoStepExecutionResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ProtoStepExecutionResult.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gauge.messages.ProtoStepExecutionResult();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.executionResult = $root.gauge.messages.ProtoExecutionResult.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.preHookFailure = $root.gauge.messages.ProtoHookFailure.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.postHookFailure = $root.gauge.messages.ProtoHookFailure.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.skipped = reader.bool();
                        break;
                    case 5:
                        message.skippedReason = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ProtoStepExecutionResult message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gauge.messages.ProtoStepExecutionResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gauge.messages.ProtoStepExecutionResult} ProtoStepExecutionResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ProtoStepExecutionResult.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ProtoStepExecutionResult message.
             * @function verify
             * @memberof gauge.messages.ProtoStepExecutionResult
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ProtoStepExecutionResult.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.executionResult != null && message.hasOwnProperty("executionResult")) {
                    var error = $root.gauge.messages.ProtoExecutionResult.verify(message.executionResult);
                    if (error)
                        return "executionResult." + error;
                }
                if (message.preHookFailure != null && message.hasOwnProperty("preHookFailure")) {
                    var error = $root.gauge.messages.ProtoHookFailure.verify(message.preHookFailure);
                    if (error)
                        return "preHookFailure." + error;
                }
                if (message.postHookFailure != null && message.hasOwnProperty("postHookFailure")) {
                    var error = $root.gauge.messages.ProtoHookFailure.verify(message.postHookFailure);
                    if (error)
                        return "postHookFailure." + error;
                }
                if (message.skipped != null && message.hasOwnProperty("skipped"))
                    if (typeof message.skipped !== "boolean")
                        return "skipped: boolean expected";
                if (message.skippedReason != null && message.hasOwnProperty("skippedReason"))
                    if (!$util.isString(message.skippedReason))
                        return "skippedReason: string expected";
                return null;
            };

            /**
             * Creates a ProtoStepExecutionResult message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gauge.messages.ProtoStepExecutionResult
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gauge.messages.ProtoStepExecutionResult} ProtoStepExecutionResult
             */
            ProtoStepExecutionResult.fromObject = function fromObject(object) {
                if (object instanceof $root.gauge.messages.ProtoStepExecutionResult)
                    return object;
                var message = new $root.gauge.messages.ProtoStepExecutionResult();
                if (object.executionResult != null) {
                    if (typeof object.executionResult !== "object")
                        throw TypeError(".gauge.messages.ProtoStepExecutionResult.executionResult: object expected");
                    message.executionResult = $root.gauge.messages.ProtoExecutionResult.fromObject(object.executionResult);
                }
                if (object.preHookFailure != null) {
                    if (typeof object.preHookFailure !== "object")
                        throw TypeError(".gauge.messages.ProtoStepExecutionResult.preHookFailure: object expected");
                    message.preHookFailure = $root.gauge.messages.ProtoHookFailure.fromObject(object.preHookFailure);
                }
                if (object.postHookFailure != null) {
                    if (typeof object.postHookFailure !== "object")
                        throw TypeError(".gauge.messages.ProtoStepExecutionResult.postHookFailure: object expected");
                    message.postHookFailure = $root.gauge.messages.ProtoHookFailure.fromObject(object.postHookFailure);
                }
                if (object.skipped != null)
                    message.skipped = Boolean(object.skipped);
                if (object.skippedReason != null)
                    message.skippedReason = String(object.skippedReason);
                return message;
            };

            /**
             * Creates a plain object from a ProtoStepExecutionResult message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gauge.messages.ProtoStepExecutionResult
             * @static
             * @param {gauge.messages.ProtoStepExecutionResult} message ProtoStepExecutionResult
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ProtoStepExecutionResult.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.executionResult = null;
                    object.preHookFailure = null;
                    object.postHookFailure = null;
                    object.skipped = false;
                    object.skippedReason = "";
                }
                if (message.executionResult != null && message.hasOwnProperty("executionResult"))
                    object.executionResult = $root.gauge.messages.ProtoExecutionResult.toObject(message.executionResult, options);
                if (message.preHookFailure != null && message.hasOwnProperty("preHookFailure"))
                    object.preHookFailure = $root.gauge.messages.ProtoHookFailure.toObject(message.preHookFailure, options);
                if (message.postHookFailure != null && message.hasOwnProperty("postHookFailure"))
                    object.postHookFailure = $root.gauge.messages.ProtoHookFailure.toObject(message.postHookFailure, options);
                if (message.skipped != null && message.hasOwnProperty("skipped"))
                    object.skipped = message.skipped;
                if (message.skippedReason != null && message.hasOwnProperty("skippedReason"))
                    object.skippedReason = message.skippedReason;
                return object;
            };

            /**
             * Converts this ProtoStepExecutionResult to JSON.
             * @function toJSON
             * @memberof gauge.messages.ProtoStepExecutionResult
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ProtoStepExecutionResult.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ProtoStepExecutionResult;
        })();

        messages.ProtoExecutionResult = (function() {

            /**
             * Properties of a ProtoExecutionResult.
             * @memberof gauge.messages
             * @interface IProtoExecutionResult
             * @property {boolean|null} [failed] Flag to indicate failure
             * @property {boolean|null} [recoverableError] Flag to indicate if the error is recoverable from.
             * @property {string|null} [errorMessage] The actual error message.
             * @property {string|null} [stackTrace] Stacktrace of the error
             * @property {Uint8Array|null} [screenShot] [DEPRECATED, use failureScreenshotFile] Bytes containing screenshot taken at the time of failure.
             * @property {number|Long|null} [executionTime] Holds the time taken for executing this scenario.
             * @property {Array.<string>|null} [message] Additional information at exec time to be available on reports
             * @property {gauge.messages.ProtoExecutionResult.ErrorType|null} [errorType] Type of the Error. Valid values: ASSERTION, VERIFICATION. Default: ASSERTION
             * @property {Uint8Array|null} [failureScreenshot] [DEPRECATED, use failureScreenshotFile] Bytes containing screenshot taken at the time of failure.
             * @property {Array.<Uint8Array>|null} [screenshots] [DEPRECATED, use screenshotFiles] Bytes array containing screenshots at the time of it invoked
             * @property {string|null} [failureScreenshotFile] Path to the screenshot file captured at the time of failure.
             * @property {Array.<string>|null} [screenshotFiles] Path to the screenshot files captured using Gauge screenshsot API.
             */

            /**
             * Constructs a new ProtoExecutionResult.
             * @memberof gauge.messages
             * @classdesc A proto object representing the result of an execution
             * @implements IProtoExecutionResult
             * @constructor
             * @param {gauge.messages.IProtoExecutionResult=} [properties] Properties to set
             */
            function ProtoExecutionResult(properties) {
                this.message = [];
                this.screenshots = [];
                this.screenshotFiles = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Flag to indicate failure
             * @member {boolean} failed
             * @memberof gauge.messages.ProtoExecutionResult
             * @instance
             */
            ProtoExecutionResult.prototype.failed = false;

            /**
             * Flag to indicate if the error is recoverable from.
             * @member {boolean} recoverableError
             * @memberof gauge.messages.ProtoExecutionResult
             * @instance
             */
            ProtoExecutionResult.prototype.recoverableError = false;

            /**
             * The actual error message.
             * @member {string} errorMessage
             * @memberof gauge.messages.ProtoExecutionResult
             * @instance
             */
            ProtoExecutionResult.prototype.errorMessage = "";

            /**
             * Stacktrace of the error
             * @member {string} stackTrace
             * @memberof gauge.messages.ProtoExecutionResult
             * @instance
             */
            ProtoExecutionResult.prototype.stackTrace = "";

            /**
             * [DEPRECATED, use failureScreenshotFile] Bytes containing screenshot taken at the time of failure.
             * @member {Uint8Array} screenShot
             * @memberof gauge.messages.ProtoExecutionResult
             * @instance
             */
            ProtoExecutionResult.prototype.screenShot = $util.newBuffer([]);

            /**
             * Holds the time taken for executing this scenario.
             * @member {number|Long} executionTime
             * @memberof gauge.messages.ProtoExecutionResult
             * @instance
             */
            ProtoExecutionResult.prototype.executionTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Additional information at exec time to be available on reports
             * @member {Array.<string>} message
             * @memberof gauge.messages.ProtoExecutionResult
             * @instance
             */
            ProtoExecutionResult.prototype.message = $util.emptyArray;

            /**
             * Type of the Error. Valid values: ASSERTION, VERIFICATION. Default: ASSERTION
             * @member {gauge.messages.ProtoExecutionResult.ErrorType} errorType
             * @memberof gauge.messages.ProtoExecutionResult
             * @instance
             */
            ProtoExecutionResult.prototype.errorType = 0;

            /**
             * [DEPRECATED, use failureScreenshotFile] Bytes containing screenshot taken at the time of failure.
             * @member {Uint8Array} failureScreenshot
             * @memberof gauge.messages.ProtoExecutionResult
             * @instance
             */
            ProtoExecutionResult.prototype.failureScreenshot = $util.newBuffer([]);

            /**
             * [DEPRECATED, use screenshotFiles] Bytes array containing screenshots at the time of it invoked
             * @member {Array.<Uint8Array>} screenshots
             * @memberof gauge.messages.ProtoExecutionResult
             * @instance
             */
            ProtoExecutionResult.prototype.screenshots = $util.emptyArray;

            /**
             * Path to the screenshot file captured at the time of failure.
             * @member {string} failureScreenshotFile
             * @memberof gauge.messages.ProtoExecutionResult
             * @instance
             */
            ProtoExecutionResult.prototype.failureScreenshotFile = "";

            /**
             * Path to the screenshot files captured using Gauge screenshsot API.
             * @member {Array.<string>} screenshotFiles
             * @memberof gauge.messages.ProtoExecutionResult
             * @instance
             */
            ProtoExecutionResult.prototype.screenshotFiles = $util.emptyArray;

            /**
             * Creates a new ProtoExecutionResult instance using the specified properties.
             * @function create
             * @memberof gauge.messages.ProtoExecutionResult
             * @static
             * @param {gauge.messages.IProtoExecutionResult=} [properties] Properties to set
             * @returns {gauge.messages.ProtoExecutionResult} ProtoExecutionResult instance
             */
            ProtoExecutionResult.create = function create(properties) {
                return new ProtoExecutionResult(properties);
            };

            /**
             * Encodes the specified ProtoExecutionResult message. Does not implicitly {@link gauge.messages.ProtoExecutionResult.verify|verify} messages.
             * @function encode
             * @memberof gauge.messages.ProtoExecutionResult
             * @static
             * @param {gauge.messages.IProtoExecutionResult} message ProtoExecutionResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ProtoExecutionResult.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.failed != null && message.hasOwnProperty("failed"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.failed);
                if (message.recoverableError != null && message.hasOwnProperty("recoverableError"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.recoverableError);
                if (message.errorMessage != null && message.hasOwnProperty("errorMessage"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.errorMessage);
                if (message.stackTrace != null && message.hasOwnProperty("stackTrace"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.stackTrace);
                if (message.screenShot != null && message.hasOwnProperty("screenShot"))
                    writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.screenShot);
                if (message.executionTime != null && message.hasOwnProperty("executionTime"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int64(message.executionTime);
                if (message.message != null && message.message.length)
                    for (var i = 0; i < message.message.length; ++i)
                        writer.uint32(/* id 7, wireType 2 =*/58).string(message.message[i]);
                if (message.errorType != null && message.hasOwnProperty("errorType"))
                    writer.uint32(/* id 8, wireType 0 =*/64).int32(message.errorType);
                if (message.failureScreenshot != null && message.hasOwnProperty("failureScreenshot"))
                    writer.uint32(/* id 9, wireType 2 =*/74).bytes(message.failureScreenshot);
                if (message.screenshots != null && message.screenshots.length)
                    for (var i = 0; i < message.screenshots.length; ++i)
                        writer.uint32(/* id 10, wireType 2 =*/82).bytes(message.screenshots[i]);
                if (message.failureScreenshotFile != null && message.hasOwnProperty("failureScreenshotFile"))
                    writer.uint32(/* id 11, wireType 2 =*/90).string(message.failureScreenshotFile);
                if (message.screenshotFiles != null && message.screenshotFiles.length)
                    for (var i = 0; i < message.screenshotFiles.length; ++i)
                        writer.uint32(/* id 12, wireType 2 =*/98).string(message.screenshotFiles[i]);
                return writer;
            };

            /**
             * Encodes the specified ProtoExecutionResult message, length delimited. Does not implicitly {@link gauge.messages.ProtoExecutionResult.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gauge.messages.ProtoExecutionResult
             * @static
             * @param {gauge.messages.IProtoExecutionResult} message ProtoExecutionResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ProtoExecutionResult.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ProtoExecutionResult message from the specified reader or buffer.
             * @function decode
             * @memberof gauge.messages.ProtoExecutionResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gauge.messages.ProtoExecutionResult} ProtoExecutionResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ProtoExecutionResult.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gauge.messages.ProtoExecutionResult();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.failed = reader.bool();
                        break;
                    case 2:
                        message.recoverableError = reader.bool();
                        break;
                    case 3:
                        message.errorMessage = reader.string();
                        break;
                    case 4:
                        message.stackTrace = reader.string();
                        break;
                    case 5:
                        message.screenShot = reader.bytes();
                        break;
                    case 6:
                        message.executionTime = reader.int64();
                        break;
                    case 7:
                        if (!(message.message && message.message.length))
                            message.message = [];
                        message.message.push(reader.string());
                        break;
                    case 8:
                        message.errorType = reader.int32();
                        break;
                    case 9:
                        message.failureScreenshot = reader.bytes();
                        break;
                    case 10:
                        if (!(message.screenshots && message.screenshots.length))
                            message.screenshots = [];
                        message.screenshots.push(reader.bytes());
                        break;
                    case 11:
                        message.failureScreenshotFile = reader.string();
                        break;
                    case 12:
                        if (!(message.screenshotFiles && message.screenshotFiles.length))
                            message.screenshotFiles = [];
                        message.screenshotFiles.push(reader.string());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ProtoExecutionResult message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gauge.messages.ProtoExecutionResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gauge.messages.ProtoExecutionResult} ProtoExecutionResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ProtoExecutionResult.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ProtoExecutionResult message.
             * @function verify
             * @memberof gauge.messages.ProtoExecutionResult
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ProtoExecutionResult.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.failed != null && message.hasOwnProperty("failed"))
                    if (typeof message.failed !== "boolean")
                        return "failed: boolean expected";
                if (message.recoverableError != null && message.hasOwnProperty("recoverableError"))
                    if (typeof message.recoverableError !== "boolean")
                        return "recoverableError: boolean expected";
                if (message.errorMessage != null && message.hasOwnProperty("errorMessage"))
                    if (!$util.isString(message.errorMessage))
                        return "errorMessage: string expected";
                if (message.stackTrace != null && message.hasOwnProperty("stackTrace"))
                    if (!$util.isString(message.stackTrace))
                        return "stackTrace: string expected";
                if (message.screenShot != null && message.hasOwnProperty("screenShot"))
                    if (!(message.screenShot && typeof message.screenShot.length === "number" || $util.isString(message.screenShot)))
                        return "screenShot: buffer expected";
                if (message.executionTime != null && message.hasOwnProperty("executionTime"))
                    if (!$util.isInteger(message.executionTime) && !(message.executionTime && $util.isInteger(message.executionTime.low) && $util.isInteger(message.executionTime.high)))
                        return "executionTime: integer|Long expected";
                if (message.message != null && message.hasOwnProperty("message")) {
                    if (!Array.isArray(message.message))
                        return "message: array expected";
                    for (var i = 0; i < message.message.length; ++i)
                        if (!$util.isString(message.message[i]))
                            return "message: string[] expected";
                }
                if (message.errorType != null && message.hasOwnProperty("errorType"))
                    switch (message.errorType) {
                    default:
                        return "errorType: enum value expected";
                    case 0:
                    case 1:
                        break;
                    }
                if (message.failureScreenshot != null && message.hasOwnProperty("failureScreenshot"))
                    if (!(message.failureScreenshot && typeof message.failureScreenshot.length === "number" || $util.isString(message.failureScreenshot)))
                        return "failureScreenshot: buffer expected";
                if (message.screenshots != null && message.hasOwnProperty("screenshots")) {
                    if (!Array.isArray(message.screenshots))
                        return "screenshots: array expected";
                    for (var i = 0; i < message.screenshots.length; ++i)
                        if (!(message.screenshots[i] && typeof message.screenshots[i].length === "number" || $util.isString(message.screenshots[i])))
                            return "screenshots: buffer[] expected";
                }
                if (message.failureScreenshotFile != null && message.hasOwnProperty("failureScreenshotFile"))
                    if (!$util.isString(message.failureScreenshotFile))
                        return "failureScreenshotFile: string expected";
                if (message.screenshotFiles != null && message.hasOwnProperty("screenshotFiles")) {
                    if (!Array.isArray(message.screenshotFiles))
                        return "screenshotFiles: array expected";
                    for (var i = 0; i < message.screenshotFiles.length; ++i)
                        if (!$util.isString(message.screenshotFiles[i]))
                            return "screenshotFiles: string[] expected";
                }
                return null;
            };

            /**
             * Creates a ProtoExecutionResult message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gauge.messages.ProtoExecutionResult
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gauge.messages.ProtoExecutionResult} ProtoExecutionResult
             */
            ProtoExecutionResult.fromObject = function fromObject(object) {
                if (object instanceof $root.gauge.messages.ProtoExecutionResult)
                    return object;
                var message = new $root.gauge.messages.ProtoExecutionResult();
                if (object.failed != null)
                    message.failed = Boolean(object.failed);
                if (object.recoverableError != null)
                    message.recoverableError = Boolean(object.recoverableError);
                if (object.errorMessage != null)
                    message.errorMessage = String(object.errorMessage);
                if (object.stackTrace != null)
                    message.stackTrace = String(object.stackTrace);
                if (object.screenShot != null)
                    if (typeof object.screenShot === "string")
                        $util.base64.decode(object.screenShot, message.screenShot = $util.newBuffer($util.base64.length(object.screenShot)), 0);
                    else if (object.screenShot.length)
                        message.screenShot = object.screenShot;
                if (object.executionTime != null)
                    if ($util.Long)
                        (message.executionTime = $util.Long.fromValue(object.executionTime)).unsigned = false;
                    else if (typeof object.executionTime === "string")
                        message.executionTime = parseInt(object.executionTime, 10);
                    else if (typeof object.executionTime === "number")
                        message.executionTime = object.executionTime;
                    else if (typeof object.executionTime === "object")
                        message.executionTime = new $util.LongBits(object.executionTime.low >>> 0, object.executionTime.high >>> 0).toNumber();
                if (object.message) {
                    if (!Array.isArray(object.message))
                        throw TypeError(".gauge.messages.ProtoExecutionResult.message: array expected");
                    message.message = [];
                    for (var i = 0; i < object.message.length; ++i)
                        message.message[i] = String(object.message[i]);
                }
                switch (object.errorType) {
                case "ASSERTION":
                case 0:
                    message.errorType = 0;
                    break;
                case "VERIFICATION":
                case 1:
                    message.errorType = 1;
                    break;
                }
                if (object.failureScreenshot != null)
                    if (typeof object.failureScreenshot === "string")
                        $util.base64.decode(object.failureScreenshot, message.failureScreenshot = $util.newBuffer($util.base64.length(object.failureScreenshot)), 0);
                    else if (object.failureScreenshot.length)
                        message.failureScreenshot = object.failureScreenshot;
                if (object.screenshots) {
                    if (!Array.isArray(object.screenshots))
                        throw TypeError(".gauge.messages.ProtoExecutionResult.screenshots: array expected");
                    message.screenshots = [];
                    for (var i = 0; i < object.screenshots.length; ++i)
                        if (typeof object.screenshots[i] === "string")
                            $util.base64.decode(object.screenshots[i], message.screenshots[i] = $util.newBuffer($util.base64.length(object.screenshots[i])), 0);
                        else if (object.screenshots[i].length)
                            message.screenshots[i] = object.screenshots[i];
                }
                if (object.failureScreenshotFile != null)
                    message.failureScreenshotFile = String(object.failureScreenshotFile);
                if (object.screenshotFiles) {
                    if (!Array.isArray(object.screenshotFiles))
                        throw TypeError(".gauge.messages.ProtoExecutionResult.screenshotFiles: array expected");
                    message.screenshotFiles = [];
                    for (var i = 0; i < object.screenshotFiles.length; ++i)
                        message.screenshotFiles[i] = String(object.screenshotFiles[i]);
                }
                return message;
            };

            /**
             * Creates a plain object from a ProtoExecutionResult message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gauge.messages.ProtoExecutionResult
             * @static
             * @param {gauge.messages.ProtoExecutionResult} message ProtoExecutionResult
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ProtoExecutionResult.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults) {
                    object.message = [];
                    object.screenshots = [];
                    object.screenshotFiles = [];
                }
                if (options.defaults) {
                    object.failed = false;
                    object.recoverableError = false;
                    object.errorMessage = "";
                    object.stackTrace = "";
                    if (options.bytes === String)
                        object.screenShot = "";
                    else {
                        object.screenShot = [];
                        if (options.bytes !== Array)
                            object.screenShot = $util.newBuffer(object.screenShot);
                    }
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.executionTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.executionTime = options.longs === String ? "0" : 0;
                    object.errorType = options.enums === String ? "ASSERTION" : 0;
                    if (options.bytes === String)
                        object.failureScreenshot = "";
                    else {
                        object.failureScreenshot = [];
                        if (options.bytes !== Array)
                            object.failureScreenshot = $util.newBuffer(object.failureScreenshot);
                    }
                    object.failureScreenshotFile = "";
                }
                if (message.failed != null && message.hasOwnProperty("failed"))
                    object.failed = message.failed;
                if (message.recoverableError != null && message.hasOwnProperty("recoverableError"))
                    object.recoverableError = message.recoverableError;
                if (message.errorMessage != null && message.hasOwnProperty("errorMessage"))
                    object.errorMessage = message.errorMessage;
                if (message.stackTrace != null && message.hasOwnProperty("stackTrace"))
                    object.stackTrace = message.stackTrace;
                if (message.screenShot != null && message.hasOwnProperty("screenShot"))
                    object.screenShot = options.bytes === String ? $util.base64.encode(message.screenShot, 0, message.screenShot.length) : options.bytes === Array ? Array.prototype.slice.call(message.screenShot) : message.screenShot;
                if (message.executionTime != null && message.hasOwnProperty("executionTime"))
                    if (typeof message.executionTime === "number")
                        object.executionTime = options.longs === String ? String(message.executionTime) : message.executionTime;
                    else
                        object.executionTime = options.longs === String ? $util.Long.prototype.toString.call(message.executionTime) : options.longs === Number ? new $util.LongBits(message.executionTime.low >>> 0, message.executionTime.high >>> 0).toNumber() : message.executionTime;
                if (message.message && message.message.length) {
                    object.message = [];
                    for (var j = 0; j < message.message.length; ++j)
                        object.message[j] = message.message[j];
                }
                if (message.errorType != null && message.hasOwnProperty("errorType"))
                    object.errorType = options.enums === String ? $root.gauge.messages.ProtoExecutionResult.ErrorType[message.errorType] : message.errorType;
                if (message.failureScreenshot != null && message.hasOwnProperty("failureScreenshot"))
                    object.failureScreenshot = options.bytes === String ? $util.base64.encode(message.failureScreenshot, 0, message.failureScreenshot.length) : options.bytes === Array ? Array.prototype.slice.call(message.failureScreenshot) : message.failureScreenshot;
                if (message.screenshots && message.screenshots.length) {
                    object.screenshots = [];
                    for (var j = 0; j < message.screenshots.length; ++j)
                        object.screenshots[j] = options.bytes === String ? $util.base64.encode(message.screenshots[j], 0, message.screenshots[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.screenshots[j]) : message.screenshots[j];
                }
                if (message.failureScreenshotFile != null && message.hasOwnProperty("failureScreenshotFile"))
                    object.failureScreenshotFile = message.failureScreenshotFile;
                if (message.screenshotFiles && message.screenshotFiles.length) {
                    object.screenshotFiles = [];
                    for (var j = 0; j < message.screenshotFiles.length; ++j)
                        object.screenshotFiles[j] = message.screenshotFiles[j];
                }
                return object;
            };

            /**
             * Converts this ProtoExecutionResult to JSON.
             * @function toJSON
             * @memberof gauge.messages.ProtoExecutionResult
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ProtoExecutionResult.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * ErrorType enum.
             * @name gauge.messages.ProtoExecutionResult.ErrorType
             * @enum {string}
             * @property {number} ASSERTION=0 ASSERTION value
             * @property {number} VERIFICATION=1 VERIFICATION value
             */
            ProtoExecutionResult.ErrorType = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "ASSERTION"] = 0;
                values[valuesById[1] = "VERIFICATION"] = 1;
                return values;
            })();

            return ProtoExecutionResult;
        })();

        messages.ProtoHookFailure = (function() {

            /**
             * Properties of a ProtoHookFailure.
             * @memberof gauge.messages
             * @interface IProtoHookFailure
             * @property {string|null} [stackTrace] Stacktrace from the failure
             * @property {string|null} [errorMessage] Error message from the failure
             * @property {Uint8Array|null} [screenShot] [DEPRECATED, use failureScreenshotFile] Bytes holding the screenshot taken at the time of failure.
             * @property {number|null} [tableRowIndex] ProtoHookFailure tableRowIndex
             * @property {Uint8Array|null} [failureScreenshot] [DEPRECATED, use failureScreenshotFile] Bytes holding the screenshot taken at the time of failure.
             * @property {string|null} [failureScreenshotFile] Path to the screenshot file captured at the time of failure.
             */

            /**
             * Constructs a new ProtoHookFailure.
             * @memberof gauge.messages
             * @classdesc Used to hold failure information for before_suite, before_spec, before_scenario and before_spec hooks.
             * @implements IProtoHookFailure
             * @constructor
             * @param {gauge.messages.IProtoHookFailure=} [properties] Properties to set
             */
            function ProtoHookFailure(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Stacktrace from the failure
             * @member {string} stackTrace
             * @memberof gauge.messages.ProtoHookFailure
             * @instance
             */
            ProtoHookFailure.prototype.stackTrace = "";

            /**
             * Error message from the failure
             * @member {string} errorMessage
             * @memberof gauge.messages.ProtoHookFailure
             * @instance
             */
            ProtoHookFailure.prototype.errorMessage = "";

            /**
             * [DEPRECATED, use failureScreenshotFile] Bytes holding the screenshot taken at the time of failure.
             * @member {Uint8Array} screenShot
             * @memberof gauge.messages.ProtoHookFailure
             * @instance
             */
            ProtoHookFailure.prototype.screenShot = $util.newBuffer([]);

            /**
             * ProtoHookFailure tableRowIndex.
             * @member {number} tableRowIndex
             * @memberof gauge.messages.ProtoHookFailure
             * @instance
             */
            ProtoHookFailure.prototype.tableRowIndex = 0;

            /**
             * [DEPRECATED, use failureScreenshotFile] Bytes holding the screenshot taken at the time of failure.
             * @member {Uint8Array} failureScreenshot
             * @memberof gauge.messages.ProtoHookFailure
             * @instance
             */
            ProtoHookFailure.prototype.failureScreenshot = $util.newBuffer([]);

            /**
             * Path to the screenshot file captured at the time of failure.
             * @member {string} failureScreenshotFile
             * @memberof gauge.messages.ProtoHookFailure
             * @instance
             */
            ProtoHookFailure.prototype.failureScreenshotFile = "";

            /**
             * Creates a new ProtoHookFailure instance using the specified properties.
             * @function create
             * @memberof gauge.messages.ProtoHookFailure
             * @static
             * @param {gauge.messages.IProtoHookFailure=} [properties] Properties to set
             * @returns {gauge.messages.ProtoHookFailure} ProtoHookFailure instance
             */
            ProtoHookFailure.create = function create(properties) {
                return new ProtoHookFailure(properties);
            };

            /**
             * Encodes the specified ProtoHookFailure message. Does not implicitly {@link gauge.messages.ProtoHookFailure.verify|verify} messages.
             * @function encode
             * @memberof gauge.messages.ProtoHookFailure
             * @static
             * @param {gauge.messages.IProtoHookFailure} message ProtoHookFailure message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ProtoHookFailure.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.stackTrace != null && message.hasOwnProperty("stackTrace"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.stackTrace);
                if (message.errorMessage != null && message.hasOwnProperty("errorMessage"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.errorMessage);
                if (message.screenShot != null && message.hasOwnProperty("screenShot"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.screenShot);
                if (message.tableRowIndex != null && message.hasOwnProperty("tableRowIndex"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.tableRowIndex);
                if (message.failureScreenshot != null && message.hasOwnProperty("failureScreenshot"))
                    writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.failureScreenshot);
                if (message.failureScreenshotFile != null && message.hasOwnProperty("failureScreenshotFile"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.failureScreenshotFile);
                return writer;
            };

            /**
             * Encodes the specified ProtoHookFailure message, length delimited. Does not implicitly {@link gauge.messages.ProtoHookFailure.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gauge.messages.ProtoHookFailure
             * @static
             * @param {gauge.messages.IProtoHookFailure} message ProtoHookFailure message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ProtoHookFailure.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ProtoHookFailure message from the specified reader or buffer.
             * @function decode
             * @memberof gauge.messages.ProtoHookFailure
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gauge.messages.ProtoHookFailure} ProtoHookFailure
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ProtoHookFailure.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gauge.messages.ProtoHookFailure();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.stackTrace = reader.string();
                        break;
                    case 2:
                        message.errorMessage = reader.string();
                        break;
                    case 3:
                        message.screenShot = reader.bytes();
                        break;
                    case 4:
                        message.tableRowIndex = reader.int32();
                        break;
                    case 5:
                        message.failureScreenshot = reader.bytes();
                        break;
                    case 6:
                        message.failureScreenshotFile = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ProtoHookFailure message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gauge.messages.ProtoHookFailure
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gauge.messages.ProtoHookFailure} ProtoHookFailure
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ProtoHookFailure.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ProtoHookFailure message.
             * @function verify
             * @memberof gauge.messages.ProtoHookFailure
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ProtoHookFailure.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.stackTrace != null && message.hasOwnProperty("stackTrace"))
                    if (!$util.isString(message.stackTrace))
                        return "stackTrace: string expected";
                if (message.errorMessage != null && message.hasOwnProperty("errorMessage"))
                    if (!$util.isString(message.errorMessage))
                        return "errorMessage: string expected";
                if (message.screenShot != null && message.hasOwnProperty("screenShot"))
                    if (!(message.screenShot && typeof message.screenShot.length === "number" || $util.isString(message.screenShot)))
                        return "screenShot: buffer expected";
                if (message.tableRowIndex != null && message.hasOwnProperty("tableRowIndex"))
                    if (!$util.isInteger(message.tableRowIndex))
                        return "tableRowIndex: integer expected";
                if (message.failureScreenshot != null && message.hasOwnProperty("failureScreenshot"))
                    if (!(message.failureScreenshot && typeof message.failureScreenshot.length === "number" || $util.isString(message.failureScreenshot)))
                        return "failureScreenshot: buffer expected";
                if (message.failureScreenshotFile != null && message.hasOwnProperty("failureScreenshotFile"))
                    if (!$util.isString(message.failureScreenshotFile))
                        return "failureScreenshotFile: string expected";
                return null;
            };

            /**
             * Creates a ProtoHookFailure message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gauge.messages.ProtoHookFailure
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gauge.messages.ProtoHookFailure} ProtoHookFailure
             */
            ProtoHookFailure.fromObject = function fromObject(object) {
                if (object instanceof $root.gauge.messages.ProtoHookFailure)
                    return object;
                var message = new $root.gauge.messages.ProtoHookFailure();
                if (object.stackTrace != null)
                    message.stackTrace = String(object.stackTrace);
                if (object.errorMessage != null)
                    message.errorMessage = String(object.errorMessage);
                if (object.screenShot != null)
                    if (typeof object.screenShot === "string")
                        $util.base64.decode(object.screenShot, message.screenShot = $util.newBuffer($util.base64.length(object.screenShot)), 0);
                    else if (object.screenShot.length)
                        message.screenShot = object.screenShot;
                if (object.tableRowIndex != null)
                    message.tableRowIndex = object.tableRowIndex | 0;
                if (object.failureScreenshot != null)
                    if (typeof object.failureScreenshot === "string")
                        $util.base64.decode(object.failureScreenshot, message.failureScreenshot = $util.newBuffer($util.base64.length(object.failureScreenshot)), 0);
                    else if (object.failureScreenshot.length)
                        message.failureScreenshot = object.failureScreenshot;
                if (object.failureScreenshotFile != null)
                    message.failureScreenshotFile = String(object.failureScreenshotFile);
                return message;
            };

            /**
             * Creates a plain object from a ProtoHookFailure message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gauge.messages.ProtoHookFailure
             * @static
             * @param {gauge.messages.ProtoHookFailure} message ProtoHookFailure
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ProtoHookFailure.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.stackTrace = "";
                    object.errorMessage = "";
                    if (options.bytes === String)
                        object.screenShot = "";
                    else {
                        object.screenShot = [];
                        if (options.bytes !== Array)
                            object.screenShot = $util.newBuffer(object.screenShot);
                    }
                    object.tableRowIndex = 0;
                    if (options.bytes === String)
                        object.failureScreenshot = "";
                    else {
                        object.failureScreenshot = [];
                        if (options.bytes !== Array)
                            object.failureScreenshot = $util.newBuffer(object.failureScreenshot);
                    }
                    object.failureScreenshotFile = "";
                }
                if (message.stackTrace != null && message.hasOwnProperty("stackTrace"))
                    object.stackTrace = message.stackTrace;
                if (message.errorMessage != null && message.hasOwnProperty("errorMessage"))
                    object.errorMessage = message.errorMessage;
                if (message.screenShot != null && message.hasOwnProperty("screenShot"))
                    object.screenShot = options.bytes === String ? $util.base64.encode(message.screenShot, 0, message.screenShot.length) : options.bytes === Array ? Array.prototype.slice.call(message.screenShot) : message.screenShot;
                if (message.tableRowIndex != null && message.hasOwnProperty("tableRowIndex"))
                    object.tableRowIndex = message.tableRowIndex;
                if (message.failureScreenshot != null && message.hasOwnProperty("failureScreenshot"))
                    object.failureScreenshot = options.bytes === String ? $util.base64.encode(message.failureScreenshot, 0, message.failureScreenshot.length) : options.bytes === Array ? Array.prototype.slice.call(message.failureScreenshot) : message.failureScreenshot;
                if (message.failureScreenshotFile != null && message.hasOwnProperty("failureScreenshotFile"))
                    object.failureScreenshotFile = message.failureScreenshotFile;
                return object;
            };

            /**
             * Converts this ProtoHookFailure to JSON.
             * @function toJSON
             * @memberof gauge.messages.ProtoHookFailure
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ProtoHookFailure.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ProtoHookFailure;
        })();

        messages.ProtoSuiteResult = (function() {

            /**
             * Properties of a ProtoSuiteResult.
             * @memberof gauge.messages
             * @interface IProtoSuiteResult
             * @property {Array.<gauge.messages.IProtoSpecResult>|null} [specResults] Contains the result from the execution
             * @property {gauge.messages.IProtoHookFailure|null} [preHookFailure] Contains a 'before' hook failure message. This happens when the `before_suite` hook has an error
             * @property {gauge.messages.IProtoHookFailure|null} [postHookFailure] Contains a 'after' hook failure message. This happens when the `after_suite` hook has an error
             * @property {boolean|null} [failed] Flag to indicate failure
             * @property {number|null} [specsFailedCount] Holds the count of number of Specifications that failed.
             * @property {number|Long|null} [executionTime] Holds the time taken for executing the whole suite.
             * @property {number|null} [successRate] Holds a metric indicating the success rate of the execution.
             * @property {string|null} [environment] The environment against which execution was done
             * @property {string|null} [tags] Tag expression used for filtering specification
             * @property {string|null} [projectName] Project name
             * @property {string|null} [timestamp] Timestamp of when execution started
             * @property {number|null} [specsSkippedCount] ProtoSuiteResult specsSkippedCount
             * @property {Array.<string>|null} [preHookMessages] Additional information at pre hook exec time to be available on reports
             * @property {Array.<string>|null} [postHookMessages] Additional information at post hook exec time to be available on reports
             * @property {Array.<string>|null} [preHookMessage] [DEPRECATED, use preHookMessages] Additional information at pre hook exec time to be available on reports
             * @property {Array.<string>|null} [postHookMessage] [DEPRECATED, use postHookMessages] Additional information at post hook exec time to be available on reports
             * @property {Array.<Uint8Array>|null} [preHookScreenshots] [DEPRECATED, use preHookScreenshotFiles] Capture Screenshot at pre hook exec time to be available on reports
             * @property {Array.<Uint8Array>|null} [postHookScreenshots] [DEPRECATED, use postHookScreenshotFiles] Capture Screenshot at post hook exec time to be available on reports
             * @property {boolean|null} [chunked] ProtoSuiteResult chunked
             * @property {number|Long|null} [chunkSize] ProtoSuiteResult chunkSize
             * @property {Array.<string>|null} [preHookScreenshotFiles] Screenshots captured on pre hook exec time to be available on reports
             * @property {Array.<string>|null} [postHookScreenshotFiles] Screenshots captured on post hook exec time to be available on reports
             */

            /**
             * Constructs a new ProtoSuiteResult.
             * @memberof gauge.messages
             * @classdesc A proto object representing the result of entire Suite execution.
             * @implements IProtoSuiteResult
             * @constructor
             * @param {gauge.messages.IProtoSuiteResult=} [properties] Properties to set
             */
            function ProtoSuiteResult(properties) {
                this.specResults = [];
                this.preHookMessages = [];
                this.postHookMessages = [];
                this.preHookMessage = [];
                this.postHookMessage = [];
                this.preHookScreenshots = [];
                this.postHookScreenshots = [];
                this.preHookScreenshotFiles = [];
                this.postHookScreenshotFiles = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Contains the result from the execution
             * @member {Array.<gauge.messages.IProtoSpecResult>} specResults
             * @memberof gauge.messages.ProtoSuiteResult
             * @instance
             */
            ProtoSuiteResult.prototype.specResults = $util.emptyArray;

            /**
             * Contains a 'before' hook failure message. This happens when the `before_suite` hook has an error
             * @member {gauge.messages.IProtoHookFailure|null|undefined} preHookFailure
             * @memberof gauge.messages.ProtoSuiteResult
             * @instance
             */
            ProtoSuiteResult.prototype.preHookFailure = null;

            /**
             * Contains a 'after' hook failure message. This happens when the `after_suite` hook has an error
             * @member {gauge.messages.IProtoHookFailure|null|undefined} postHookFailure
             * @memberof gauge.messages.ProtoSuiteResult
             * @instance
             */
            ProtoSuiteResult.prototype.postHookFailure = null;

            /**
             * Flag to indicate failure
             * @member {boolean} failed
             * @memberof gauge.messages.ProtoSuiteResult
             * @instance
             */
            ProtoSuiteResult.prototype.failed = false;

            /**
             * Holds the count of number of Specifications that failed.
             * @member {number} specsFailedCount
             * @memberof gauge.messages.ProtoSuiteResult
             * @instance
             */
            ProtoSuiteResult.prototype.specsFailedCount = 0;

            /**
             * Holds the time taken for executing the whole suite.
             * @member {number|Long} executionTime
             * @memberof gauge.messages.ProtoSuiteResult
             * @instance
             */
            ProtoSuiteResult.prototype.executionTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Holds a metric indicating the success rate of the execution.
             * @member {number} successRate
             * @memberof gauge.messages.ProtoSuiteResult
             * @instance
             */
            ProtoSuiteResult.prototype.successRate = 0;

            /**
             * The environment against which execution was done
             * @member {string} environment
             * @memberof gauge.messages.ProtoSuiteResult
             * @instance
             */
            ProtoSuiteResult.prototype.environment = "";

            /**
             * Tag expression used for filtering specification
             * @member {string} tags
             * @memberof gauge.messages.ProtoSuiteResult
             * @instance
             */
            ProtoSuiteResult.prototype.tags = "";

            /**
             * Project name
             * @member {string} projectName
             * @memberof gauge.messages.ProtoSuiteResult
             * @instance
             */
            ProtoSuiteResult.prototype.projectName = "";

            /**
             * Timestamp of when execution started
             * @member {string} timestamp
             * @memberof gauge.messages.ProtoSuiteResult
             * @instance
             */
            ProtoSuiteResult.prototype.timestamp = "";

            /**
             * ProtoSuiteResult specsSkippedCount.
             * @member {number} specsSkippedCount
             * @memberof gauge.messages.ProtoSuiteResult
             * @instance
             */
            ProtoSuiteResult.prototype.specsSkippedCount = 0;

            /**
             * Additional information at pre hook exec time to be available on reports
             * @member {Array.<string>} preHookMessages
             * @memberof gauge.messages.ProtoSuiteResult
             * @instance
             */
            ProtoSuiteResult.prototype.preHookMessages = $util.emptyArray;

            /**
             * Additional information at post hook exec time to be available on reports
             * @member {Array.<string>} postHookMessages
             * @memberof gauge.messages.ProtoSuiteResult
             * @instance
             */
            ProtoSuiteResult.prototype.postHookMessages = $util.emptyArray;

            /**
             * [DEPRECATED, use preHookMessages] Additional information at pre hook exec time to be available on reports
             * @member {Array.<string>} preHookMessage
             * @memberof gauge.messages.ProtoSuiteResult
             * @instance
             */
            ProtoSuiteResult.prototype.preHookMessage = $util.emptyArray;

            /**
             * [DEPRECATED, use postHookMessages] Additional information at post hook exec time to be available on reports
             * @member {Array.<string>} postHookMessage
             * @memberof gauge.messages.ProtoSuiteResult
             * @instance
             */
            ProtoSuiteResult.prototype.postHookMessage = $util.emptyArray;

            /**
             * [DEPRECATED, use preHookScreenshotFiles] Capture Screenshot at pre hook exec time to be available on reports
             * @member {Array.<Uint8Array>} preHookScreenshots
             * @memberof gauge.messages.ProtoSuiteResult
             * @instance
             */
            ProtoSuiteResult.prototype.preHookScreenshots = $util.emptyArray;

            /**
             * [DEPRECATED, use postHookScreenshotFiles] Capture Screenshot at post hook exec time to be available on reports
             * @member {Array.<Uint8Array>} postHookScreenshots
             * @memberof gauge.messages.ProtoSuiteResult
             * @instance
             */
            ProtoSuiteResult.prototype.postHookScreenshots = $util.emptyArray;

            /**
             * ProtoSuiteResult chunked.
             * @member {boolean} chunked
             * @memberof gauge.messages.ProtoSuiteResult
             * @instance
             */
            ProtoSuiteResult.prototype.chunked = false;

            /**
             * ProtoSuiteResult chunkSize.
             * @member {number|Long} chunkSize
             * @memberof gauge.messages.ProtoSuiteResult
             * @instance
             */
            ProtoSuiteResult.prototype.chunkSize = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Screenshots captured on pre hook exec time to be available on reports
             * @member {Array.<string>} preHookScreenshotFiles
             * @memberof gauge.messages.ProtoSuiteResult
             * @instance
             */
            ProtoSuiteResult.prototype.preHookScreenshotFiles = $util.emptyArray;

            /**
             * Screenshots captured on post hook exec time to be available on reports
             * @member {Array.<string>} postHookScreenshotFiles
             * @memberof gauge.messages.ProtoSuiteResult
             * @instance
             */
            ProtoSuiteResult.prototype.postHookScreenshotFiles = $util.emptyArray;

            /**
             * Creates a new ProtoSuiteResult instance using the specified properties.
             * @function create
             * @memberof gauge.messages.ProtoSuiteResult
             * @static
             * @param {gauge.messages.IProtoSuiteResult=} [properties] Properties to set
             * @returns {gauge.messages.ProtoSuiteResult} ProtoSuiteResult instance
             */
            ProtoSuiteResult.create = function create(properties) {
                return new ProtoSuiteResult(properties);
            };

            /**
             * Encodes the specified ProtoSuiteResult message. Does not implicitly {@link gauge.messages.ProtoSuiteResult.verify|verify} messages.
             * @function encode
             * @memberof gauge.messages.ProtoSuiteResult
             * @static
             * @param {gauge.messages.IProtoSuiteResult} message ProtoSuiteResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ProtoSuiteResult.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.specResults != null && message.specResults.length)
                    for (var i = 0; i < message.specResults.length; ++i)
                        $root.gauge.messages.ProtoSpecResult.encode(message.specResults[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.preHookFailure != null && message.hasOwnProperty("preHookFailure"))
                    $root.gauge.messages.ProtoHookFailure.encode(message.preHookFailure, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.postHookFailure != null && message.hasOwnProperty("postHookFailure"))
                    $root.gauge.messages.ProtoHookFailure.encode(message.postHookFailure, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.failed != null && message.hasOwnProperty("failed"))
                    writer.uint32(/* id 4, wireType 0 =*/32).bool(message.failed);
                if (message.specsFailedCount != null && message.hasOwnProperty("specsFailedCount"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int32(message.specsFailedCount);
                if (message.executionTime != null && message.hasOwnProperty("executionTime"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int64(message.executionTime);
                if (message.successRate != null && message.hasOwnProperty("successRate"))
                    writer.uint32(/* id 7, wireType 5 =*/61).float(message.successRate);
                if (message.environment != null && message.hasOwnProperty("environment"))
                    writer.uint32(/* id 8, wireType 2 =*/66).string(message.environment);
                if (message.tags != null && message.hasOwnProperty("tags"))
                    writer.uint32(/* id 9, wireType 2 =*/74).string(message.tags);
                if (message.projectName != null && message.hasOwnProperty("projectName"))
                    writer.uint32(/* id 10, wireType 2 =*/82).string(message.projectName);
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    writer.uint32(/* id 11, wireType 2 =*/90).string(message.timestamp);
                if (message.specsSkippedCount != null && message.hasOwnProperty("specsSkippedCount"))
                    writer.uint32(/* id 12, wireType 0 =*/96).int32(message.specsSkippedCount);
                if (message.preHookMessages != null && message.preHookMessages.length)
                    for (var i = 0; i < message.preHookMessages.length; ++i)
                        writer.uint32(/* id 13, wireType 2 =*/106).string(message.preHookMessages[i]);
                if (message.postHookMessages != null && message.postHookMessages.length)
                    for (var i = 0; i < message.postHookMessages.length; ++i)
                        writer.uint32(/* id 14, wireType 2 =*/114).string(message.postHookMessages[i]);
                if (message.preHookMessage != null && message.preHookMessage.length)
                    for (var i = 0; i < message.preHookMessage.length; ++i)
                        writer.uint32(/* id 15, wireType 2 =*/122).string(message.preHookMessage[i]);
                if (message.postHookMessage != null && message.postHookMessage.length)
                    for (var i = 0; i < message.postHookMessage.length; ++i)
                        writer.uint32(/* id 16, wireType 2 =*/130).string(message.postHookMessage[i]);
                if (message.preHookScreenshots != null && message.preHookScreenshots.length)
                    for (var i = 0; i < message.preHookScreenshots.length; ++i)
                        writer.uint32(/* id 17, wireType 2 =*/138).bytes(message.preHookScreenshots[i]);
                if (message.postHookScreenshots != null && message.postHookScreenshots.length)
                    for (var i = 0; i < message.postHookScreenshots.length; ++i)
                        writer.uint32(/* id 18, wireType 2 =*/146).bytes(message.postHookScreenshots[i]);
                if (message.chunked != null && message.hasOwnProperty("chunked"))
                    writer.uint32(/* id 19, wireType 0 =*/152).bool(message.chunked);
                if (message.chunkSize != null && message.hasOwnProperty("chunkSize"))
                    writer.uint32(/* id 20, wireType 0 =*/160).int64(message.chunkSize);
                if (message.preHookScreenshotFiles != null && message.preHookScreenshotFiles.length)
                    for (var i = 0; i < message.preHookScreenshotFiles.length; ++i)
                        writer.uint32(/* id 21, wireType 2 =*/170).string(message.preHookScreenshotFiles[i]);
                if (message.postHookScreenshotFiles != null && message.postHookScreenshotFiles.length)
                    for (var i = 0; i < message.postHookScreenshotFiles.length; ++i)
                        writer.uint32(/* id 22, wireType 2 =*/178).string(message.postHookScreenshotFiles[i]);
                return writer;
            };

            /**
             * Encodes the specified ProtoSuiteResult message, length delimited. Does not implicitly {@link gauge.messages.ProtoSuiteResult.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gauge.messages.ProtoSuiteResult
             * @static
             * @param {gauge.messages.IProtoSuiteResult} message ProtoSuiteResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ProtoSuiteResult.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ProtoSuiteResult message from the specified reader or buffer.
             * @function decode
             * @memberof gauge.messages.ProtoSuiteResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gauge.messages.ProtoSuiteResult} ProtoSuiteResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ProtoSuiteResult.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gauge.messages.ProtoSuiteResult();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.specResults && message.specResults.length))
                            message.specResults = [];
                        message.specResults.push($root.gauge.messages.ProtoSpecResult.decode(reader, reader.uint32()));
                        break;
                    case 2:
                        message.preHookFailure = $root.gauge.messages.ProtoHookFailure.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.postHookFailure = $root.gauge.messages.ProtoHookFailure.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.failed = reader.bool();
                        break;
                    case 5:
                        message.specsFailedCount = reader.int32();
                        break;
                    case 6:
                        message.executionTime = reader.int64();
                        break;
                    case 7:
                        message.successRate = reader.float();
                        break;
                    case 8:
                        message.environment = reader.string();
                        break;
                    case 9:
                        message.tags = reader.string();
                        break;
                    case 10:
                        message.projectName = reader.string();
                        break;
                    case 11:
                        message.timestamp = reader.string();
                        break;
                    case 12:
                        message.specsSkippedCount = reader.int32();
                        break;
                    case 13:
                        if (!(message.preHookMessages && message.preHookMessages.length))
                            message.preHookMessages = [];
                        message.preHookMessages.push(reader.string());
                        break;
                    case 14:
                        if (!(message.postHookMessages && message.postHookMessages.length))
                            message.postHookMessages = [];
                        message.postHookMessages.push(reader.string());
                        break;
                    case 15:
                        if (!(message.preHookMessage && message.preHookMessage.length))
                            message.preHookMessage = [];
                        message.preHookMessage.push(reader.string());
                        break;
                    case 16:
                        if (!(message.postHookMessage && message.postHookMessage.length))
                            message.postHookMessage = [];
                        message.postHookMessage.push(reader.string());
                        break;
                    case 17:
                        if (!(message.preHookScreenshots && message.preHookScreenshots.length))
                            message.preHookScreenshots = [];
                        message.preHookScreenshots.push(reader.bytes());
                        break;
                    case 18:
                        if (!(message.postHookScreenshots && message.postHookScreenshots.length))
                            message.postHookScreenshots = [];
                        message.postHookScreenshots.push(reader.bytes());
                        break;
                    case 19:
                        message.chunked = reader.bool();
                        break;
                    case 20:
                        message.chunkSize = reader.int64();
                        break;
                    case 21:
                        if (!(message.preHookScreenshotFiles && message.preHookScreenshotFiles.length))
                            message.preHookScreenshotFiles = [];
                        message.preHookScreenshotFiles.push(reader.string());
                        break;
                    case 22:
                        if (!(message.postHookScreenshotFiles && message.postHookScreenshotFiles.length))
                            message.postHookScreenshotFiles = [];
                        message.postHookScreenshotFiles.push(reader.string());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ProtoSuiteResult message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gauge.messages.ProtoSuiteResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gauge.messages.ProtoSuiteResult} ProtoSuiteResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ProtoSuiteResult.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ProtoSuiteResult message.
             * @function verify
             * @memberof gauge.messages.ProtoSuiteResult
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ProtoSuiteResult.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.specResults != null && message.hasOwnProperty("specResults")) {
                    if (!Array.isArray(message.specResults))
                        return "specResults: array expected";
                    for (var i = 0; i < message.specResults.length; ++i) {
                        var error = $root.gauge.messages.ProtoSpecResult.verify(message.specResults[i]);
                        if (error)
                            return "specResults." + error;
                    }
                }
                if (message.preHookFailure != null && message.hasOwnProperty("preHookFailure")) {
                    var error = $root.gauge.messages.ProtoHookFailure.verify(message.preHookFailure);
                    if (error)
                        return "preHookFailure." + error;
                }
                if (message.postHookFailure != null && message.hasOwnProperty("postHookFailure")) {
                    var error = $root.gauge.messages.ProtoHookFailure.verify(message.postHookFailure);
                    if (error)
                        return "postHookFailure." + error;
                }
                if (message.failed != null && message.hasOwnProperty("failed"))
                    if (typeof message.failed !== "boolean")
                        return "failed: boolean expected";
                if (message.specsFailedCount != null && message.hasOwnProperty("specsFailedCount"))
                    if (!$util.isInteger(message.specsFailedCount))
                        return "specsFailedCount: integer expected";
                if (message.executionTime != null && message.hasOwnProperty("executionTime"))
                    if (!$util.isInteger(message.executionTime) && !(message.executionTime && $util.isInteger(message.executionTime.low) && $util.isInteger(message.executionTime.high)))
                        return "executionTime: integer|Long expected";
                if (message.successRate != null && message.hasOwnProperty("successRate"))
                    if (typeof message.successRate !== "number")
                        return "successRate: number expected";
                if (message.environment != null && message.hasOwnProperty("environment"))
                    if (!$util.isString(message.environment))
                        return "environment: string expected";
                if (message.tags != null && message.hasOwnProperty("tags"))
                    if (!$util.isString(message.tags))
                        return "tags: string expected";
                if (message.projectName != null && message.hasOwnProperty("projectName"))
                    if (!$util.isString(message.projectName))
                        return "projectName: string expected";
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    if (!$util.isString(message.timestamp))
                        return "timestamp: string expected";
                if (message.specsSkippedCount != null && message.hasOwnProperty("specsSkippedCount"))
                    if (!$util.isInteger(message.specsSkippedCount))
                        return "specsSkippedCount: integer expected";
                if (message.preHookMessages != null && message.hasOwnProperty("preHookMessages")) {
                    if (!Array.isArray(message.preHookMessages))
                        return "preHookMessages: array expected";
                    for (var i = 0; i < message.preHookMessages.length; ++i)
                        if (!$util.isString(message.preHookMessages[i]))
                            return "preHookMessages: string[] expected";
                }
                if (message.postHookMessages != null && message.hasOwnProperty("postHookMessages")) {
                    if (!Array.isArray(message.postHookMessages))
                        return "postHookMessages: array expected";
                    for (var i = 0; i < message.postHookMessages.length; ++i)
                        if (!$util.isString(message.postHookMessages[i]))
                            return "postHookMessages: string[] expected";
                }
                if (message.preHookMessage != null && message.hasOwnProperty("preHookMessage")) {
                    if (!Array.isArray(message.preHookMessage))
                        return "preHookMessage: array expected";
                    for (var i = 0; i < message.preHookMessage.length; ++i)
                        if (!$util.isString(message.preHookMessage[i]))
                            return "preHookMessage: string[] expected";
                }
                if (message.postHookMessage != null && message.hasOwnProperty("postHookMessage")) {
                    if (!Array.isArray(message.postHookMessage))
                        return "postHookMessage: array expected";
                    for (var i = 0; i < message.postHookMessage.length; ++i)
                        if (!$util.isString(message.postHookMessage[i]))
                            return "postHookMessage: string[] expected";
                }
                if (message.preHookScreenshots != null && message.hasOwnProperty("preHookScreenshots")) {
                    if (!Array.isArray(message.preHookScreenshots))
                        return "preHookScreenshots: array expected";
                    for (var i = 0; i < message.preHookScreenshots.length; ++i)
                        if (!(message.preHookScreenshots[i] && typeof message.preHookScreenshots[i].length === "number" || $util.isString(message.preHookScreenshots[i])))
                            return "preHookScreenshots: buffer[] expected";
                }
                if (message.postHookScreenshots != null && message.hasOwnProperty("postHookScreenshots")) {
                    if (!Array.isArray(message.postHookScreenshots))
                        return "postHookScreenshots: array expected";
                    for (var i = 0; i < message.postHookScreenshots.length; ++i)
                        if (!(message.postHookScreenshots[i] && typeof message.postHookScreenshots[i].length === "number" || $util.isString(message.postHookScreenshots[i])))
                            return "postHookScreenshots: buffer[] expected";
                }
                if (message.chunked != null && message.hasOwnProperty("chunked"))
                    if (typeof message.chunked !== "boolean")
                        return "chunked: boolean expected";
                if (message.chunkSize != null && message.hasOwnProperty("chunkSize"))
                    if (!$util.isInteger(message.chunkSize) && !(message.chunkSize && $util.isInteger(message.chunkSize.low) && $util.isInteger(message.chunkSize.high)))
                        return "chunkSize: integer|Long expected";
                if (message.preHookScreenshotFiles != null && message.hasOwnProperty("preHookScreenshotFiles")) {
                    if (!Array.isArray(message.preHookScreenshotFiles))
                        return "preHookScreenshotFiles: array expected";
                    for (var i = 0; i < message.preHookScreenshotFiles.length; ++i)
                        if (!$util.isString(message.preHookScreenshotFiles[i]))
                            return "preHookScreenshotFiles: string[] expected";
                }
                if (message.postHookScreenshotFiles != null && message.hasOwnProperty("postHookScreenshotFiles")) {
                    if (!Array.isArray(message.postHookScreenshotFiles))
                        return "postHookScreenshotFiles: array expected";
                    for (var i = 0; i < message.postHookScreenshotFiles.length; ++i)
                        if (!$util.isString(message.postHookScreenshotFiles[i]))
                            return "postHookScreenshotFiles: string[] expected";
                }
                return null;
            };

            /**
             * Creates a ProtoSuiteResult message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gauge.messages.ProtoSuiteResult
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gauge.messages.ProtoSuiteResult} ProtoSuiteResult
             */
            ProtoSuiteResult.fromObject = function fromObject(object) {
                if (object instanceof $root.gauge.messages.ProtoSuiteResult)
                    return object;
                var message = new $root.gauge.messages.ProtoSuiteResult();
                if (object.specResults) {
                    if (!Array.isArray(object.specResults))
                        throw TypeError(".gauge.messages.ProtoSuiteResult.specResults: array expected");
                    message.specResults = [];
                    for (var i = 0; i < object.specResults.length; ++i) {
                        if (typeof object.specResults[i] !== "object")
                            throw TypeError(".gauge.messages.ProtoSuiteResult.specResults: object expected");
                        message.specResults[i] = $root.gauge.messages.ProtoSpecResult.fromObject(object.specResults[i]);
                    }
                }
                if (object.preHookFailure != null) {
                    if (typeof object.preHookFailure !== "object")
                        throw TypeError(".gauge.messages.ProtoSuiteResult.preHookFailure: object expected");
                    message.preHookFailure = $root.gauge.messages.ProtoHookFailure.fromObject(object.preHookFailure);
                }
                if (object.postHookFailure != null) {
                    if (typeof object.postHookFailure !== "object")
                        throw TypeError(".gauge.messages.ProtoSuiteResult.postHookFailure: object expected");
                    message.postHookFailure = $root.gauge.messages.ProtoHookFailure.fromObject(object.postHookFailure);
                }
                if (object.failed != null)
                    message.failed = Boolean(object.failed);
                if (object.specsFailedCount != null)
                    message.specsFailedCount = object.specsFailedCount | 0;
                if (object.executionTime != null)
                    if ($util.Long)
                        (message.executionTime = $util.Long.fromValue(object.executionTime)).unsigned = false;
                    else if (typeof object.executionTime === "string")
                        message.executionTime = parseInt(object.executionTime, 10);
                    else if (typeof object.executionTime === "number")
                        message.executionTime = object.executionTime;
                    else if (typeof object.executionTime === "object")
                        message.executionTime = new $util.LongBits(object.executionTime.low >>> 0, object.executionTime.high >>> 0).toNumber();
                if (object.successRate != null)
                    message.successRate = Number(object.successRate);
                if (object.environment != null)
                    message.environment = String(object.environment);
                if (object.tags != null)
                    message.tags = String(object.tags);
                if (object.projectName != null)
                    message.projectName = String(object.projectName);
                if (object.timestamp != null)
                    message.timestamp = String(object.timestamp);
                if (object.specsSkippedCount != null)
                    message.specsSkippedCount = object.specsSkippedCount | 0;
                if (object.preHookMessages) {
                    if (!Array.isArray(object.preHookMessages))
                        throw TypeError(".gauge.messages.ProtoSuiteResult.preHookMessages: array expected");
                    message.preHookMessages = [];
                    for (var i = 0; i < object.preHookMessages.length; ++i)
                        message.preHookMessages[i] = String(object.preHookMessages[i]);
                }
                if (object.postHookMessages) {
                    if (!Array.isArray(object.postHookMessages))
                        throw TypeError(".gauge.messages.ProtoSuiteResult.postHookMessages: array expected");
                    message.postHookMessages = [];
                    for (var i = 0; i < object.postHookMessages.length; ++i)
                        message.postHookMessages[i] = String(object.postHookMessages[i]);
                }
                if (object.preHookMessage) {
                    if (!Array.isArray(object.preHookMessage))
                        throw TypeError(".gauge.messages.ProtoSuiteResult.preHookMessage: array expected");
                    message.preHookMessage = [];
                    for (var i = 0; i < object.preHookMessage.length; ++i)
                        message.preHookMessage[i] = String(object.preHookMessage[i]);
                }
                if (object.postHookMessage) {
                    if (!Array.isArray(object.postHookMessage))
                        throw TypeError(".gauge.messages.ProtoSuiteResult.postHookMessage: array expected");
                    message.postHookMessage = [];
                    for (var i = 0; i < object.postHookMessage.length; ++i)
                        message.postHookMessage[i] = String(object.postHookMessage[i]);
                }
                if (object.preHookScreenshots) {
                    if (!Array.isArray(object.preHookScreenshots))
                        throw TypeError(".gauge.messages.ProtoSuiteResult.preHookScreenshots: array expected");
                    message.preHookScreenshots = [];
                    for (var i = 0; i < object.preHookScreenshots.length; ++i)
                        if (typeof object.preHookScreenshots[i] === "string")
                            $util.base64.decode(object.preHookScreenshots[i], message.preHookScreenshots[i] = $util.newBuffer($util.base64.length(object.preHookScreenshots[i])), 0);
                        else if (object.preHookScreenshots[i].length)
                            message.preHookScreenshots[i] = object.preHookScreenshots[i];
                }
                if (object.postHookScreenshots) {
                    if (!Array.isArray(object.postHookScreenshots))
                        throw TypeError(".gauge.messages.ProtoSuiteResult.postHookScreenshots: array expected");
                    message.postHookScreenshots = [];
                    for (var i = 0; i < object.postHookScreenshots.length; ++i)
                        if (typeof object.postHookScreenshots[i] === "string")
                            $util.base64.decode(object.postHookScreenshots[i], message.postHookScreenshots[i] = $util.newBuffer($util.base64.length(object.postHookScreenshots[i])), 0);
                        else if (object.postHookScreenshots[i].length)
                            message.postHookScreenshots[i] = object.postHookScreenshots[i];
                }
                if (object.chunked != null)
                    message.chunked = Boolean(object.chunked);
                if (object.chunkSize != null)
                    if ($util.Long)
                        (message.chunkSize = $util.Long.fromValue(object.chunkSize)).unsigned = false;
                    else if (typeof object.chunkSize === "string")
                        message.chunkSize = parseInt(object.chunkSize, 10);
                    else if (typeof object.chunkSize === "number")
                        message.chunkSize = object.chunkSize;
                    else if (typeof object.chunkSize === "object")
                        message.chunkSize = new $util.LongBits(object.chunkSize.low >>> 0, object.chunkSize.high >>> 0).toNumber();
                if (object.preHookScreenshotFiles) {
                    if (!Array.isArray(object.preHookScreenshotFiles))
                        throw TypeError(".gauge.messages.ProtoSuiteResult.preHookScreenshotFiles: array expected");
                    message.preHookScreenshotFiles = [];
                    for (var i = 0; i < object.preHookScreenshotFiles.length; ++i)
                        message.preHookScreenshotFiles[i] = String(object.preHookScreenshotFiles[i]);
                }
                if (object.postHookScreenshotFiles) {
                    if (!Array.isArray(object.postHookScreenshotFiles))
                        throw TypeError(".gauge.messages.ProtoSuiteResult.postHookScreenshotFiles: array expected");
                    message.postHookScreenshotFiles = [];
                    for (var i = 0; i < object.postHookScreenshotFiles.length; ++i)
                        message.postHookScreenshotFiles[i] = String(object.postHookScreenshotFiles[i]);
                }
                return message;
            };

            /**
             * Creates a plain object from a ProtoSuiteResult message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gauge.messages.ProtoSuiteResult
             * @static
             * @param {gauge.messages.ProtoSuiteResult} message ProtoSuiteResult
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ProtoSuiteResult.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults) {
                    object.specResults = [];
                    object.preHookMessages = [];
                    object.postHookMessages = [];
                    object.preHookMessage = [];
                    object.postHookMessage = [];
                    object.preHookScreenshots = [];
                    object.postHookScreenshots = [];
                    object.preHookScreenshotFiles = [];
                    object.postHookScreenshotFiles = [];
                }
                if (options.defaults) {
                    object.preHookFailure = null;
                    object.postHookFailure = null;
                    object.failed = false;
                    object.specsFailedCount = 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.executionTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.executionTime = options.longs === String ? "0" : 0;
                    object.successRate = 0;
                    object.environment = "";
                    object.tags = "";
                    object.projectName = "";
                    object.timestamp = "";
                    object.specsSkippedCount = 0;
                    object.chunked = false;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.chunkSize = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.chunkSize = options.longs === String ? "0" : 0;
                }
                if (message.specResults && message.specResults.length) {
                    object.specResults = [];
                    for (var j = 0; j < message.specResults.length; ++j)
                        object.specResults[j] = $root.gauge.messages.ProtoSpecResult.toObject(message.specResults[j], options);
                }
                if (message.preHookFailure != null && message.hasOwnProperty("preHookFailure"))
                    object.preHookFailure = $root.gauge.messages.ProtoHookFailure.toObject(message.preHookFailure, options);
                if (message.postHookFailure != null && message.hasOwnProperty("postHookFailure"))
                    object.postHookFailure = $root.gauge.messages.ProtoHookFailure.toObject(message.postHookFailure, options);
                if (message.failed != null && message.hasOwnProperty("failed"))
                    object.failed = message.failed;
                if (message.specsFailedCount != null && message.hasOwnProperty("specsFailedCount"))
                    object.specsFailedCount = message.specsFailedCount;
                if (message.executionTime != null && message.hasOwnProperty("executionTime"))
                    if (typeof message.executionTime === "number")
                        object.executionTime = options.longs === String ? String(message.executionTime) : message.executionTime;
                    else
                        object.executionTime = options.longs === String ? $util.Long.prototype.toString.call(message.executionTime) : options.longs === Number ? new $util.LongBits(message.executionTime.low >>> 0, message.executionTime.high >>> 0).toNumber() : message.executionTime;
                if (message.successRate != null && message.hasOwnProperty("successRate"))
                    object.successRate = options.json && !isFinite(message.successRate) ? String(message.successRate) : message.successRate;
                if (message.environment != null && message.hasOwnProperty("environment"))
                    object.environment = message.environment;
                if (message.tags != null && message.hasOwnProperty("tags"))
                    object.tags = message.tags;
                if (message.projectName != null && message.hasOwnProperty("projectName"))
                    object.projectName = message.projectName;
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    object.timestamp = message.timestamp;
                if (message.specsSkippedCount != null && message.hasOwnProperty("specsSkippedCount"))
                    object.specsSkippedCount = message.specsSkippedCount;
                if (message.preHookMessages && message.preHookMessages.length) {
                    object.preHookMessages = [];
                    for (var j = 0; j < message.preHookMessages.length; ++j)
                        object.preHookMessages[j] = message.preHookMessages[j];
                }
                if (message.postHookMessages && message.postHookMessages.length) {
                    object.postHookMessages = [];
                    for (var j = 0; j < message.postHookMessages.length; ++j)
                        object.postHookMessages[j] = message.postHookMessages[j];
                }
                if (message.preHookMessage && message.preHookMessage.length) {
                    object.preHookMessage = [];
                    for (var j = 0; j < message.preHookMessage.length; ++j)
                        object.preHookMessage[j] = message.preHookMessage[j];
                }
                if (message.postHookMessage && message.postHookMessage.length) {
                    object.postHookMessage = [];
                    for (var j = 0; j < message.postHookMessage.length; ++j)
                        object.postHookMessage[j] = message.postHookMessage[j];
                }
                if (message.preHookScreenshots && message.preHookScreenshots.length) {
                    object.preHookScreenshots = [];
                    for (var j = 0; j < message.preHookScreenshots.length; ++j)
                        object.preHookScreenshots[j] = options.bytes === String ? $util.base64.encode(message.preHookScreenshots[j], 0, message.preHookScreenshots[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.preHookScreenshots[j]) : message.preHookScreenshots[j];
                }
                if (message.postHookScreenshots && message.postHookScreenshots.length) {
                    object.postHookScreenshots = [];
                    for (var j = 0; j < message.postHookScreenshots.length; ++j)
                        object.postHookScreenshots[j] = options.bytes === String ? $util.base64.encode(message.postHookScreenshots[j], 0, message.postHookScreenshots[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.postHookScreenshots[j]) : message.postHookScreenshots[j];
                }
                if (message.chunked != null && message.hasOwnProperty("chunked"))
                    object.chunked = message.chunked;
                if (message.chunkSize != null && message.hasOwnProperty("chunkSize"))
                    if (typeof message.chunkSize === "number")
                        object.chunkSize = options.longs === String ? String(message.chunkSize) : message.chunkSize;
                    else
                        object.chunkSize = options.longs === String ? $util.Long.prototype.toString.call(message.chunkSize) : options.longs === Number ? new $util.LongBits(message.chunkSize.low >>> 0, message.chunkSize.high >>> 0).toNumber() : message.chunkSize;
                if (message.preHookScreenshotFiles && message.preHookScreenshotFiles.length) {
                    object.preHookScreenshotFiles = [];
                    for (var j = 0; j < message.preHookScreenshotFiles.length; ++j)
                        object.preHookScreenshotFiles[j] = message.preHookScreenshotFiles[j];
                }
                if (message.postHookScreenshotFiles && message.postHookScreenshotFiles.length) {
                    object.postHookScreenshotFiles = [];
                    for (var j = 0; j < message.postHookScreenshotFiles.length; ++j)
                        object.postHookScreenshotFiles[j] = message.postHookScreenshotFiles[j];
                }
                return object;
            };

            /**
             * Converts this ProtoSuiteResult to JSON.
             * @function toJSON
             * @memberof gauge.messages.ProtoSuiteResult
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ProtoSuiteResult.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ProtoSuiteResult;
        })();

        messages.ProtoSpecResult = (function() {

            /**
             * Properties of a ProtoSpecResult.
             * @memberof gauge.messages
             * @interface IProtoSpecResult
             * @property {gauge.messages.IProtoSpec|null} [protoSpec] Represents the corresponding Specification
             * @property {number|null} [scenarioCount] Holds the number of Scenarios executed
             * @property {number|null} [scenarioFailedCount] Holds the number of Scenarios failed
             * @property {boolean|null} [failed] Flag to indicate failure
             * @property {Array.<number>|null} [failedDataTableRows] Holds the row numbers, which caused the execution to fail.
             * @property {number|Long|null} [executionTime] Holds the time taken for executing the spec.
             * @property {boolean|null} [skipped] Flag to indicate if spec is skipped
             * @property {number|null} [scenarioSkippedCount] Holds the number of Scenarios skipped
             * @property {Array.<number>|null} [skippedDataTableRows] Holds the row numbers, for which the execution skipped.
             * @property {Array.<gauge.messages.IError>|null} [errors] Holds parse, validation and skipped errors.
             * @property {string|null} [timestamp] Holds the timestamp of event starting.
             */

            /**
             * Constructs a new ProtoSpecResult.
             * @memberof gauge.messages
             * @classdesc A proto object representing the result of Spec execution.
             * @implements IProtoSpecResult
             * @constructor
             * @param {gauge.messages.IProtoSpecResult=} [properties] Properties to set
             */
            function ProtoSpecResult(properties) {
                this.failedDataTableRows = [];
                this.skippedDataTableRows = [];
                this.errors = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Represents the corresponding Specification
             * @member {gauge.messages.IProtoSpec|null|undefined} protoSpec
             * @memberof gauge.messages.ProtoSpecResult
             * @instance
             */
            ProtoSpecResult.prototype.protoSpec = null;

            /**
             * Holds the number of Scenarios executed
             * @member {number} scenarioCount
             * @memberof gauge.messages.ProtoSpecResult
             * @instance
             */
            ProtoSpecResult.prototype.scenarioCount = 0;

            /**
             * Holds the number of Scenarios failed
             * @member {number} scenarioFailedCount
             * @memberof gauge.messages.ProtoSpecResult
             * @instance
             */
            ProtoSpecResult.prototype.scenarioFailedCount = 0;

            /**
             * Flag to indicate failure
             * @member {boolean} failed
             * @memberof gauge.messages.ProtoSpecResult
             * @instance
             */
            ProtoSpecResult.prototype.failed = false;

            /**
             * Holds the row numbers, which caused the execution to fail.
             * @member {Array.<number>} failedDataTableRows
             * @memberof gauge.messages.ProtoSpecResult
             * @instance
             */
            ProtoSpecResult.prototype.failedDataTableRows = $util.emptyArray;

            /**
             * Holds the time taken for executing the spec.
             * @member {number|Long} executionTime
             * @memberof gauge.messages.ProtoSpecResult
             * @instance
             */
            ProtoSpecResult.prototype.executionTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Flag to indicate if spec is skipped
             * @member {boolean} skipped
             * @memberof gauge.messages.ProtoSpecResult
             * @instance
             */
            ProtoSpecResult.prototype.skipped = false;

            /**
             * Holds the number of Scenarios skipped
             * @member {number} scenarioSkippedCount
             * @memberof gauge.messages.ProtoSpecResult
             * @instance
             */
            ProtoSpecResult.prototype.scenarioSkippedCount = 0;

            /**
             * Holds the row numbers, for which the execution skipped.
             * @member {Array.<number>} skippedDataTableRows
             * @memberof gauge.messages.ProtoSpecResult
             * @instance
             */
            ProtoSpecResult.prototype.skippedDataTableRows = $util.emptyArray;

            /**
             * Holds parse, validation and skipped errors.
             * @member {Array.<gauge.messages.IError>} errors
             * @memberof gauge.messages.ProtoSpecResult
             * @instance
             */
            ProtoSpecResult.prototype.errors = $util.emptyArray;

            /**
             * Holds the timestamp of event starting.
             * @member {string} timestamp
             * @memberof gauge.messages.ProtoSpecResult
             * @instance
             */
            ProtoSpecResult.prototype.timestamp = "";

            /**
             * Creates a new ProtoSpecResult instance using the specified properties.
             * @function create
             * @memberof gauge.messages.ProtoSpecResult
             * @static
             * @param {gauge.messages.IProtoSpecResult=} [properties] Properties to set
             * @returns {gauge.messages.ProtoSpecResult} ProtoSpecResult instance
             */
            ProtoSpecResult.create = function create(properties) {
                return new ProtoSpecResult(properties);
            };

            /**
             * Encodes the specified ProtoSpecResult message. Does not implicitly {@link gauge.messages.ProtoSpecResult.verify|verify} messages.
             * @function encode
             * @memberof gauge.messages.ProtoSpecResult
             * @static
             * @param {gauge.messages.IProtoSpecResult} message ProtoSpecResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ProtoSpecResult.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.protoSpec != null && message.hasOwnProperty("protoSpec"))
                    $root.gauge.messages.ProtoSpec.encode(message.protoSpec, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.scenarioCount != null && message.hasOwnProperty("scenarioCount"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.scenarioCount);
                if (message.scenarioFailedCount != null && message.hasOwnProperty("scenarioFailedCount"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.scenarioFailedCount);
                if (message.failed != null && message.hasOwnProperty("failed"))
                    writer.uint32(/* id 4, wireType 0 =*/32).bool(message.failed);
                if (message.failedDataTableRows != null && message.failedDataTableRows.length) {
                    writer.uint32(/* id 5, wireType 2 =*/42).fork();
                    for (var i = 0; i < message.failedDataTableRows.length; ++i)
                        writer.int32(message.failedDataTableRows[i]);
                    writer.ldelim();
                }
                if (message.executionTime != null && message.hasOwnProperty("executionTime"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int64(message.executionTime);
                if (message.skipped != null && message.hasOwnProperty("skipped"))
                    writer.uint32(/* id 7, wireType 0 =*/56).bool(message.skipped);
                if (message.scenarioSkippedCount != null && message.hasOwnProperty("scenarioSkippedCount"))
                    writer.uint32(/* id 8, wireType 0 =*/64).int32(message.scenarioSkippedCount);
                if (message.skippedDataTableRows != null && message.skippedDataTableRows.length) {
                    writer.uint32(/* id 9, wireType 2 =*/74).fork();
                    for (var i = 0; i < message.skippedDataTableRows.length; ++i)
                        writer.int32(message.skippedDataTableRows[i]);
                    writer.ldelim();
                }
                if (message.errors != null && message.errors.length)
                    for (var i = 0; i < message.errors.length; ++i)
                        $root.gauge.messages.Error.encode(message.errors[i], writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    writer.uint32(/* id 11, wireType 2 =*/90).string(message.timestamp);
                return writer;
            };

            /**
             * Encodes the specified ProtoSpecResult message, length delimited. Does not implicitly {@link gauge.messages.ProtoSpecResult.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gauge.messages.ProtoSpecResult
             * @static
             * @param {gauge.messages.IProtoSpecResult} message ProtoSpecResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ProtoSpecResult.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ProtoSpecResult message from the specified reader or buffer.
             * @function decode
             * @memberof gauge.messages.ProtoSpecResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gauge.messages.ProtoSpecResult} ProtoSpecResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ProtoSpecResult.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gauge.messages.ProtoSpecResult();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.protoSpec = $root.gauge.messages.ProtoSpec.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.scenarioCount = reader.int32();
                        break;
                    case 3:
                        message.scenarioFailedCount = reader.int32();
                        break;
                    case 4:
                        message.failed = reader.bool();
                        break;
                    case 5:
                        if (!(message.failedDataTableRows && message.failedDataTableRows.length))
                            message.failedDataTableRows = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.failedDataTableRows.push(reader.int32());
                        } else
                            message.failedDataTableRows.push(reader.int32());
                        break;
                    case 6:
                        message.executionTime = reader.int64();
                        break;
                    case 7:
                        message.skipped = reader.bool();
                        break;
                    case 8:
                        message.scenarioSkippedCount = reader.int32();
                        break;
                    case 9:
                        if (!(message.skippedDataTableRows && message.skippedDataTableRows.length))
                            message.skippedDataTableRows = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.skippedDataTableRows.push(reader.int32());
                        } else
                            message.skippedDataTableRows.push(reader.int32());
                        break;
                    case 10:
                        if (!(message.errors && message.errors.length))
                            message.errors = [];
                        message.errors.push($root.gauge.messages.Error.decode(reader, reader.uint32()));
                        break;
                    case 11:
                        message.timestamp = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ProtoSpecResult message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gauge.messages.ProtoSpecResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gauge.messages.ProtoSpecResult} ProtoSpecResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ProtoSpecResult.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ProtoSpecResult message.
             * @function verify
             * @memberof gauge.messages.ProtoSpecResult
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ProtoSpecResult.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.protoSpec != null && message.hasOwnProperty("protoSpec")) {
                    var error = $root.gauge.messages.ProtoSpec.verify(message.protoSpec);
                    if (error)
                        return "protoSpec." + error;
                }
                if (message.scenarioCount != null && message.hasOwnProperty("scenarioCount"))
                    if (!$util.isInteger(message.scenarioCount))
                        return "scenarioCount: integer expected";
                if (message.scenarioFailedCount != null && message.hasOwnProperty("scenarioFailedCount"))
                    if (!$util.isInteger(message.scenarioFailedCount))
                        return "scenarioFailedCount: integer expected";
                if (message.failed != null && message.hasOwnProperty("failed"))
                    if (typeof message.failed !== "boolean")
                        return "failed: boolean expected";
                if (message.failedDataTableRows != null && message.hasOwnProperty("failedDataTableRows")) {
                    if (!Array.isArray(message.failedDataTableRows))
                        return "failedDataTableRows: array expected";
                    for (var i = 0; i < message.failedDataTableRows.length; ++i)
                        if (!$util.isInteger(message.failedDataTableRows[i]))
                            return "failedDataTableRows: integer[] expected";
                }
                if (message.executionTime != null && message.hasOwnProperty("executionTime"))
                    if (!$util.isInteger(message.executionTime) && !(message.executionTime && $util.isInteger(message.executionTime.low) && $util.isInteger(message.executionTime.high)))
                        return "executionTime: integer|Long expected";
                if (message.skipped != null && message.hasOwnProperty("skipped"))
                    if (typeof message.skipped !== "boolean")
                        return "skipped: boolean expected";
                if (message.scenarioSkippedCount != null && message.hasOwnProperty("scenarioSkippedCount"))
                    if (!$util.isInteger(message.scenarioSkippedCount))
                        return "scenarioSkippedCount: integer expected";
                if (message.skippedDataTableRows != null && message.hasOwnProperty("skippedDataTableRows")) {
                    if (!Array.isArray(message.skippedDataTableRows))
                        return "skippedDataTableRows: array expected";
                    for (var i = 0; i < message.skippedDataTableRows.length; ++i)
                        if (!$util.isInteger(message.skippedDataTableRows[i]))
                            return "skippedDataTableRows: integer[] expected";
                }
                if (message.errors != null && message.hasOwnProperty("errors")) {
                    if (!Array.isArray(message.errors))
                        return "errors: array expected";
                    for (var i = 0; i < message.errors.length; ++i) {
                        var error = $root.gauge.messages.Error.verify(message.errors[i]);
                        if (error)
                            return "errors." + error;
                    }
                }
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    if (!$util.isString(message.timestamp))
                        return "timestamp: string expected";
                return null;
            };

            /**
             * Creates a ProtoSpecResult message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gauge.messages.ProtoSpecResult
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gauge.messages.ProtoSpecResult} ProtoSpecResult
             */
            ProtoSpecResult.fromObject = function fromObject(object) {
                if (object instanceof $root.gauge.messages.ProtoSpecResult)
                    return object;
                var message = new $root.gauge.messages.ProtoSpecResult();
                if (object.protoSpec != null) {
                    if (typeof object.protoSpec !== "object")
                        throw TypeError(".gauge.messages.ProtoSpecResult.protoSpec: object expected");
                    message.protoSpec = $root.gauge.messages.ProtoSpec.fromObject(object.protoSpec);
                }
                if (object.scenarioCount != null)
                    message.scenarioCount = object.scenarioCount | 0;
                if (object.scenarioFailedCount != null)
                    message.scenarioFailedCount = object.scenarioFailedCount | 0;
                if (object.failed != null)
                    message.failed = Boolean(object.failed);
                if (object.failedDataTableRows) {
                    if (!Array.isArray(object.failedDataTableRows))
                        throw TypeError(".gauge.messages.ProtoSpecResult.failedDataTableRows: array expected");
                    message.failedDataTableRows = [];
                    for (var i = 0; i < object.failedDataTableRows.length; ++i)
                        message.failedDataTableRows[i] = object.failedDataTableRows[i] | 0;
                }
                if (object.executionTime != null)
                    if ($util.Long)
                        (message.executionTime = $util.Long.fromValue(object.executionTime)).unsigned = false;
                    else if (typeof object.executionTime === "string")
                        message.executionTime = parseInt(object.executionTime, 10);
                    else if (typeof object.executionTime === "number")
                        message.executionTime = object.executionTime;
                    else if (typeof object.executionTime === "object")
                        message.executionTime = new $util.LongBits(object.executionTime.low >>> 0, object.executionTime.high >>> 0).toNumber();
                if (object.skipped != null)
                    message.skipped = Boolean(object.skipped);
                if (object.scenarioSkippedCount != null)
                    message.scenarioSkippedCount = object.scenarioSkippedCount | 0;
                if (object.skippedDataTableRows) {
                    if (!Array.isArray(object.skippedDataTableRows))
                        throw TypeError(".gauge.messages.ProtoSpecResult.skippedDataTableRows: array expected");
                    message.skippedDataTableRows = [];
                    for (var i = 0; i < object.skippedDataTableRows.length; ++i)
                        message.skippedDataTableRows[i] = object.skippedDataTableRows[i] | 0;
                }
                if (object.errors) {
                    if (!Array.isArray(object.errors))
                        throw TypeError(".gauge.messages.ProtoSpecResult.errors: array expected");
                    message.errors = [];
                    for (var i = 0; i < object.errors.length; ++i) {
                        if (typeof object.errors[i] !== "object")
                            throw TypeError(".gauge.messages.ProtoSpecResult.errors: object expected");
                        message.errors[i] = $root.gauge.messages.Error.fromObject(object.errors[i]);
                    }
                }
                if (object.timestamp != null)
                    message.timestamp = String(object.timestamp);
                return message;
            };

            /**
             * Creates a plain object from a ProtoSpecResult message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gauge.messages.ProtoSpecResult
             * @static
             * @param {gauge.messages.ProtoSpecResult} message ProtoSpecResult
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ProtoSpecResult.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults) {
                    object.failedDataTableRows = [];
                    object.skippedDataTableRows = [];
                    object.errors = [];
                }
                if (options.defaults) {
                    object.protoSpec = null;
                    object.scenarioCount = 0;
                    object.scenarioFailedCount = 0;
                    object.failed = false;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.executionTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.executionTime = options.longs === String ? "0" : 0;
                    object.skipped = false;
                    object.scenarioSkippedCount = 0;
                    object.timestamp = "";
                }
                if (message.protoSpec != null && message.hasOwnProperty("protoSpec"))
                    object.protoSpec = $root.gauge.messages.ProtoSpec.toObject(message.protoSpec, options);
                if (message.scenarioCount != null && message.hasOwnProperty("scenarioCount"))
                    object.scenarioCount = message.scenarioCount;
                if (message.scenarioFailedCount != null && message.hasOwnProperty("scenarioFailedCount"))
                    object.scenarioFailedCount = message.scenarioFailedCount;
                if (message.failed != null && message.hasOwnProperty("failed"))
                    object.failed = message.failed;
                if (message.failedDataTableRows && message.failedDataTableRows.length) {
                    object.failedDataTableRows = [];
                    for (var j = 0; j < message.failedDataTableRows.length; ++j)
                        object.failedDataTableRows[j] = message.failedDataTableRows[j];
                }
                if (message.executionTime != null && message.hasOwnProperty("executionTime"))
                    if (typeof message.executionTime === "number")
                        object.executionTime = options.longs === String ? String(message.executionTime) : message.executionTime;
                    else
                        object.executionTime = options.longs === String ? $util.Long.prototype.toString.call(message.executionTime) : options.longs === Number ? new $util.LongBits(message.executionTime.low >>> 0, message.executionTime.high >>> 0).toNumber() : message.executionTime;
                if (message.skipped != null && message.hasOwnProperty("skipped"))
                    object.skipped = message.skipped;
                if (message.scenarioSkippedCount != null && message.hasOwnProperty("scenarioSkippedCount"))
                    object.scenarioSkippedCount = message.scenarioSkippedCount;
                if (message.skippedDataTableRows && message.skippedDataTableRows.length) {
                    object.skippedDataTableRows = [];
                    for (var j = 0; j < message.skippedDataTableRows.length; ++j)
                        object.skippedDataTableRows[j] = message.skippedDataTableRows[j];
                }
                if (message.errors && message.errors.length) {
                    object.errors = [];
                    for (var j = 0; j < message.errors.length; ++j)
                        object.errors[j] = $root.gauge.messages.Error.toObject(message.errors[j], options);
                }
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    object.timestamp = message.timestamp;
                return object;
            };

            /**
             * Converts this ProtoSpecResult to JSON.
             * @function toJSON
             * @memberof gauge.messages.ProtoSpecResult
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ProtoSpecResult.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ProtoSpecResult;
        })();

        messages.ProtoScenarioResult = (function() {

            /**
             * Properties of a ProtoScenarioResult.
             * @memberof gauge.messages
             * @interface IProtoScenarioResult
             * @property {gauge.messages.IProtoItem|null} [protoItem] Collection of scenarios in scenario execution result.
             * @property {number|Long|null} [executionTime] Holds the time taken for executing the whole suite.
             * @property {string|null} [timestamp] Holds the timestamp of event starting.
             */

            /**
             * Constructs a new ProtoScenarioResult.
             * @memberof gauge.messages
             * @classdesc A proto object representing the result of Scenario execution.
             * @implements IProtoScenarioResult
             * @constructor
             * @param {gauge.messages.IProtoScenarioResult=} [properties] Properties to set
             */
            function ProtoScenarioResult(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Collection of scenarios in scenario execution result.
             * @member {gauge.messages.IProtoItem|null|undefined} protoItem
             * @memberof gauge.messages.ProtoScenarioResult
             * @instance
             */
            ProtoScenarioResult.prototype.protoItem = null;

            /**
             * Holds the time taken for executing the whole suite.
             * @member {number|Long} executionTime
             * @memberof gauge.messages.ProtoScenarioResult
             * @instance
             */
            ProtoScenarioResult.prototype.executionTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Holds the timestamp of event starting.
             * @member {string} timestamp
             * @memberof gauge.messages.ProtoScenarioResult
             * @instance
             */
            ProtoScenarioResult.prototype.timestamp = "";

            /**
             * Creates a new ProtoScenarioResult instance using the specified properties.
             * @function create
             * @memberof gauge.messages.ProtoScenarioResult
             * @static
             * @param {gauge.messages.IProtoScenarioResult=} [properties] Properties to set
             * @returns {gauge.messages.ProtoScenarioResult} ProtoScenarioResult instance
             */
            ProtoScenarioResult.create = function create(properties) {
                return new ProtoScenarioResult(properties);
            };

            /**
             * Encodes the specified ProtoScenarioResult message. Does not implicitly {@link gauge.messages.ProtoScenarioResult.verify|verify} messages.
             * @function encode
             * @memberof gauge.messages.ProtoScenarioResult
             * @static
             * @param {gauge.messages.IProtoScenarioResult} message ProtoScenarioResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ProtoScenarioResult.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.protoItem != null && message.hasOwnProperty("protoItem"))
                    $root.gauge.messages.ProtoItem.encode(message.protoItem, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.executionTime != null && message.hasOwnProperty("executionTime"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.executionTime);
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.timestamp);
                return writer;
            };

            /**
             * Encodes the specified ProtoScenarioResult message, length delimited. Does not implicitly {@link gauge.messages.ProtoScenarioResult.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gauge.messages.ProtoScenarioResult
             * @static
             * @param {gauge.messages.IProtoScenarioResult} message ProtoScenarioResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ProtoScenarioResult.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ProtoScenarioResult message from the specified reader or buffer.
             * @function decode
             * @memberof gauge.messages.ProtoScenarioResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gauge.messages.ProtoScenarioResult} ProtoScenarioResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ProtoScenarioResult.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gauge.messages.ProtoScenarioResult();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.protoItem = $root.gauge.messages.ProtoItem.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.executionTime = reader.int64();
                        break;
                    case 3:
                        message.timestamp = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ProtoScenarioResult message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gauge.messages.ProtoScenarioResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gauge.messages.ProtoScenarioResult} ProtoScenarioResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ProtoScenarioResult.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ProtoScenarioResult message.
             * @function verify
             * @memberof gauge.messages.ProtoScenarioResult
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ProtoScenarioResult.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.protoItem != null && message.hasOwnProperty("protoItem")) {
                    var error = $root.gauge.messages.ProtoItem.verify(message.protoItem);
                    if (error)
                        return "protoItem." + error;
                }
                if (message.executionTime != null && message.hasOwnProperty("executionTime"))
                    if (!$util.isInteger(message.executionTime) && !(message.executionTime && $util.isInteger(message.executionTime.low) && $util.isInteger(message.executionTime.high)))
                        return "executionTime: integer|Long expected";
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    if (!$util.isString(message.timestamp))
                        return "timestamp: string expected";
                return null;
            };

            /**
             * Creates a ProtoScenarioResult message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gauge.messages.ProtoScenarioResult
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gauge.messages.ProtoScenarioResult} ProtoScenarioResult
             */
            ProtoScenarioResult.fromObject = function fromObject(object) {
                if (object instanceof $root.gauge.messages.ProtoScenarioResult)
                    return object;
                var message = new $root.gauge.messages.ProtoScenarioResult();
                if (object.protoItem != null) {
                    if (typeof object.protoItem !== "object")
                        throw TypeError(".gauge.messages.ProtoScenarioResult.protoItem: object expected");
                    message.protoItem = $root.gauge.messages.ProtoItem.fromObject(object.protoItem);
                }
                if (object.executionTime != null)
                    if ($util.Long)
                        (message.executionTime = $util.Long.fromValue(object.executionTime)).unsigned = false;
                    else if (typeof object.executionTime === "string")
                        message.executionTime = parseInt(object.executionTime, 10);
                    else if (typeof object.executionTime === "number")
                        message.executionTime = object.executionTime;
                    else if (typeof object.executionTime === "object")
                        message.executionTime = new $util.LongBits(object.executionTime.low >>> 0, object.executionTime.high >>> 0).toNumber();
                if (object.timestamp != null)
                    message.timestamp = String(object.timestamp);
                return message;
            };

            /**
             * Creates a plain object from a ProtoScenarioResult message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gauge.messages.ProtoScenarioResult
             * @static
             * @param {gauge.messages.ProtoScenarioResult} message ProtoScenarioResult
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ProtoScenarioResult.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.protoItem = null;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.executionTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.executionTime = options.longs === String ? "0" : 0;
                    object.timestamp = "";
                }
                if (message.protoItem != null && message.hasOwnProperty("protoItem"))
                    object.protoItem = $root.gauge.messages.ProtoItem.toObject(message.protoItem, options);
                if (message.executionTime != null && message.hasOwnProperty("executionTime"))
                    if (typeof message.executionTime === "number")
                        object.executionTime = options.longs === String ? String(message.executionTime) : message.executionTime;
                    else
                        object.executionTime = options.longs === String ? $util.Long.prototype.toString.call(message.executionTime) : options.longs === Number ? new $util.LongBits(message.executionTime.low >>> 0, message.executionTime.high >>> 0).toNumber() : message.executionTime;
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    object.timestamp = message.timestamp;
                return object;
            };

            /**
             * Converts this ProtoScenarioResult to JSON.
             * @function toJSON
             * @memberof gauge.messages.ProtoScenarioResult
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ProtoScenarioResult.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ProtoScenarioResult;
        })();

        messages.ProtoStepResult = (function() {

            /**
             * Properties of a ProtoStepResult.
             * @memberof gauge.messages
             * @interface IProtoStepResult
             * @property {gauge.messages.IProtoItem|null} [protoItem] Collection of steps in step execution result.
             * @property {number|Long|null} [executionTime] Holds the time taken for executing the whole suite.
             * @property {string|null} [timestamp] Holds the timestamp of event starting.
             */

            /**
             * Constructs a new ProtoStepResult.
             * @memberof gauge.messages
             * @classdesc A proto object representing the result of Step execution.
             * @implements IProtoStepResult
             * @constructor
             * @param {gauge.messages.IProtoStepResult=} [properties] Properties to set
             */
            function ProtoStepResult(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Collection of steps in step execution result.
             * @member {gauge.messages.IProtoItem|null|undefined} protoItem
             * @memberof gauge.messages.ProtoStepResult
             * @instance
             */
            ProtoStepResult.prototype.protoItem = null;

            /**
             * Holds the time taken for executing the whole suite.
             * @member {number|Long} executionTime
             * @memberof gauge.messages.ProtoStepResult
             * @instance
             */
            ProtoStepResult.prototype.executionTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Holds the timestamp of event starting.
             * @member {string} timestamp
             * @memberof gauge.messages.ProtoStepResult
             * @instance
             */
            ProtoStepResult.prototype.timestamp = "";

            /**
             * Creates a new ProtoStepResult instance using the specified properties.
             * @function create
             * @memberof gauge.messages.ProtoStepResult
             * @static
             * @param {gauge.messages.IProtoStepResult=} [properties] Properties to set
             * @returns {gauge.messages.ProtoStepResult} ProtoStepResult instance
             */
            ProtoStepResult.create = function create(properties) {
                return new ProtoStepResult(properties);
            };

            /**
             * Encodes the specified ProtoStepResult message. Does not implicitly {@link gauge.messages.ProtoStepResult.verify|verify} messages.
             * @function encode
             * @memberof gauge.messages.ProtoStepResult
             * @static
             * @param {gauge.messages.IProtoStepResult} message ProtoStepResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ProtoStepResult.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.protoItem != null && message.hasOwnProperty("protoItem"))
                    $root.gauge.messages.ProtoItem.encode(message.protoItem, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.executionTime != null && message.hasOwnProperty("executionTime"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.executionTime);
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.timestamp);
                return writer;
            };

            /**
             * Encodes the specified ProtoStepResult message, length delimited. Does not implicitly {@link gauge.messages.ProtoStepResult.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gauge.messages.ProtoStepResult
             * @static
             * @param {gauge.messages.IProtoStepResult} message ProtoStepResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ProtoStepResult.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ProtoStepResult message from the specified reader or buffer.
             * @function decode
             * @memberof gauge.messages.ProtoStepResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gauge.messages.ProtoStepResult} ProtoStepResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ProtoStepResult.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gauge.messages.ProtoStepResult();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.protoItem = $root.gauge.messages.ProtoItem.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.executionTime = reader.int64();
                        break;
                    case 3:
                        message.timestamp = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ProtoStepResult message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gauge.messages.ProtoStepResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gauge.messages.ProtoStepResult} ProtoStepResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ProtoStepResult.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ProtoStepResult message.
             * @function verify
             * @memberof gauge.messages.ProtoStepResult
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ProtoStepResult.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.protoItem != null && message.hasOwnProperty("protoItem")) {
                    var error = $root.gauge.messages.ProtoItem.verify(message.protoItem);
                    if (error)
                        return "protoItem." + error;
                }
                if (message.executionTime != null && message.hasOwnProperty("executionTime"))
                    if (!$util.isInteger(message.executionTime) && !(message.executionTime && $util.isInteger(message.executionTime.low) && $util.isInteger(message.executionTime.high)))
                        return "executionTime: integer|Long expected";
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    if (!$util.isString(message.timestamp))
                        return "timestamp: string expected";
                return null;
            };

            /**
             * Creates a ProtoStepResult message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gauge.messages.ProtoStepResult
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gauge.messages.ProtoStepResult} ProtoStepResult
             */
            ProtoStepResult.fromObject = function fromObject(object) {
                if (object instanceof $root.gauge.messages.ProtoStepResult)
                    return object;
                var message = new $root.gauge.messages.ProtoStepResult();
                if (object.protoItem != null) {
                    if (typeof object.protoItem !== "object")
                        throw TypeError(".gauge.messages.ProtoStepResult.protoItem: object expected");
                    message.protoItem = $root.gauge.messages.ProtoItem.fromObject(object.protoItem);
                }
                if (object.executionTime != null)
                    if ($util.Long)
                        (message.executionTime = $util.Long.fromValue(object.executionTime)).unsigned = false;
                    else if (typeof object.executionTime === "string")
                        message.executionTime = parseInt(object.executionTime, 10);
                    else if (typeof object.executionTime === "number")
                        message.executionTime = object.executionTime;
                    else if (typeof object.executionTime === "object")
                        message.executionTime = new $util.LongBits(object.executionTime.low >>> 0, object.executionTime.high >>> 0).toNumber();
                if (object.timestamp != null)
                    message.timestamp = String(object.timestamp);
                return message;
            };

            /**
             * Creates a plain object from a ProtoStepResult message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gauge.messages.ProtoStepResult
             * @static
             * @param {gauge.messages.ProtoStepResult} message ProtoStepResult
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ProtoStepResult.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.protoItem = null;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.executionTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.executionTime = options.longs === String ? "0" : 0;
                    object.timestamp = "";
                }
                if (message.protoItem != null && message.hasOwnProperty("protoItem"))
                    object.protoItem = $root.gauge.messages.ProtoItem.toObject(message.protoItem, options);
                if (message.executionTime != null && message.hasOwnProperty("executionTime"))
                    if (typeof message.executionTime === "number")
                        object.executionTime = options.longs === String ? String(message.executionTime) : message.executionTime;
                    else
                        object.executionTime = options.longs === String ? $util.Long.prototype.toString.call(message.executionTime) : options.longs === Number ? new $util.LongBits(message.executionTime.low >>> 0, message.executionTime.high >>> 0).toNumber() : message.executionTime;
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    object.timestamp = message.timestamp;
                return object;
            };

            /**
             * Converts this ProtoStepResult to JSON.
             * @function toJSON
             * @memberof gauge.messages.ProtoStepResult
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ProtoStepResult.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ProtoStepResult;
        })();

        messages.Error = (function() {

            /**
             * Properties of an Error.
             * @memberof gauge.messages
             * @interface IError
             * @property {gauge.messages.Error.ErrorType|null} [type] Holds the type of error
             * @property {string|null} [filename] Holds the filename.
             * @property {number|null} [lineNumber] Holds the line number of the error in file.
             * @property {string|null} [message] Holds the error message.
             */

            /**
             * Constructs a new Error.
             * @memberof gauge.messages
             * @classdesc A proto object representing an error in spec/Scenario.
             * @implements IError
             * @constructor
             * @param {gauge.messages.IError=} [properties] Properties to set
             */
            function Error(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Holds the type of error
             * @member {gauge.messages.Error.ErrorType} type
             * @memberof gauge.messages.Error
             * @instance
             */
            Error.prototype.type = 0;

            /**
             * Holds the filename.
             * @member {string} filename
             * @memberof gauge.messages.Error
             * @instance
             */
            Error.prototype.filename = "";

            /**
             * Holds the line number of the error in file.
             * @member {number} lineNumber
             * @memberof gauge.messages.Error
             * @instance
             */
            Error.prototype.lineNumber = 0;

            /**
             * Holds the error message.
             * @member {string} message
             * @memberof gauge.messages.Error
             * @instance
             */
            Error.prototype.message = "";

            /**
             * Creates a new Error instance using the specified properties.
             * @function create
             * @memberof gauge.messages.Error
             * @static
             * @param {gauge.messages.IError=} [properties] Properties to set
             * @returns {gauge.messages.Error} Error instance
             */
            Error.create = function create(properties) {
                return new Error(properties);
            };

            /**
             * Encodes the specified Error message. Does not implicitly {@link gauge.messages.Error.verify|verify} messages.
             * @function encode
             * @memberof gauge.messages.Error
             * @static
             * @param {gauge.messages.IError} message Error message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Error.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.type != null && message.hasOwnProperty("type"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
                if (message.filename != null && message.hasOwnProperty("filename"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.filename);
                if (message.lineNumber != null && message.hasOwnProperty("lineNumber"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.lineNumber);
                if (message.message != null && message.hasOwnProperty("message"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.message);
                return writer;
            };

            /**
             * Encodes the specified Error message, length delimited. Does not implicitly {@link gauge.messages.Error.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gauge.messages.Error
             * @static
             * @param {gauge.messages.IError} message Error message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Error.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an Error message from the specified reader or buffer.
             * @function decode
             * @memberof gauge.messages.Error
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gauge.messages.Error} Error
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Error.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gauge.messages.Error();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.type = reader.int32();
                        break;
                    case 2:
                        message.filename = reader.string();
                        break;
                    case 3:
                        message.lineNumber = reader.int32();
                        break;
                    case 4:
                        message.message = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an Error message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gauge.messages.Error
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gauge.messages.Error} Error
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Error.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an Error message.
             * @function verify
             * @memberof gauge.messages.Error
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Error.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.type != null && message.hasOwnProperty("type"))
                    switch (message.type) {
                    default:
                        return "type: enum value expected";
                    case 0:
                    case 1:
                        break;
                    }
                if (message.filename != null && message.hasOwnProperty("filename"))
                    if (!$util.isString(message.filename))
                        return "filename: string expected";
                if (message.lineNumber != null && message.hasOwnProperty("lineNumber"))
                    if (!$util.isInteger(message.lineNumber))
                        return "lineNumber: integer expected";
                if (message.message != null && message.hasOwnProperty("message"))
                    if (!$util.isString(message.message))
                        return "message: string expected";
                return null;
            };

            /**
             * Creates an Error message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gauge.messages.Error
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gauge.messages.Error} Error
             */
            Error.fromObject = function fromObject(object) {
                if (object instanceof $root.gauge.messages.Error)
                    return object;
                var message = new $root.gauge.messages.Error();
                switch (object.type) {
                case "PARSE_ERROR":
                case 0:
                    message.type = 0;
                    break;
                case "VALIDATION_ERROR":
                case 1:
                    message.type = 1;
                    break;
                }
                if (object.filename != null)
                    message.filename = String(object.filename);
                if (object.lineNumber != null)
                    message.lineNumber = object.lineNumber | 0;
                if (object.message != null)
                    message.message = String(object.message);
                return message;
            };

            /**
             * Creates a plain object from an Error message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gauge.messages.Error
             * @static
             * @param {gauge.messages.Error} message Error
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Error.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.type = options.enums === String ? "PARSE_ERROR" : 0;
                    object.filename = "";
                    object.lineNumber = 0;
                    object.message = "";
                }
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = options.enums === String ? $root.gauge.messages.Error.ErrorType[message.type] : message.type;
                if (message.filename != null && message.hasOwnProperty("filename"))
                    object.filename = message.filename;
                if (message.lineNumber != null && message.hasOwnProperty("lineNumber"))
                    object.lineNumber = message.lineNumber;
                if (message.message != null && message.hasOwnProperty("message"))
                    object.message = message.message;
                return object;
            };

            /**
             * Converts this Error to JSON.
             * @function toJSON
             * @memberof gauge.messages.Error
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Error.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * ErrorType enum.
             * @name gauge.messages.Error.ErrorType
             * @enum {string}
             * @property {number} PARSE_ERROR=0 PARSE_ERROR value
             * @property {number} VALIDATION_ERROR=1 VALIDATION_ERROR value
             */
            Error.ErrorType = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "PARSE_ERROR"] = 0;
                values[valuesById[1] = "VALIDATION_ERROR"] = 1;
                return values;
            })();

            return Error;
        })();

        messages.ProtoStepValue = (function() {

            /**
             * Properties of a ProtoStepValue.
             * @memberof gauge.messages
             * @interface IProtoStepValue
             * @property {string|null} [stepValue] The actual string value describing he Step
             * @property {string|null} [parameterizedStepValue] The parameterized string value describing he Step. The parameters are replaced with placeholders.
             * @property {Array.<string>|null} [parameters] A collection of strings representing the parameters.
             */

            /**
             * Constructs a new ProtoStepValue.
             * @memberof gauge.messages
             * @classdesc A proto object representing a Step value.
             * @implements IProtoStepValue
             * @constructor
             * @param {gauge.messages.IProtoStepValue=} [properties] Properties to set
             */
            function ProtoStepValue(properties) {
                this.parameters = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * The actual string value describing he Step
             * @member {string} stepValue
             * @memberof gauge.messages.ProtoStepValue
             * @instance
             */
            ProtoStepValue.prototype.stepValue = "";

            /**
             * The parameterized string value describing he Step. The parameters are replaced with placeholders.
             * @member {string} parameterizedStepValue
             * @memberof gauge.messages.ProtoStepValue
             * @instance
             */
            ProtoStepValue.prototype.parameterizedStepValue = "";

            /**
             * A collection of strings representing the parameters.
             * @member {Array.<string>} parameters
             * @memberof gauge.messages.ProtoStepValue
             * @instance
             */
            ProtoStepValue.prototype.parameters = $util.emptyArray;

            /**
             * Creates a new ProtoStepValue instance using the specified properties.
             * @function create
             * @memberof gauge.messages.ProtoStepValue
             * @static
             * @param {gauge.messages.IProtoStepValue=} [properties] Properties to set
             * @returns {gauge.messages.ProtoStepValue} ProtoStepValue instance
             */
            ProtoStepValue.create = function create(properties) {
                return new ProtoStepValue(properties);
            };

            /**
             * Encodes the specified ProtoStepValue message. Does not implicitly {@link gauge.messages.ProtoStepValue.verify|verify} messages.
             * @function encode
             * @memberof gauge.messages.ProtoStepValue
             * @static
             * @param {gauge.messages.IProtoStepValue} message ProtoStepValue message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ProtoStepValue.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.stepValue != null && message.hasOwnProperty("stepValue"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.stepValue);
                if (message.parameterizedStepValue != null && message.hasOwnProperty("parameterizedStepValue"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.parameterizedStepValue);
                if (message.parameters != null && message.parameters.length)
                    for (var i = 0; i < message.parameters.length; ++i)
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.parameters[i]);
                return writer;
            };

            /**
             * Encodes the specified ProtoStepValue message, length delimited. Does not implicitly {@link gauge.messages.ProtoStepValue.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gauge.messages.ProtoStepValue
             * @static
             * @param {gauge.messages.IProtoStepValue} message ProtoStepValue message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ProtoStepValue.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ProtoStepValue message from the specified reader or buffer.
             * @function decode
             * @memberof gauge.messages.ProtoStepValue
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gauge.messages.ProtoStepValue} ProtoStepValue
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ProtoStepValue.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gauge.messages.ProtoStepValue();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.stepValue = reader.string();
                        break;
                    case 2:
                        message.parameterizedStepValue = reader.string();
                        break;
                    case 3:
                        if (!(message.parameters && message.parameters.length))
                            message.parameters = [];
                        message.parameters.push(reader.string());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ProtoStepValue message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gauge.messages.ProtoStepValue
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gauge.messages.ProtoStepValue} ProtoStepValue
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ProtoStepValue.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ProtoStepValue message.
             * @function verify
             * @memberof gauge.messages.ProtoStepValue
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ProtoStepValue.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.stepValue != null && message.hasOwnProperty("stepValue"))
                    if (!$util.isString(message.stepValue))
                        return "stepValue: string expected";
                if (message.parameterizedStepValue != null && message.hasOwnProperty("parameterizedStepValue"))
                    if (!$util.isString(message.parameterizedStepValue))
                        return "parameterizedStepValue: string expected";
                if (message.parameters != null && message.hasOwnProperty("parameters")) {
                    if (!Array.isArray(message.parameters))
                        return "parameters: array expected";
                    for (var i = 0; i < message.parameters.length; ++i)
                        if (!$util.isString(message.parameters[i]))
                            return "parameters: string[] expected";
                }
                return null;
            };

            /**
             * Creates a ProtoStepValue message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gauge.messages.ProtoStepValue
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gauge.messages.ProtoStepValue} ProtoStepValue
             */
            ProtoStepValue.fromObject = function fromObject(object) {
                if (object instanceof $root.gauge.messages.ProtoStepValue)
                    return object;
                var message = new $root.gauge.messages.ProtoStepValue();
                if (object.stepValue != null)
                    message.stepValue = String(object.stepValue);
                if (object.parameterizedStepValue != null)
                    message.parameterizedStepValue = String(object.parameterizedStepValue);
                if (object.parameters) {
                    if (!Array.isArray(object.parameters))
                        throw TypeError(".gauge.messages.ProtoStepValue.parameters: array expected");
                    message.parameters = [];
                    for (var i = 0; i < object.parameters.length; ++i)
                        message.parameters[i] = String(object.parameters[i]);
                }
                return message;
            };

            /**
             * Creates a plain object from a ProtoStepValue message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gauge.messages.ProtoStepValue
             * @static
             * @param {gauge.messages.ProtoStepValue} message ProtoStepValue
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ProtoStepValue.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.parameters = [];
                if (options.defaults) {
                    object.stepValue = "";
                    object.parameterizedStepValue = "";
                }
                if (message.stepValue != null && message.hasOwnProperty("stepValue"))
                    object.stepValue = message.stepValue;
                if (message.parameterizedStepValue != null && message.hasOwnProperty("parameterizedStepValue"))
                    object.parameterizedStepValue = message.parameterizedStepValue;
                if (message.parameters && message.parameters.length) {
                    object.parameters = [];
                    for (var j = 0; j < message.parameters.length; ++j)
                        object.parameters[j] = message.parameters[j];
                }
                return object;
            };

            /**
             * Converts this ProtoStepValue to JSON.
             * @function toJSON
             * @memberof gauge.messages.ProtoStepValue
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ProtoStepValue.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ProtoStepValue;
        })();

        messages.lspService = (function() {

            /**
             * Constructs a new lspService service.
             * @memberof gauge.messages
             * @classdesc Represents a lspService
             * @extends $protobuf.rpc.Service
             * @constructor
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             */
            function lspService(rpcImpl, requestDelimited, responseDelimited) {
                $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
            }

            (lspService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = lspService;

            /**
             * Creates new lspService service using the specified rpc implementation.
             * @function create
             * @memberof gauge.messages.lspService
             * @static
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             * @returns {lspService} RPC service. Useful where requests and/or responses are streamed.
             */
            lspService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                return new this(rpcImpl, requestDelimited, responseDelimited);
            };

            /**
             * Callback as used by {@link gauge.messages.lspService#getStepNames}.
             * @memberof gauge.messages.lspService
             * @typedef GetStepNamesCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {gauge.messages.StepNamesResponse} [response] StepNamesResponse
             */

            /**
             * Calls GetStepNames.
             * @function getStepNames
             * @memberof gauge.messages.lspService
             * @instance
             * @param {gauge.messages.IStepNamesRequest} request StepNamesRequest message or plain object
             * @param {gauge.messages.lspService.GetStepNamesCallback} callback Node-style callback called with the error, if any, and StepNamesResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(lspService.prototype.getStepNames = function getStepNames(request, callback) {
                return this.rpcCall(getStepNames, $root.gauge.messages.StepNamesRequest, $root.gauge.messages.StepNamesResponse, request, callback);
            }, "name", { value: "GetStepNames" });

            /**
             * Calls GetStepNames.
             * @function getStepNames
             * @memberof gauge.messages.lspService
             * @instance
             * @param {gauge.messages.IStepNamesRequest} request StepNamesRequest message or plain object
             * @returns {Promise<gauge.messages.StepNamesResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link gauge.messages.lspService#cacheFile}.
             * @memberof gauge.messages.lspService
             * @typedef CacheFileCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {gauge.messages.Empty} [response] Empty
             */

            /**
             * Calls CacheFile.
             * @function cacheFile
             * @memberof gauge.messages.lspService
             * @instance
             * @param {gauge.messages.ICacheFileRequest} request CacheFileRequest message or plain object
             * @param {gauge.messages.lspService.CacheFileCallback} callback Node-style callback called with the error, if any, and Empty
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(lspService.prototype.cacheFile = function cacheFile(request, callback) {
                return this.rpcCall(cacheFile, $root.gauge.messages.CacheFileRequest, $root.gauge.messages.Empty, request, callback);
            }, "name", { value: "CacheFile" });

            /**
             * Calls CacheFile.
             * @function cacheFile
             * @memberof gauge.messages.lspService
             * @instance
             * @param {gauge.messages.ICacheFileRequest} request CacheFileRequest message or plain object
             * @returns {Promise<gauge.messages.Empty>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link gauge.messages.lspService#getStepPositions}.
             * @memberof gauge.messages.lspService
             * @typedef GetStepPositionsCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {gauge.messages.StepPositionsResponse} [response] StepPositionsResponse
             */

            /**
             * Calls GetStepPositions.
             * @function getStepPositions
             * @memberof gauge.messages.lspService
             * @instance
             * @param {gauge.messages.IStepPositionsRequest} request StepPositionsRequest message or plain object
             * @param {gauge.messages.lspService.GetStepPositionsCallback} callback Node-style callback called with the error, if any, and StepPositionsResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(lspService.prototype.getStepPositions = function getStepPositions(request, callback) {
                return this.rpcCall(getStepPositions, $root.gauge.messages.StepPositionsRequest, $root.gauge.messages.StepPositionsResponse, request, callback);
            }, "name", { value: "GetStepPositions" });

            /**
             * Calls GetStepPositions.
             * @function getStepPositions
             * @memberof gauge.messages.lspService
             * @instance
             * @param {gauge.messages.IStepPositionsRequest} request StepPositionsRequest message or plain object
             * @returns {Promise<gauge.messages.StepPositionsResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link gauge.messages.lspService#getImplementationFiles}.
             * @memberof gauge.messages.lspService
             * @typedef GetImplementationFilesCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {gauge.messages.ImplementationFileListResponse} [response] ImplementationFileListResponse
             */

            /**
             * Calls GetImplementationFiles.
             * @function getImplementationFiles
             * @memberof gauge.messages.lspService
             * @instance
             * @param {gauge.messages.IEmpty} request Empty message or plain object
             * @param {gauge.messages.lspService.GetImplementationFilesCallback} callback Node-style callback called with the error, if any, and ImplementationFileListResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(lspService.prototype.getImplementationFiles = function getImplementationFiles(request, callback) {
                return this.rpcCall(getImplementationFiles, $root.gauge.messages.Empty, $root.gauge.messages.ImplementationFileListResponse, request, callback);
            }, "name", { value: "GetImplementationFiles" });

            /**
             * Calls GetImplementationFiles.
             * @function getImplementationFiles
             * @memberof gauge.messages.lspService
             * @instance
             * @param {gauge.messages.IEmpty} request Empty message or plain object
             * @returns {Promise<gauge.messages.ImplementationFileListResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link gauge.messages.lspService#implementStub}.
             * @memberof gauge.messages.lspService
             * @typedef ImplementStubCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {gauge.messages.FileDiff} [response] FileDiff
             */

            /**
             * Calls ImplementStub.
             * @function implementStub
             * @memberof gauge.messages.lspService
             * @instance
             * @param {gauge.messages.IStubImplementationCodeRequest} request StubImplementationCodeRequest message or plain object
             * @param {gauge.messages.lspService.ImplementStubCallback} callback Node-style callback called with the error, if any, and FileDiff
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(lspService.prototype.implementStub = function implementStub(request, callback) {
                return this.rpcCall(implementStub, $root.gauge.messages.StubImplementationCodeRequest, $root.gauge.messages.FileDiff, request, callback);
            }, "name", { value: "ImplementStub" });

            /**
             * Calls ImplementStub.
             * @function implementStub
             * @memberof gauge.messages.lspService
             * @instance
             * @param {gauge.messages.IStubImplementationCodeRequest} request StubImplementationCodeRequest message or plain object
             * @returns {Promise<gauge.messages.FileDiff>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link gauge.messages.lspService#validateStep}.
             * @memberof gauge.messages.lspService
             * @typedef ValidateStepCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {gauge.messages.StepValidateResponse} [response] StepValidateResponse
             */

            /**
             * Calls ValidateStep.
             * @function validateStep
             * @memberof gauge.messages.lspService
             * @instance
             * @param {gauge.messages.IStepValidateRequest} request StepValidateRequest message or plain object
             * @param {gauge.messages.lspService.ValidateStepCallback} callback Node-style callback called with the error, if any, and StepValidateResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(lspService.prototype.validateStep = function validateStep(request, callback) {
                return this.rpcCall(validateStep, $root.gauge.messages.StepValidateRequest, $root.gauge.messages.StepValidateResponse, request, callback);
            }, "name", { value: "ValidateStep" });

            /**
             * Calls ValidateStep.
             * @function validateStep
             * @memberof gauge.messages.lspService
             * @instance
             * @param {gauge.messages.IStepValidateRequest} request StepValidateRequest message or plain object
             * @returns {Promise<gauge.messages.StepValidateResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link gauge.messages.lspService#refactor}.
             * @memberof gauge.messages.lspService
             * @typedef RefactorCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {gauge.messages.RefactorResponse} [response] RefactorResponse
             */

            /**
             * Calls Refactor.
             * @function refactor
             * @memberof gauge.messages.lspService
             * @instance
             * @param {gauge.messages.IRefactorRequest} request RefactorRequest message or plain object
             * @param {gauge.messages.lspService.RefactorCallback} callback Node-style callback called with the error, if any, and RefactorResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(lspService.prototype.refactor = function refactor(request, callback) {
                return this.rpcCall(refactor, $root.gauge.messages.RefactorRequest, $root.gauge.messages.RefactorResponse, request, callback);
            }, "name", { value: "Refactor" });

            /**
             * Calls Refactor.
             * @function refactor
             * @memberof gauge.messages.lspService
             * @instance
             * @param {gauge.messages.IRefactorRequest} request RefactorRequest message or plain object
             * @returns {Promise<gauge.messages.RefactorResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link gauge.messages.lspService#getStepName}.
             * @memberof gauge.messages.lspService
             * @typedef GetStepNameCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {gauge.messages.StepNameResponse} [response] StepNameResponse
             */

            /**
             * Calls GetStepName.
             * @function getStepName
             * @memberof gauge.messages.lspService
             * @instance
             * @param {gauge.messages.IStepNameRequest} request StepNameRequest message or plain object
             * @param {gauge.messages.lspService.GetStepNameCallback} callback Node-style callback called with the error, if any, and StepNameResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(lspService.prototype.getStepName = function getStepName(request, callback) {
                return this.rpcCall(getStepName, $root.gauge.messages.StepNameRequest, $root.gauge.messages.StepNameResponse, request, callback);
            }, "name", { value: "GetStepName" });

            /**
             * Calls GetStepName.
             * @function getStepName
             * @memberof gauge.messages.lspService
             * @instance
             * @param {gauge.messages.IStepNameRequest} request StepNameRequest message or plain object
             * @returns {Promise<gauge.messages.StepNameResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link gauge.messages.lspService#getGlobPatterns}.
             * @memberof gauge.messages.lspService
             * @typedef GetGlobPatternsCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {gauge.messages.ImplementationFileGlobPatternResponse} [response] ImplementationFileGlobPatternResponse
             */

            /**
             * Calls GetGlobPatterns.
             * @function getGlobPatterns
             * @memberof gauge.messages.lspService
             * @instance
             * @param {gauge.messages.IEmpty} request Empty message or plain object
             * @param {gauge.messages.lspService.GetGlobPatternsCallback} callback Node-style callback called with the error, if any, and ImplementationFileGlobPatternResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(lspService.prototype.getGlobPatterns = function getGlobPatterns(request, callback) {
                return this.rpcCall(getGlobPatterns, $root.gauge.messages.Empty, $root.gauge.messages.ImplementationFileGlobPatternResponse, request, callback);
            }, "name", { value: "GetGlobPatterns" });

            /**
             * Calls GetGlobPatterns.
             * @function getGlobPatterns
             * @memberof gauge.messages.lspService
             * @instance
             * @param {gauge.messages.IEmpty} request Empty message or plain object
             * @returns {Promise<gauge.messages.ImplementationFileGlobPatternResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link gauge.messages.lspService#killProcess}.
             * @memberof gauge.messages.lspService
             * @typedef KillProcessCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {gauge.messages.Empty} [response] Empty
             */

            /**
             * Calls KillProcess.
             * @function killProcess
             * @memberof gauge.messages.lspService
             * @instance
             * @param {gauge.messages.IKillProcessRequest} request KillProcessRequest message or plain object
             * @param {gauge.messages.lspService.KillProcessCallback} callback Node-style callback called with the error, if any, and Empty
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(lspService.prototype.killProcess = function killProcess(request, callback) {
                return this.rpcCall(killProcess, $root.gauge.messages.KillProcessRequest, $root.gauge.messages.Empty, request, callback);
            }, "name", { value: "KillProcess" });

            /**
             * Calls KillProcess.
             * @function killProcess
             * @memberof gauge.messages.lspService
             * @instance
             * @param {gauge.messages.IKillProcessRequest} request KillProcessRequest message or plain object
             * @returns {Promise<gauge.messages.Empty>} Promise
             * @variation 2
             */

            return lspService;
        })();

        messages.KillProcessRequest = (function() {

            /**
             * Properties of a KillProcessRequest.
             * @memberof gauge.messages
             * @interface IKillProcessRequest
             */

            /**
             * Constructs a new KillProcessRequest.
             * @memberof gauge.messages
             * @classdesc Default request. Tells the runner to shutdown.
             * @implements IKillProcessRequest
             * @constructor
             * @param {gauge.messages.IKillProcessRequest=} [properties] Properties to set
             */
            function KillProcessRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new KillProcessRequest instance using the specified properties.
             * @function create
             * @memberof gauge.messages.KillProcessRequest
             * @static
             * @param {gauge.messages.IKillProcessRequest=} [properties] Properties to set
             * @returns {gauge.messages.KillProcessRequest} KillProcessRequest instance
             */
            KillProcessRequest.create = function create(properties) {
                return new KillProcessRequest(properties);
            };

            /**
             * Encodes the specified KillProcessRequest message. Does not implicitly {@link gauge.messages.KillProcessRequest.verify|verify} messages.
             * @function encode
             * @memberof gauge.messages.KillProcessRequest
             * @static
             * @param {gauge.messages.IKillProcessRequest} message KillProcessRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KillProcessRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified KillProcessRequest message, length delimited. Does not implicitly {@link gauge.messages.KillProcessRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gauge.messages.KillProcessRequest
             * @static
             * @param {gauge.messages.IKillProcessRequest} message KillProcessRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KillProcessRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a KillProcessRequest message from the specified reader or buffer.
             * @function decode
             * @memberof gauge.messages.KillProcessRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gauge.messages.KillProcessRequest} KillProcessRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KillProcessRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gauge.messages.KillProcessRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a KillProcessRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gauge.messages.KillProcessRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gauge.messages.KillProcessRequest} KillProcessRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KillProcessRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a KillProcessRequest message.
             * @function verify
             * @memberof gauge.messages.KillProcessRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            KillProcessRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a KillProcessRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gauge.messages.KillProcessRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gauge.messages.KillProcessRequest} KillProcessRequest
             */
            KillProcessRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.gauge.messages.KillProcessRequest)
                    return object;
                return new $root.gauge.messages.KillProcessRequest();
            };

            /**
             * Creates a plain object from a KillProcessRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gauge.messages.KillProcessRequest
             * @static
             * @param {gauge.messages.KillProcessRequest} message KillProcessRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            KillProcessRequest.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this KillProcessRequest to JSON.
             * @function toJSON
             * @memberof gauge.messages.KillProcessRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            KillProcessRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return KillProcessRequest;
        })();

        messages.ExecutionStatusResponse = (function() {

            /**
             * Properties of an ExecutionStatusResponse.
             * @memberof gauge.messages
             * @interface IExecutionStatusResponse
             * @property {gauge.messages.IProtoExecutionResult|null} [executionResult] Holds the suite result after suite execution done.
             */

            /**
             * Constructs a new ExecutionStatusResponse.
             * @memberof gauge.messages
             * @classdesc usually step execution, hooks etc will return this
             * @implements IExecutionStatusResponse
             * @constructor
             * @param {gauge.messages.IExecutionStatusResponse=} [properties] Properties to set
             */
            function ExecutionStatusResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Holds the suite result after suite execution done.
             * @member {gauge.messages.IProtoExecutionResult|null|undefined} executionResult
             * @memberof gauge.messages.ExecutionStatusResponse
             * @instance
             */
            ExecutionStatusResponse.prototype.executionResult = null;

            /**
             * Creates a new ExecutionStatusResponse instance using the specified properties.
             * @function create
             * @memberof gauge.messages.ExecutionStatusResponse
             * @static
             * @param {gauge.messages.IExecutionStatusResponse=} [properties] Properties to set
             * @returns {gauge.messages.ExecutionStatusResponse} ExecutionStatusResponse instance
             */
            ExecutionStatusResponse.create = function create(properties) {
                return new ExecutionStatusResponse(properties);
            };

            /**
             * Encodes the specified ExecutionStatusResponse message. Does not implicitly {@link gauge.messages.ExecutionStatusResponse.verify|verify} messages.
             * @function encode
             * @memberof gauge.messages.ExecutionStatusResponse
             * @static
             * @param {gauge.messages.IExecutionStatusResponse} message ExecutionStatusResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExecutionStatusResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.executionResult != null && message.hasOwnProperty("executionResult"))
                    $root.gauge.messages.ProtoExecutionResult.encode(message.executionResult, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ExecutionStatusResponse message, length delimited. Does not implicitly {@link gauge.messages.ExecutionStatusResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gauge.messages.ExecutionStatusResponse
             * @static
             * @param {gauge.messages.IExecutionStatusResponse} message ExecutionStatusResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExecutionStatusResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an ExecutionStatusResponse message from the specified reader or buffer.
             * @function decode
             * @memberof gauge.messages.ExecutionStatusResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gauge.messages.ExecutionStatusResponse} ExecutionStatusResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExecutionStatusResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gauge.messages.ExecutionStatusResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.executionResult = $root.gauge.messages.ProtoExecutionResult.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an ExecutionStatusResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gauge.messages.ExecutionStatusResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gauge.messages.ExecutionStatusResponse} ExecutionStatusResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExecutionStatusResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an ExecutionStatusResponse message.
             * @function verify
             * @memberof gauge.messages.ExecutionStatusResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ExecutionStatusResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.executionResult != null && message.hasOwnProperty("executionResult")) {
                    var error = $root.gauge.messages.ProtoExecutionResult.verify(message.executionResult);
                    if (error)
                        return "executionResult." + error;
                }
                return null;
            };

            /**
             * Creates an ExecutionStatusResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gauge.messages.ExecutionStatusResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gauge.messages.ExecutionStatusResponse} ExecutionStatusResponse
             */
            ExecutionStatusResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.gauge.messages.ExecutionStatusResponse)
                    return object;
                var message = new $root.gauge.messages.ExecutionStatusResponse();
                if (object.executionResult != null) {
                    if (typeof object.executionResult !== "object")
                        throw TypeError(".gauge.messages.ExecutionStatusResponse.executionResult: object expected");
                    message.executionResult = $root.gauge.messages.ProtoExecutionResult.fromObject(object.executionResult);
                }
                return message;
            };

            /**
             * Creates a plain object from an ExecutionStatusResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gauge.messages.ExecutionStatusResponse
             * @static
             * @param {gauge.messages.ExecutionStatusResponse} message ExecutionStatusResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ExecutionStatusResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.executionResult = null;
                if (message.executionResult != null && message.hasOwnProperty("executionResult"))
                    object.executionResult = $root.gauge.messages.ProtoExecutionResult.toObject(message.executionResult, options);
                return object;
            };

            /**
             * Converts this ExecutionStatusResponse to JSON.
             * @function toJSON
             * @memberof gauge.messages.ExecutionStatusResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ExecutionStatusResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ExecutionStatusResponse;
        })();

        messages.ExecutionStartingRequest = (function() {

            /**
             * Properties of an ExecutionStartingRequest.
             * @memberof gauge.messages
             * @interface IExecutionStartingRequest
             * @property {gauge.messages.IExecutionInfo|null} [currentExecutionInfo] Holds the current suite execution info.
             * @property {gauge.messages.IProtoSuiteResult|null} [suiteResult] Some fields will not be populated before execution.
             * @property {number|null} [stream] ExecutionStartingRequest stream
             */

            /**
             * Constructs a new ExecutionStartingRequest.
             * @memberof gauge.messages
             * @classdesc Sent at start of Suite Execution. Tells the runner to execute `before_suite` hook.
             * @implements IExecutionStartingRequest
             * @constructor
             * @param {gauge.messages.IExecutionStartingRequest=} [properties] Properties to set
             */
            function ExecutionStartingRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Holds the current suite execution info.
             * @member {gauge.messages.IExecutionInfo|null|undefined} currentExecutionInfo
             * @memberof gauge.messages.ExecutionStartingRequest
             * @instance
             */
            ExecutionStartingRequest.prototype.currentExecutionInfo = null;

            /**
             * Some fields will not be populated before execution.
             * @member {gauge.messages.IProtoSuiteResult|null|undefined} suiteResult
             * @memberof gauge.messages.ExecutionStartingRequest
             * @instance
             */
            ExecutionStartingRequest.prototype.suiteResult = null;

            /**
             * ExecutionStartingRequest stream.
             * @member {number} stream
             * @memberof gauge.messages.ExecutionStartingRequest
             * @instance
             */
            ExecutionStartingRequest.prototype.stream = 0;

            /**
             * Creates a new ExecutionStartingRequest instance using the specified properties.
             * @function create
             * @memberof gauge.messages.ExecutionStartingRequest
             * @static
             * @param {gauge.messages.IExecutionStartingRequest=} [properties] Properties to set
             * @returns {gauge.messages.ExecutionStartingRequest} ExecutionStartingRequest instance
             */
            ExecutionStartingRequest.create = function create(properties) {
                return new ExecutionStartingRequest(properties);
            };

            /**
             * Encodes the specified ExecutionStartingRequest message. Does not implicitly {@link gauge.messages.ExecutionStartingRequest.verify|verify} messages.
             * @function encode
             * @memberof gauge.messages.ExecutionStartingRequest
             * @static
             * @param {gauge.messages.IExecutionStartingRequest} message ExecutionStartingRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExecutionStartingRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.currentExecutionInfo != null && message.hasOwnProperty("currentExecutionInfo"))
                    $root.gauge.messages.ExecutionInfo.encode(message.currentExecutionInfo, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.suiteResult != null && message.hasOwnProperty("suiteResult"))
                    $root.gauge.messages.ProtoSuiteResult.encode(message.suiteResult, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.stream != null && message.hasOwnProperty("stream"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.stream);
                return writer;
            };

            /**
             * Encodes the specified ExecutionStartingRequest message, length delimited. Does not implicitly {@link gauge.messages.ExecutionStartingRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gauge.messages.ExecutionStartingRequest
             * @static
             * @param {gauge.messages.IExecutionStartingRequest} message ExecutionStartingRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExecutionStartingRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an ExecutionStartingRequest message from the specified reader or buffer.
             * @function decode
             * @memberof gauge.messages.ExecutionStartingRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gauge.messages.ExecutionStartingRequest} ExecutionStartingRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExecutionStartingRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gauge.messages.ExecutionStartingRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.currentExecutionInfo = $root.gauge.messages.ExecutionInfo.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.suiteResult = $root.gauge.messages.ProtoSuiteResult.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.stream = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an ExecutionStartingRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gauge.messages.ExecutionStartingRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gauge.messages.ExecutionStartingRequest} ExecutionStartingRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExecutionStartingRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an ExecutionStartingRequest message.
             * @function verify
             * @memberof gauge.messages.ExecutionStartingRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ExecutionStartingRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.currentExecutionInfo != null && message.hasOwnProperty("currentExecutionInfo")) {
                    var error = $root.gauge.messages.ExecutionInfo.verify(message.currentExecutionInfo);
                    if (error)
                        return "currentExecutionInfo." + error;
                }
                if (message.suiteResult != null && message.hasOwnProperty("suiteResult")) {
                    var error = $root.gauge.messages.ProtoSuiteResult.verify(message.suiteResult);
                    if (error)
                        return "suiteResult." + error;
                }
                if (message.stream != null && message.hasOwnProperty("stream"))
                    if (!$util.isInteger(message.stream))
                        return "stream: integer expected";
                return null;
            };

            /**
             * Creates an ExecutionStartingRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gauge.messages.ExecutionStartingRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gauge.messages.ExecutionStartingRequest} ExecutionStartingRequest
             */
            ExecutionStartingRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.gauge.messages.ExecutionStartingRequest)
                    return object;
                var message = new $root.gauge.messages.ExecutionStartingRequest();
                if (object.currentExecutionInfo != null) {
                    if (typeof object.currentExecutionInfo !== "object")
                        throw TypeError(".gauge.messages.ExecutionStartingRequest.currentExecutionInfo: object expected");
                    message.currentExecutionInfo = $root.gauge.messages.ExecutionInfo.fromObject(object.currentExecutionInfo);
                }
                if (object.suiteResult != null) {
                    if (typeof object.suiteResult !== "object")
                        throw TypeError(".gauge.messages.ExecutionStartingRequest.suiteResult: object expected");
                    message.suiteResult = $root.gauge.messages.ProtoSuiteResult.fromObject(object.suiteResult);
                }
                if (object.stream != null)
                    message.stream = object.stream | 0;
                return message;
            };

            /**
             * Creates a plain object from an ExecutionStartingRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gauge.messages.ExecutionStartingRequest
             * @static
             * @param {gauge.messages.ExecutionStartingRequest} message ExecutionStartingRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ExecutionStartingRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.currentExecutionInfo = null;
                    object.suiteResult = null;
                    object.stream = 0;
                }
                if (message.currentExecutionInfo != null && message.hasOwnProperty("currentExecutionInfo"))
                    object.currentExecutionInfo = $root.gauge.messages.ExecutionInfo.toObject(message.currentExecutionInfo, options);
                if (message.suiteResult != null && message.hasOwnProperty("suiteResult"))
                    object.suiteResult = $root.gauge.messages.ProtoSuiteResult.toObject(message.suiteResult, options);
                if (message.stream != null && message.hasOwnProperty("stream"))
                    object.stream = message.stream;
                return object;
            };

            /**
             * Converts this ExecutionStartingRequest to JSON.
             * @function toJSON
             * @memberof gauge.messages.ExecutionStartingRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ExecutionStartingRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ExecutionStartingRequest;
        })();

        messages.ExecutionEndingRequest = (function() {

            /**
             * Properties of an ExecutionEndingRequest.
             * @memberof gauge.messages
             * @interface IExecutionEndingRequest
             * @property {gauge.messages.IExecutionInfo|null} [currentExecutionInfo] Holds the current suite execution info.
             * @property {gauge.messages.IProtoSuiteResult|null} [suiteResult] Holds the suite result in execution ending.
             * @property {number|null} [stream] ExecutionEndingRequest stream
             */

            /**
             * Constructs a new ExecutionEndingRequest.
             * @memberof gauge.messages
             * @classdesc Sent at end of Suite Execution. Tells the runner to execute `after_suite` hook.
             * @implements IExecutionEndingRequest
             * @constructor
             * @param {gauge.messages.IExecutionEndingRequest=} [properties] Properties to set
             */
            function ExecutionEndingRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Holds the current suite execution info.
             * @member {gauge.messages.IExecutionInfo|null|undefined} currentExecutionInfo
             * @memberof gauge.messages.ExecutionEndingRequest
             * @instance
             */
            ExecutionEndingRequest.prototype.currentExecutionInfo = null;

            /**
             * Holds the suite result in execution ending.
             * @member {gauge.messages.IProtoSuiteResult|null|undefined} suiteResult
             * @memberof gauge.messages.ExecutionEndingRequest
             * @instance
             */
            ExecutionEndingRequest.prototype.suiteResult = null;

            /**
             * ExecutionEndingRequest stream.
             * @member {number} stream
             * @memberof gauge.messages.ExecutionEndingRequest
             * @instance
             */
            ExecutionEndingRequest.prototype.stream = 0;

            /**
             * Creates a new ExecutionEndingRequest instance using the specified properties.
             * @function create
             * @memberof gauge.messages.ExecutionEndingRequest
             * @static
             * @param {gauge.messages.IExecutionEndingRequest=} [properties] Properties to set
             * @returns {gauge.messages.ExecutionEndingRequest} ExecutionEndingRequest instance
             */
            ExecutionEndingRequest.create = function create(properties) {
                return new ExecutionEndingRequest(properties);
            };

            /**
             * Encodes the specified ExecutionEndingRequest message. Does not implicitly {@link gauge.messages.ExecutionEndingRequest.verify|verify} messages.
             * @function encode
             * @memberof gauge.messages.ExecutionEndingRequest
             * @static
             * @param {gauge.messages.IExecutionEndingRequest} message ExecutionEndingRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExecutionEndingRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.currentExecutionInfo != null && message.hasOwnProperty("currentExecutionInfo"))
                    $root.gauge.messages.ExecutionInfo.encode(message.currentExecutionInfo, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.suiteResult != null && message.hasOwnProperty("suiteResult"))
                    $root.gauge.messages.ProtoSuiteResult.encode(message.suiteResult, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.stream != null && message.hasOwnProperty("stream"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.stream);
                return writer;
            };

            /**
             * Encodes the specified ExecutionEndingRequest message, length delimited. Does not implicitly {@link gauge.messages.ExecutionEndingRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gauge.messages.ExecutionEndingRequest
             * @static
             * @param {gauge.messages.IExecutionEndingRequest} message ExecutionEndingRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExecutionEndingRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an ExecutionEndingRequest message from the specified reader or buffer.
             * @function decode
             * @memberof gauge.messages.ExecutionEndingRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gauge.messages.ExecutionEndingRequest} ExecutionEndingRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExecutionEndingRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gauge.messages.ExecutionEndingRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.currentExecutionInfo = $root.gauge.messages.ExecutionInfo.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.suiteResult = $root.gauge.messages.ProtoSuiteResult.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.stream = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an ExecutionEndingRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gauge.messages.ExecutionEndingRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gauge.messages.ExecutionEndingRequest} ExecutionEndingRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExecutionEndingRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an ExecutionEndingRequest message.
             * @function verify
             * @memberof gauge.messages.ExecutionEndingRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ExecutionEndingRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.currentExecutionInfo != null && message.hasOwnProperty("currentExecutionInfo")) {
                    var error = $root.gauge.messages.ExecutionInfo.verify(message.currentExecutionInfo);
                    if (error)
                        return "currentExecutionInfo." + error;
                }
                if (message.suiteResult != null && message.hasOwnProperty("suiteResult")) {
                    var error = $root.gauge.messages.ProtoSuiteResult.verify(message.suiteResult);
                    if (error)
                        return "suiteResult." + error;
                }
                if (message.stream != null && message.hasOwnProperty("stream"))
                    if (!$util.isInteger(message.stream))
                        return "stream: integer expected";
                return null;
            };

            /**
             * Creates an ExecutionEndingRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gauge.messages.ExecutionEndingRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gauge.messages.ExecutionEndingRequest} ExecutionEndingRequest
             */
            ExecutionEndingRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.gauge.messages.ExecutionEndingRequest)
                    return object;
                var message = new $root.gauge.messages.ExecutionEndingRequest();
                if (object.currentExecutionInfo != null) {
                    if (typeof object.currentExecutionInfo !== "object")
                        throw TypeError(".gauge.messages.ExecutionEndingRequest.currentExecutionInfo: object expected");
                    message.currentExecutionInfo = $root.gauge.messages.ExecutionInfo.fromObject(object.currentExecutionInfo);
                }
                if (object.suiteResult != null) {
                    if (typeof object.suiteResult !== "object")
                        throw TypeError(".gauge.messages.ExecutionEndingRequest.suiteResult: object expected");
                    message.suiteResult = $root.gauge.messages.ProtoSuiteResult.fromObject(object.suiteResult);
                }
                if (object.stream != null)
                    message.stream = object.stream | 0;
                return message;
            };

            /**
             * Creates a plain object from an ExecutionEndingRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gauge.messages.ExecutionEndingRequest
             * @static
             * @param {gauge.messages.ExecutionEndingRequest} message ExecutionEndingRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ExecutionEndingRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.currentExecutionInfo = null;
                    object.suiteResult = null;
                    object.stream = 0;
                }
                if (message.currentExecutionInfo != null && message.hasOwnProperty("currentExecutionInfo"))
                    object.currentExecutionInfo = $root.gauge.messages.ExecutionInfo.toObject(message.currentExecutionInfo, options);
                if (message.suiteResult != null && message.hasOwnProperty("suiteResult"))
                    object.suiteResult = $root.gauge.messages.ProtoSuiteResult.toObject(message.suiteResult, options);
                if (message.stream != null && message.hasOwnProperty("stream"))
                    object.stream = message.stream;
                return object;
            };

            /**
             * Converts this ExecutionEndingRequest to JSON.
             * @function toJSON
             * @memberof gauge.messages.ExecutionEndingRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ExecutionEndingRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ExecutionEndingRequest;
        })();

        messages.SpecExecutionStartingRequest = (function() {

            /**
             * Properties of a SpecExecutionStartingRequest.
             * @memberof gauge.messages
             * @interface ISpecExecutionStartingRequest
             * @property {gauge.messages.IExecutionInfo|null} [currentExecutionInfo] Holds the current spec execution info.
             * @property {gauge.messages.IProtoSpecResult|null} [specResult] Some fields will not be populated before execution.
             * @property {number|null} [stream] SpecExecutionStartingRequest stream
             */

            /**
             * Constructs a new SpecExecutionStartingRequest.
             * @memberof gauge.messages
             * @classdesc Sent at start of Spec Execution. Tells the runner to execute `before_spec` hook.
             * @implements ISpecExecutionStartingRequest
             * @constructor
             * @param {gauge.messages.ISpecExecutionStartingRequest=} [properties] Properties to set
             */
            function SpecExecutionStartingRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Holds the current spec execution info.
             * @member {gauge.messages.IExecutionInfo|null|undefined} currentExecutionInfo
             * @memberof gauge.messages.SpecExecutionStartingRequest
             * @instance
             */
            SpecExecutionStartingRequest.prototype.currentExecutionInfo = null;

            /**
             * Some fields will not be populated before execution.
             * @member {gauge.messages.IProtoSpecResult|null|undefined} specResult
             * @memberof gauge.messages.SpecExecutionStartingRequest
             * @instance
             */
            SpecExecutionStartingRequest.prototype.specResult = null;

            /**
             * SpecExecutionStartingRequest stream.
             * @member {number} stream
             * @memberof gauge.messages.SpecExecutionStartingRequest
             * @instance
             */
            SpecExecutionStartingRequest.prototype.stream = 0;

            /**
             * Creates a new SpecExecutionStartingRequest instance using the specified properties.
             * @function create
             * @memberof gauge.messages.SpecExecutionStartingRequest
             * @static
             * @param {gauge.messages.ISpecExecutionStartingRequest=} [properties] Properties to set
             * @returns {gauge.messages.SpecExecutionStartingRequest} SpecExecutionStartingRequest instance
             */
            SpecExecutionStartingRequest.create = function create(properties) {
                return new SpecExecutionStartingRequest(properties);
            };

            /**
             * Encodes the specified SpecExecutionStartingRequest message. Does not implicitly {@link gauge.messages.SpecExecutionStartingRequest.verify|verify} messages.
             * @function encode
             * @memberof gauge.messages.SpecExecutionStartingRequest
             * @static
             * @param {gauge.messages.ISpecExecutionStartingRequest} message SpecExecutionStartingRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SpecExecutionStartingRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.currentExecutionInfo != null && message.hasOwnProperty("currentExecutionInfo"))
                    $root.gauge.messages.ExecutionInfo.encode(message.currentExecutionInfo, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.specResult != null && message.hasOwnProperty("specResult"))
                    $root.gauge.messages.ProtoSpecResult.encode(message.specResult, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.stream != null && message.hasOwnProperty("stream"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.stream);
                return writer;
            };

            /**
             * Encodes the specified SpecExecutionStartingRequest message, length delimited. Does not implicitly {@link gauge.messages.SpecExecutionStartingRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gauge.messages.SpecExecutionStartingRequest
             * @static
             * @param {gauge.messages.ISpecExecutionStartingRequest} message SpecExecutionStartingRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SpecExecutionStartingRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SpecExecutionStartingRequest message from the specified reader or buffer.
             * @function decode
             * @memberof gauge.messages.SpecExecutionStartingRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gauge.messages.SpecExecutionStartingRequest} SpecExecutionStartingRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SpecExecutionStartingRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gauge.messages.SpecExecutionStartingRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.currentExecutionInfo = $root.gauge.messages.ExecutionInfo.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.specResult = $root.gauge.messages.ProtoSpecResult.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.stream = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SpecExecutionStartingRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gauge.messages.SpecExecutionStartingRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gauge.messages.SpecExecutionStartingRequest} SpecExecutionStartingRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SpecExecutionStartingRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SpecExecutionStartingRequest message.
             * @function verify
             * @memberof gauge.messages.SpecExecutionStartingRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SpecExecutionStartingRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.currentExecutionInfo != null && message.hasOwnProperty("currentExecutionInfo")) {
                    var error = $root.gauge.messages.ExecutionInfo.verify(message.currentExecutionInfo);
                    if (error)
                        return "currentExecutionInfo." + error;
                }
                if (message.specResult != null && message.hasOwnProperty("specResult")) {
                    var error = $root.gauge.messages.ProtoSpecResult.verify(message.specResult);
                    if (error)
                        return "specResult." + error;
                }
                if (message.stream != null && message.hasOwnProperty("stream"))
                    if (!$util.isInteger(message.stream))
                        return "stream: integer expected";
                return null;
            };

            /**
             * Creates a SpecExecutionStartingRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gauge.messages.SpecExecutionStartingRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gauge.messages.SpecExecutionStartingRequest} SpecExecutionStartingRequest
             */
            SpecExecutionStartingRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.gauge.messages.SpecExecutionStartingRequest)
                    return object;
                var message = new $root.gauge.messages.SpecExecutionStartingRequest();
                if (object.currentExecutionInfo != null) {
                    if (typeof object.currentExecutionInfo !== "object")
                        throw TypeError(".gauge.messages.SpecExecutionStartingRequest.currentExecutionInfo: object expected");
                    message.currentExecutionInfo = $root.gauge.messages.ExecutionInfo.fromObject(object.currentExecutionInfo);
                }
                if (object.specResult != null) {
                    if (typeof object.specResult !== "object")
                        throw TypeError(".gauge.messages.SpecExecutionStartingRequest.specResult: object expected");
                    message.specResult = $root.gauge.messages.ProtoSpecResult.fromObject(object.specResult);
                }
                if (object.stream != null)
                    message.stream = object.stream | 0;
                return message;
            };

            /**
             * Creates a plain object from a SpecExecutionStartingRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gauge.messages.SpecExecutionStartingRequest
             * @static
             * @param {gauge.messages.SpecExecutionStartingRequest} message SpecExecutionStartingRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SpecExecutionStartingRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.currentExecutionInfo = null;
                    object.specResult = null;
                    object.stream = 0;
                }
                if (message.currentExecutionInfo != null && message.hasOwnProperty("currentExecutionInfo"))
                    object.currentExecutionInfo = $root.gauge.messages.ExecutionInfo.toObject(message.currentExecutionInfo, options);
                if (message.specResult != null && message.hasOwnProperty("specResult"))
                    object.specResult = $root.gauge.messages.ProtoSpecResult.toObject(message.specResult, options);
                if (message.stream != null && message.hasOwnProperty("stream"))
                    object.stream = message.stream;
                return object;
            };

            /**
             * Converts this SpecExecutionStartingRequest to JSON.
             * @function toJSON
             * @memberof gauge.messages.SpecExecutionStartingRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SpecExecutionStartingRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return SpecExecutionStartingRequest;
        })();

        messages.SpecExecutionEndingRequest = (function() {

            /**
             * Properties of a SpecExecutionEndingRequest.
             * @memberof gauge.messages
             * @interface ISpecExecutionEndingRequest
             * @property {gauge.messages.IExecutionInfo|null} [currentExecutionInfo] Holds the current spec execution info.
             * @property {gauge.messages.IProtoSpecResult|null} [specResult] Holds the specs result in spec execution ending.
             * @property {number|null} [stream] SpecExecutionEndingRequest stream
             */

            /**
             * Constructs a new SpecExecutionEndingRequest.
             * @memberof gauge.messages
             * @classdesc Sent at end of Spec Execution. Tells the runner to execute `after_spec` hook.
             * @implements ISpecExecutionEndingRequest
             * @constructor
             * @param {gauge.messages.ISpecExecutionEndingRequest=} [properties] Properties to set
             */
            function SpecExecutionEndingRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Holds the current spec execution info.
             * @member {gauge.messages.IExecutionInfo|null|undefined} currentExecutionInfo
             * @memberof gauge.messages.SpecExecutionEndingRequest
             * @instance
             */
            SpecExecutionEndingRequest.prototype.currentExecutionInfo = null;

            /**
             * Holds the specs result in spec execution ending.
             * @member {gauge.messages.IProtoSpecResult|null|undefined} specResult
             * @memberof gauge.messages.SpecExecutionEndingRequest
             * @instance
             */
            SpecExecutionEndingRequest.prototype.specResult = null;

            /**
             * SpecExecutionEndingRequest stream.
             * @member {number} stream
             * @memberof gauge.messages.SpecExecutionEndingRequest
             * @instance
             */
            SpecExecutionEndingRequest.prototype.stream = 0;

            /**
             * Creates a new SpecExecutionEndingRequest instance using the specified properties.
             * @function create
             * @memberof gauge.messages.SpecExecutionEndingRequest
             * @static
             * @param {gauge.messages.ISpecExecutionEndingRequest=} [properties] Properties to set
             * @returns {gauge.messages.SpecExecutionEndingRequest} SpecExecutionEndingRequest instance
             */
            SpecExecutionEndingRequest.create = function create(properties) {
                return new SpecExecutionEndingRequest(properties);
            };

            /**
             * Encodes the specified SpecExecutionEndingRequest message. Does not implicitly {@link gauge.messages.SpecExecutionEndingRequest.verify|verify} messages.
             * @function encode
             * @memberof gauge.messages.SpecExecutionEndingRequest
             * @static
             * @param {gauge.messages.ISpecExecutionEndingRequest} message SpecExecutionEndingRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SpecExecutionEndingRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.currentExecutionInfo != null && message.hasOwnProperty("currentExecutionInfo"))
                    $root.gauge.messages.ExecutionInfo.encode(message.currentExecutionInfo, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.specResult != null && message.hasOwnProperty("specResult"))
                    $root.gauge.messages.ProtoSpecResult.encode(message.specResult, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.stream != null && message.hasOwnProperty("stream"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.stream);
                return writer;
            };

            /**
             * Encodes the specified SpecExecutionEndingRequest message, length delimited. Does not implicitly {@link gauge.messages.SpecExecutionEndingRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gauge.messages.SpecExecutionEndingRequest
             * @static
             * @param {gauge.messages.ISpecExecutionEndingRequest} message SpecExecutionEndingRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SpecExecutionEndingRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SpecExecutionEndingRequest message from the specified reader or buffer.
             * @function decode
             * @memberof gauge.messages.SpecExecutionEndingRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gauge.messages.SpecExecutionEndingRequest} SpecExecutionEndingRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SpecExecutionEndingRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gauge.messages.SpecExecutionEndingRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.currentExecutionInfo = $root.gauge.messages.ExecutionInfo.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.specResult = $root.gauge.messages.ProtoSpecResult.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.stream = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SpecExecutionEndingRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gauge.messages.SpecExecutionEndingRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gauge.messages.SpecExecutionEndingRequest} SpecExecutionEndingRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SpecExecutionEndingRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SpecExecutionEndingRequest message.
             * @function verify
             * @memberof gauge.messages.SpecExecutionEndingRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SpecExecutionEndingRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.currentExecutionInfo != null && message.hasOwnProperty("currentExecutionInfo")) {
                    var error = $root.gauge.messages.ExecutionInfo.verify(message.currentExecutionInfo);
                    if (error)
                        return "currentExecutionInfo." + error;
                }
                if (message.specResult != null && message.hasOwnProperty("specResult")) {
                    var error = $root.gauge.messages.ProtoSpecResult.verify(message.specResult);
                    if (error)
                        return "specResult." + error;
                }
                if (message.stream != null && message.hasOwnProperty("stream"))
                    if (!$util.isInteger(message.stream))
                        return "stream: integer expected";
                return null;
            };

            /**
             * Creates a SpecExecutionEndingRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gauge.messages.SpecExecutionEndingRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gauge.messages.SpecExecutionEndingRequest} SpecExecutionEndingRequest
             */
            SpecExecutionEndingRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.gauge.messages.SpecExecutionEndingRequest)
                    return object;
                var message = new $root.gauge.messages.SpecExecutionEndingRequest();
                if (object.currentExecutionInfo != null) {
                    if (typeof object.currentExecutionInfo !== "object")
                        throw TypeError(".gauge.messages.SpecExecutionEndingRequest.currentExecutionInfo: object expected");
                    message.currentExecutionInfo = $root.gauge.messages.ExecutionInfo.fromObject(object.currentExecutionInfo);
                }
                if (object.specResult != null) {
                    if (typeof object.specResult !== "object")
                        throw TypeError(".gauge.messages.SpecExecutionEndingRequest.specResult: object expected");
                    message.specResult = $root.gauge.messages.ProtoSpecResult.fromObject(object.specResult);
                }
                if (object.stream != null)
                    message.stream = object.stream | 0;
                return message;
            };

            /**
             * Creates a plain object from a SpecExecutionEndingRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gauge.messages.SpecExecutionEndingRequest
             * @static
             * @param {gauge.messages.SpecExecutionEndingRequest} message SpecExecutionEndingRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SpecExecutionEndingRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.currentExecutionInfo = null;
                    object.specResult = null;
                    object.stream = 0;
                }
                if (message.currentExecutionInfo != null && message.hasOwnProperty("currentExecutionInfo"))
                    object.currentExecutionInfo = $root.gauge.messages.ExecutionInfo.toObject(message.currentExecutionInfo, options);
                if (message.specResult != null && message.hasOwnProperty("specResult"))
                    object.specResult = $root.gauge.messages.ProtoSpecResult.toObject(message.specResult, options);
                if (message.stream != null && message.hasOwnProperty("stream"))
                    object.stream = message.stream;
                return object;
            };

            /**
             * Converts this SpecExecutionEndingRequest to JSON.
             * @function toJSON
             * @memberof gauge.messages.SpecExecutionEndingRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SpecExecutionEndingRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return SpecExecutionEndingRequest;
        })();

        messages.ScenarioExecutionStartingRequest = (function() {

            /**
             * Properties of a ScenarioExecutionStartingRequest.
             * @memberof gauge.messages
             * @interface IScenarioExecutionStartingRequest
             * @property {gauge.messages.IExecutionInfo|null} [currentExecutionInfo] Holds the current sceanrio execution info.
             * @property {gauge.messages.IProtoScenarioResult|null} [scenarioResult] Some fields will not be populated before execution.
             * @property {number|null} [stream] ScenarioExecutionStartingRequest stream
             */

            /**
             * Constructs a new ScenarioExecutionStartingRequest.
             * @memberof gauge.messages
             * @classdesc Sent at start of Scenario Execution. Tells the runner to execute `before_scenario` hook.
             * @implements IScenarioExecutionStartingRequest
             * @constructor
             * @param {gauge.messages.IScenarioExecutionStartingRequest=} [properties] Properties to set
             */
            function ScenarioExecutionStartingRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Holds the current sceanrio execution info.
             * @member {gauge.messages.IExecutionInfo|null|undefined} currentExecutionInfo
             * @memberof gauge.messages.ScenarioExecutionStartingRequest
             * @instance
             */
            ScenarioExecutionStartingRequest.prototype.currentExecutionInfo = null;

            /**
             * Some fields will not be populated before execution.
             * @member {gauge.messages.IProtoScenarioResult|null|undefined} scenarioResult
             * @memberof gauge.messages.ScenarioExecutionStartingRequest
             * @instance
             */
            ScenarioExecutionStartingRequest.prototype.scenarioResult = null;

            /**
             * ScenarioExecutionStartingRequest stream.
             * @member {number} stream
             * @memberof gauge.messages.ScenarioExecutionStartingRequest
             * @instance
             */
            ScenarioExecutionStartingRequest.prototype.stream = 0;

            /**
             * Creates a new ScenarioExecutionStartingRequest instance using the specified properties.
             * @function create
             * @memberof gauge.messages.ScenarioExecutionStartingRequest
             * @static
             * @param {gauge.messages.IScenarioExecutionStartingRequest=} [properties] Properties to set
             * @returns {gauge.messages.ScenarioExecutionStartingRequest} ScenarioExecutionStartingRequest instance
             */
            ScenarioExecutionStartingRequest.create = function create(properties) {
                return new ScenarioExecutionStartingRequest(properties);
            };

            /**
             * Encodes the specified ScenarioExecutionStartingRequest message. Does not implicitly {@link gauge.messages.ScenarioExecutionStartingRequest.verify|verify} messages.
             * @function encode
             * @memberof gauge.messages.ScenarioExecutionStartingRequest
             * @static
             * @param {gauge.messages.IScenarioExecutionStartingRequest} message ScenarioExecutionStartingRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ScenarioExecutionStartingRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.currentExecutionInfo != null && message.hasOwnProperty("currentExecutionInfo"))
                    $root.gauge.messages.ExecutionInfo.encode(message.currentExecutionInfo, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.scenarioResult != null && message.hasOwnProperty("scenarioResult"))
                    $root.gauge.messages.ProtoScenarioResult.encode(message.scenarioResult, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.stream != null && message.hasOwnProperty("stream"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.stream);
                return writer;
            };

            /**
             * Encodes the specified ScenarioExecutionStartingRequest message, length delimited. Does not implicitly {@link gauge.messages.ScenarioExecutionStartingRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gauge.messages.ScenarioExecutionStartingRequest
             * @static
             * @param {gauge.messages.IScenarioExecutionStartingRequest} message ScenarioExecutionStartingRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ScenarioExecutionStartingRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ScenarioExecutionStartingRequest message from the specified reader or buffer.
             * @function decode
             * @memberof gauge.messages.ScenarioExecutionStartingRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gauge.messages.ScenarioExecutionStartingRequest} ScenarioExecutionStartingRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ScenarioExecutionStartingRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gauge.messages.ScenarioExecutionStartingRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.currentExecutionInfo = $root.gauge.messages.ExecutionInfo.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.scenarioResult = $root.gauge.messages.ProtoScenarioResult.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.stream = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ScenarioExecutionStartingRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gauge.messages.ScenarioExecutionStartingRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gauge.messages.ScenarioExecutionStartingRequest} ScenarioExecutionStartingRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ScenarioExecutionStartingRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ScenarioExecutionStartingRequest message.
             * @function verify
             * @memberof gauge.messages.ScenarioExecutionStartingRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ScenarioExecutionStartingRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.currentExecutionInfo != null && message.hasOwnProperty("currentExecutionInfo")) {
                    var error = $root.gauge.messages.ExecutionInfo.verify(message.currentExecutionInfo);
                    if (error)
                        return "currentExecutionInfo." + error;
                }
                if (message.scenarioResult != null && message.hasOwnProperty("scenarioResult")) {
                    var error = $root.gauge.messages.ProtoScenarioResult.verify(message.scenarioResult);
                    if (error)
                        return "scenarioResult." + error;
                }
                if (message.stream != null && message.hasOwnProperty("stream"))
                    if (!$util.isInteger(message.stream))
                        return "stream: integer expected";
                return null;
            };

            /**
             * Creates a ScenarioExecutionStartingRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gauge.messages.ScenarioExecutionStartingRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gauge.messages.ScenarioExecutionStartingRequest} ScenarioExecutionStartingRequest
             */
            ScenarioExecutionStartingRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.gauge.messages.ScenarioExecutionStartingRequest)
                    return object;
                var message = new $root.gauge.messages.ScenarioExecutionStartingRequest();
                if (object.currentExecutionInfo != null) {
                    if (typeof object.currentExecutionInfo !== "object")
                        throw TypeError(".gauge.messages.ScenarioExecutionStartingRequest.currentExecutionInfo: object expected");
                    message.currentExecutionInfo = $root.gauge.messages.ExecutionInfo.fromObject(object.currentExecutionInfo);
                }
                if (object.scenarioResult != null) {
                    if (typeof object.scenarioResult !== "object")
                        throw TypeError(".gauge.messages.ScenarioExecutionStartingRequest.scenarioResult: object expected");
                    message.scenarioResult = $root.gauge.messages.ProtoScenarioResult.fromObject(object.scenarioResult);
                }
                if (object.stream != null)
                    message.stream = object.stream | 0;
                return message;
            };

            /**
             * Creates a plain object from a ScenarioExecutionStartingRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gauge.messages.ScenarioExecutionStartingRequest
             * @static
             * @param {gauge.messages.ScenarioExecutionStartingRequest} message ScenarioExecutionStartingRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ScenarioExecutionStartingRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.currentExecutionInfo = null;
                    object.scenarioResult = null;
                    object.stream = 0;
                }
                if (message.currentExecutionInfo != null && message.hasOwnProperty("currentExecutionInfo"))
                    object.currentExecutionInfo = $root.gauge.messages.ExecutionInfo.toObject(message.currentExecutionInfo, options);
                if (message.scenarioResult != null && message.hasOwnProperty("scenarioResult"))
                    object.scenarioResult = $root.gauge.messages.ProtoScenarioResult.toObject(message.scenarioResult, options);
                if (message.stream != null && message.hasOwnProperty("stream"))
                    object.stream = message.stream;
                return object;
            };

            /**
             * Converts this ScenarioExecutionStartingRequest to JSON.
             * @function toJSON
             * @memberof gauge.messages.ScenarioExecutionStartingRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ScenarioExecutionStartingRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ScenarioExecutionStartingRequest;
        })();

        messages.ScenarioExecutionEndingRequest = (function() {

            /**
             * Properties of a ScenarioExecutionEndingRequest.
             * @memberof gauge.messages
             * @interface IScenarioExecutionEndingRequest
             * @property {gauge.messages.IExecutionInfo|null} [currentExecutionInfo] Holds the current scenario execution info.
             * @property {gauge.messages.IProtoScenarioResult|null} [scenarioResult] ScenarioExecutionEndingRequest scenarioResult
             * @property {number|null} [stream] ScenarioExecutionEndingRequest stream
             */

            /**
             * Constructs a new ScenarioExecutionEndingRequest.
             * @memberof gauge.messages
             * @classdesc Sent at end of Scenario Execution. Tells the runner to execute `after_scenario` hook.
             * @implements IScenarioExecutionEndingRequest
             * @constructor
             * @param {gauge.messages.IScenarioExecutionEndingRequest=} [properties] Properties to set
             */
            function ScenarioExecutionEndingRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Holds the current scenario execution info.
             * @member {gauge.messages.IExecutionInfo|null|undefined} currentExecutionInfo
             * @memberof gauge.messages.ScenarioExecutionEndingRequest
             * @instance
             */
            ScenarioExecutionEndingRequest.prototype.currentExecutionInfo = null;

            /**
             * ScenarioExecutionEndingRequest scenarioResult.
             * @member {gauge.messages.IProtoScenarioResult|null|undefined} scenarioResult
             * @memberof gauge.messages.ScenarioExecutionEndingRequest
             * @instance
             */
            ScenarioExecutionEndingRequest.prototype.scenarioResult = null;

            /**
             * ScenarioExecutionEndingRequest stream.
             * @member {number} stream
             * @memberof gauge.messages.ScenarioExecutionEndingRequest
             * @instance
             */
            ScenarioExecutionEndingRequest.prototype.stream = 0;

            /**
             * Creates a new ScenarioExecutionEndingRequest instance using the specified properties.
             * @function create
             * @memberof gauge.messages.ScenarioExecutionEndingRequest
             * @static
             * @param {gauge.messages.IScenarioExecutionEndingRequest=} [properties] Properties to set
             * @returns {gauge.messages.ScenarioExecutionEndingRequest} ScenarioExecutionEndingRequest instance
             */
            ScenarioExecutionEndingRequest.create = function create(properties) {
                return new ScenarioExecutionEndingRequest(properties);
            };

            /**
             * Encodes the specified ScenarioExecutionEndingRequest message. Does not implicitly {@link gauge.messages.ScenarioExecutionEndingRequest.verify|verify} messages.
             * @function encode
             * @memberof gauge.messages.ScenarioExecutionEndingRequest
             * @static
             * @param {gauge.messages.IScenarioExecutionEndingRequest} message ScenarioExecutionEndingRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ScenarioExecutionEndingRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.currentExecutionInfo != null && message.hasOwnProperty("currentExecutionInfo"))
                    $root.gauge.messages.ExecutionInfo.encode(message.currentExecutionInfo, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.scenarioResult != null && message.hasOwnProperty("scenarioResult"))
                    $root.gauge.messages.ProtoScenarioResult.encode(message.scenarioResult, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.stream != null && message.hasOwnProperty("stream"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.stream);
                return writer;
            };

            /**
             * Encodes the specified ScenarioExecutionEndingRequest message, length delimited. Does not implicitly {@link gauge.messages.ScenarioExecutionEndingRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gauge.messages.ScenarioExecutionEndingRequest
             * @static
             * @param {gauge.messages.IScenarioExecutionEndingRequest} message ScenarioExecutionEndingRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ScenarioExecutionEndingRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ScenarioExecutionEndingRequest message from the specified reader or buffer.
             * @function decode
             * @memberof gauge.messages.ScenarioExecutionEndingRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gauge.messages.ScenarioExecutionEndingRequest} ScenarioExecutionEndingRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ScenarioExecutionEndingRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gauge.messages.ScenarioExecutionEndingRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.currentExecutionInfo = $root.gauge.messages.ExecutionInfo.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.scenarioResult = $root.gauge.messages.ProtoScenarioResult.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.stream = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ScenarioExecutionEndingRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gauge.messages.ScenarioExecutionEndingRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gauge.messages.ScenarioExecutionEndingRequest} ScenarioExecutionEndingRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ScenarioExecutionEndingRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ScenarioExecutionEndingRequest message.
             * @function verify
             * @memberof gauge.messages.ScenarioExecutionEndingRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ScenarioExecutionEndingRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.currentExecutionInfo != null && message.hasOwnProperty("currentExecutionInfo")) {
                    var error = $root.gauge.messages.ExecutionInfo.verify(message.currentExecutionInfo);
                    if (error)
                        return "currentExecutionInfo." + error;
                }
                if (message.scenarioResult != null && message.hasOwnProperty("scenarioResult")) {
                    var error = $root.gauge.messages.ProtoScenarioResult.verify(message.scenarioResult);
                    if (error)
                        return "scenarioResult." + error;
                }
                if (message.stream != null && message.hasOwnProperty("stream"))
                    if (!$util.isInteger(message.stream))
                        return "stream: integer expected";
                return null;
            };

            /**
             * Creates a ScenarioExecutionEndingRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gauge.messages.ScenarioExecutionEndingRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gauge.messages.ScenarioExecutionEndingRequest} ScenarioExecutionEndingRequest
             */
            ScenarioExecutionEndingRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.gauge.messages.ScenarioExecutionEndingRequest)
                    return object;
                var message = new $root.gauge.messages.ScenarioExecutionEndingRequest();
                if (object.currentExecutionInfo != null) {
                    if (typeof object.currentExecutionInfo !== "object")
                        throw TypeError(".gauge.messages.ScenarioExecutionEndingRequest.currentExecutionInfo: object expected");
                    message.currentExecutionInfo = $root.gauge.messages.ExecutionInfo.fromObject(object.currentExecutionInfo);
                }
                if (object.scenarioResult != null) {
                    if (typeof object.scenarioResult !== "object")
                        throw TypeError(".gauge.messages.ScenarioExecutionEndingRequest.scenarioResult: object expected");
                    message.scenarioResult = $root.gauge.messages.ProtoScenarioResult.fromObject(object.scenarioResult);
                }
                if (object.stream != null)
                    message.stream = object.stream | 0;
                return message;
            };

            /**
             * Creates a plain object from a ScenarioExecutionEndingRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gauge.messages.ScenarioExecutionEndingRequest
             * @static
             * @param {gauge.messages.ScenarioExecutionEndingRequest} message ScenarioExecutionEndingRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ScenarioExecutionEndingRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.currentExecutionInfo = null;
                    object.scenarioResult = null;
                    object.stream = 0;
                }
                if (message.currentExecutionInfo != null && message.hasOwnProperty("currentExecutionInfo"))
                    object.currentExecutionInfo = $root.gauge.messages.ExecutionInfo.toObject(message.currentExecutionInfo, options);
                if (message.scenarioResult != null && message.hasOwnProperty("scenarioResult"))
                    object.scenarioResult = $root.gauge.messages.ProtoScenarioResult.toObject(message.scenarioResult, options);
                if (message.stream != null && message.hasOwnProperty("stream"))
                    object.stream = message.stream;
                return object;
            };

            /**
             * Converts this ScenarioExecutionEndingRequest to JSON.
             * @function toJSON
             * @memberof gauge.messages.ScenarioExecutionEndingRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ScenarioExecutionEndingRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ScenarioExecutionEndingRequest;
        })();

        messages.StepExecutionStartingRequest = (function() {

            /**
             * Properties of a StepExecutionStartingRequest.
             * @memberof gauge.messages
             * @interface IStepExecutionStartingRequest
             * @property {gauge.messages.IExecutionInfo|null} [currentExecutionInfo] Holds the current step execution info.
             * @property {gauge.messages.IProtoStepResult|null} [stepResult] Some fields will not be populated before execution.
             * @property {number|null} [stream] StepExecutionStartingRequest stream
             */

            /**
             * Constructs a new StepExecutionStartingRequest.
             * @memberof gauge.messages
             * @classdesc Sent at start of Step Execution. Tells the runner to execute `before_step` hook.
             * @implements IStepExecutionStartingRequest
             * @constructor
             * @param {gauge.messages.IStepExecutionStartingRequest=} [properties] Properties to set
             */
            function StepExecutionStartingRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Holds the current step execution info.
             * @member {gauge.messages.IExecutionInfo|null|undefined} currentExecutionInfo
             * @memberof gauge.messages.StepExecutionStartingRequest
             * @instance
             */
            StepExecutionStartingRequest.prototype.currentExecutionInfo = null;

            /**
             * Some fields will not be populated before execution.
             * @member {gauge.messages.IProtoStepResult|null|undefined} stepResult
             * @memberof gauge.messages.StepExecutionStartingRequest
             * @instance
             */
            StepExecutionStartingRequest.prototype.stepResult = null;

            /**
             * StepExecutionStartingRequest stream.
             * @member {number} stream
             * @memberof gauge.messages.StepExecutionStartingRequest
             * @instance
             */
            StepExecutionStartingRequest.prototype.stream = 0;

            /**
             * Creates a new StepExecutionStartingRequest instance using the specified properties.
             * @function create
             * @memberof gauge.messages.StepExecutionStartingRequest
             * @static
             * @param {gauge.messages.IStepExecutionStartingRequest=} [properties] Properties to set
             * @returns {gauge.messages.StepExecutionStartingRequest} StepExecutionStartingRequest instance
             */
            StepExecutionStartingRequest.create = function create(properties) {
                return new StepExecutionStartingRequest(properties);
            };

            /**
             * Encodes the specified StepExecutionStartingRequest message. Does not implicitly {@link gauge.messages.StepExecutionStartingRequest.verify|verify} messages.
             * @function encode
             * @memberof gauge.messages.StepExecutionStartingRequest
             * @static
             * @param {gauge.messages.IStepExecutionStartingRequest} message StepExecutionStartingRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StepExecutionStartingRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.currentExecutionInfo != null && message.hasOwnProperty("currentExecutionInfo"))
                    $root.gauge.messages.ExecutionInfo.encode(message.currentExecutionInfo, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.stepResult != null && message.hasOwnProperty("stepResult"))
                    $root.gauge.messages.ProtoStepResult.encode(message.stepResult, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.stream != null && message.hasOwnProperty("stream"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.stream);
                return writer;
            };

            /**
             * Encodes the specified StepExecutionStartingRequest message, length delimited. Does not implicitly {@link gauge.messages.StepExecutionStartingRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gauge.messages.StepExecutionStartingRequest
             * @static
             * @param {gauge.messages.IStepExecutionStartingRequest} message StepExecutionStartingRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StepExecutionStartingRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a StepExecutionStartingRequest message from the specified reader or buffer.
             * @function decode
             * @memberof gauge.messages.StepExecutionStartingRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gauge.messages.StepExecutionStartingRequest} StepExecutionStartingRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StepExecutionStartingRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gauge.messages.StepExecutionStartingRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.currentExecutionInfo = $root.gauge.messages.ExecutionInfo.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.stepResult = $root.gauge.messages.ProtoStepResult.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.stream = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a StepExecutionStartingRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gauge.messages.StepExecutionStartingRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gauge.messages.StepExecutionStartingRequest} StepExecutionStartingRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StepExecutionStartingRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a StepExecutionStartingRequest message.
             * @function verify
             * @memberof gauge.messages.StepExecutionStartingRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            StepExecutionStartingRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.currentExecutionInfo != null && message.hasOwnProperty("currentExecutionInfo")) {
                    var error = $root.gauge.messages.ExecutionInfo.verify(message.currentExecutionInfo);
                    if (error)
                        return "currentExecutionInfo." + error;
                }
                if (message.stepResult != null && message.hasOwnProperty("stepResult")) {
                    var error = $root.gauge.messages.ProtoStepResult.verify(message.stepResult);
                    if (error)
                        return "stepResult." + error;
                }
                if (message.stream != null && message.hasOwnProperty("stream"))
                    if (!$util.isInteger(message.stream))
                        return "stream: integer expected";
                return null;
            };

            /**
             * Creates a StepExecutionStartingRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gauge.messages.StepExecutionStartingRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gauge.messages.StepExecutionStartingRequest} StepExecutionStartingRequest
             */
            StepExecutionStartingRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.gauge.messages.StepExecutionStartingRequest)
                    return object;
                var message = new $root.gauge.messages.StepExecutionStartingRequest();
                if (object.currentExecutionInfo != null) {
                    if (typeof object.currentExecutionInfo !== "object")
                        throw TypeError(".gauge.messages.StepExecutionStartingRequest.currentExecutionInfo: object expected");
                    message.currentExecutionInfo = $root.gauge.messages.ExecutionInfo.fromObject(object.currentExecutionInfo);
                }
                if (object.stepResult != null) {
                    if (typeof object.stepResult !== "object")
                        throw TypeError(".gauge.messages.StepExecutionStartingRequest.stepResult: object expected");
                    message.stepResult = $root.gauge.messages.ProtoStepResult.fromObject(object.stepResult);
                }
                if (object.stream != null)
                    message.stream = object.stream | 0;
                return message;
            };

            /**
             * Creates a plain object from a StepExecutionStartingRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gauge.messages.StepExecutionStartingRequest
             * @static
             * @param {gauge.messages.StepExecutionStartingRequest} message StepExecutionStartingRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            StepExecutionStartingRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.currentExecutionInfo = null;
                    object.stepResult = null;
                    object.stream = 0;
                }
                if (message.currentExecutionInfo != null && message.hasOwnProperty("currentExecutionInfo"))
                    object.currentExecutionInfo = $root.gauge.messages.ExecutionInfo.toObject(message.currentExecutionInfo, options);
                if (message.stepResult != null && message.hasOwnProperty("stepResult"))
                    object.stepResult = $root.gauge.messages.ProtoStepResult.toObject(message.stepResult, options);
                if (message.stream != null && message.hasOwnProperty("stream"))
                    object.stream = message.stream;
                return object;
            };

            /**
             * Converts this StepExecutionStartingRequest to JSON.
             * @function toJSON
             * @memberof gauge.messages.StepExecutionStartingRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            StepExecutionStartingRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return StepExecutionStartingRequest;
        })();

        messages.StepExecutionEndingRequest = (function() {

            /**
             * Properties of a StepExecutionEndingRequest.
             * @memberof gauge.messages
             * @interface IStepExecutionEndingRequest
             * @property {gauge.messages.IExecutionInfo|null} [currentExecutionInfo] Holds the current step execution info.
             * @property {gauge.messages.IProtoStepResult|null} [stepResult] Holds step result in step execution ending.
             * @property {number|null} [stream] StepExecutionEndingRequest stream
             */

            /**
             * Constructs a new StepExecutionEndingRequest.
             * @memberof gauge.messages
             * @classdesc Sent at end of Step Execution. Tells the runner to execute `after_step` hook.
             * @implements IStepExecutionEndingRequest
             * @constructor
             * @param {gauge.messages.IStepExecutionEndingRequest=} [properties] Properties to set
             */
            function StepExecutionEndingRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Holds the current step execution info.
             * @member {gauge.messages.IExecutionInfo|null|undefined} currentExecutionInfo
             * @memberof gauge.messages.StepExecutionEndingRequest
             * @instance
             */
            StepExecutionEndingRequest.prototype.currentExecutionInfo = null;

            /**
             * Holds step result in step execution ending.
             * @member {gauge.messages.IProtoStepResult|null|undefined} stepResult
             * @memberof gauge.messages.StepExecutionEndingRequest
             * @instance
             */
            StepExecutionEndingRequest.prototype.stepResult = null;

            /**
             * StepExecutionEndingRequest stream.
             * @member {number} stream
             * @memberof gauge.messages.StepExecutionEndingRequest
             * @instance
             */
            StepExecutionEndingRequest.prototype.stream = 0;

            /**
             * Creates a new StepExecutionEndingRequest instance using the specified properties.
             * @function create
             * @memberof gauge.messages.StepExecutionEndingRequest
             * @static
             * @param {gauge.messages.IStepExecutionEndingRequest=} [properties] Properties to set
             * @returns {gauge.messages.StepExecutionEndingRequest} StepExecutionEndingRequest instance
             */
            StepExecutionEndingRequest.create = function create(properties) {
                return new StepExecutionEndingRequest(properties);
            };

            /**
             * Encodes the specified StepExecutionEndingRequest message. Does not implicitly {@link gauge.messages.StepExecutionEndingRequest.verify|verify} messages.
             * @function encode
             * @memberof gauge.messages.StepExecutionEndingRequest
             * @static
             * @param {gauge.messages.IStepExecutionEndingRequest} message StepExecutionEndingRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StepExecutionEndingRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.currentExecutionInfo != null && message.hasOwnProperty("currentExecutionInfo"))
                    $root.gauge.messages.ExecutionInfo.encode(message.currentExecutionInfo, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.stepResult != null && message.hasOwnProperty("stepResult"))
                    $root.gauge.messages.ProtoStepResult.encode(message.stepResult, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.stream != null && message.hasOwnProperty("stream"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.stream);
                return writer;
            };

            /**
             * Encodes the specified StepExecutionEndingRequest message, length delimited. Does not implicitly {@link gauge.messages.StepExecutionEndingRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gauge.messages.StepExecutionEndingRequest
             * @static
             * @param {gauge.messages.IStepExecutionEndingRequest} message StepExecutionEndingRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StepExecutionEndingRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a StepExecutionEndingRequest message from the specified reader or buffer.
             * @function decode
             * @memberof gauge.messages.StepExecutionEndingRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gauge.messages.StepExecutionEndingRequest} StepExecutionEndingRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StepExecutionEndingRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gauge.messages.StepExecutionEndingRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.currentExecutionInfo = $root.gauge.messages.ExecutionInfo.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.stepResult = $root.gauge.messages.ProtoStepResult.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.stream = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a StepExecutionEndingRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gauge.messages.StepExecutionEndingRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gauge.messages.StepExecutionEndingRequest} StepExecutionEndingRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StepExecutionEndingRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a StepExecutionEndingRequest message.
             * @function verify
             * @memberof gauge.messages.StepExecutionEndingRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            StepExecutionEndingRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.currentExecutionInfo != null && message.hasOwnProperty("currentExecutionInfo")) {
                    var error = $root.gauge.messages.ExecutionInfo.verify(message.currentExecutionInfo);
                    if (error)
                        return "currentExecutionInfo." + error;
                }
                if (message.stepResult != null && message.hasOwnProperty("stepResult")) {
                    var error = $root.gauge.messages.ProtoStepResult.verify(message.stepResult);
                    if (error)
                        return "stepResult." + error;
                }
                if (message.stream != null && message.hasOwnProperty("stream"))
                    if (!$util.isInteger(message.stream))
                        return "stream: integer expected";
                return null;
            };

            /**
             * Creates a StepExecutionEndingRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gauge.messages.StepExecutionEndingRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gauge.messages.StepExecutionEndingRequest} StepExecutionEndingRequest
             */
            StepExecutionEndingRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.gauge.messages.StepExecutionEndingRequest)
                    return object;
                var message = new $root.gauge.messages.StepExecutionEndingRequest();
                if (object.currentExecutionInfo != null) {
                    if (typeof object.currentExecutionInfo !== "object")
                        throw TypeError(".gauge.messages.StepExecutionEndingRequest.currentExecutionInfo: object expected");
                    message.currentExecutionInfo = $root.gauge.messages.ExecutionInfo.fromObject(object.currentExecutionInfo);
                }
                if (object.stepResult != null) {
                    if (typeof object.stepResult !== "object")
                        throw TypeError(".gauge.messages.StepExecutionEndingRequest.stepResult: object expected");
                    message.stepResult = $root.gauge.messages.ProtoStepResult.fromObject(object.stepResult);
                }
                if (object.stream != null)
                    message.stream = object.stream | 0;
                return message;
            };

            /**
             * Creates a plain object from a StepExecutionEndingRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gauge.messages.StepExecutionEndingRequest
             * @static
             * @param {gauge.messages.StepExecutionEndingRequest} message StepExecutionEndingRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            StepExecutionEndingRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.currentExecutionInfo = null;
                    object.stepResult = null;
                    object.stream = 0;
                }
                if (message.currentExecutionInfo != null && message.hasOwnProperty("currentExecutionInfo"))
                    object.currentExecutionInfo = $root.gauge.messages.ExecutionInfo.toObject(message.currentExecutionInfo, options);
                if (message.stepResult != null && message.hasOwnProperty("stepResult"))
                    object.stepResult = $root.gauge.messages.ProtoStepResult.toObject(message.stepResult, options);
                if (message.stream != null && message.hasOwnProperty("stream"))
                    object.stream = message.stream;
                return object;
            };

            /**
             * Converts this StepExecutionEndingRequest to JSON.
             * @function toJSON
             * @memberof gauge.messages.StepExecutionEndingRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            StepExecutionEndingRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return StepExecutionEndingRequest;
        })();

        messages.ExecutionArg = (function() {

            /**
             * Properties of an ExecutionArg.
             * @memberof gauge.messages
             * @interface IExecutionArg
             * @property {string|null} [flagName] Holds the flag name passed from command line.
             * @property {Array.<string>|null} [flagValue] Holds the flag value passed from command line.
             */

            /**
             * Constructs a new ExecutionArg.
             * @memberof gauge.messages
             * @classdesc Contains command line arguments which passed by user during execution.
             * @implements IExecutionArg
             * @constructor
             * @param {gauge.messages.IExecutionArg=} [properties] Properties to set
             */
            function ExecutionArg(properties) {
                this.flagValue = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Holds the flag name passed from command line.
             * @member {string} flagName
             * @memberof gauge.messages.ExecutionArg
             * @instance
             */
            ExecutionArg.prototype.flagName = "";

            /**
             * Holds the flag value passed from command line.
             * @member {Array.<string>} flagValue
             * @memberof gauge.messages.ExecutionArg
             * @instance
             */
            ExecutionArg.prototype.flagValue = $util.emptyArray;

            /**
             * Creates a new ExecutionArg instance using the specified properties.
             * @function create
             * @memberof gauge.messages.ExecutionArg
             * @static
             * @param {gauge.messages.IExecutionArg=} [properties] Properties to set
             * @returns {gauge.messages.ExecutionArg} ExecutionArg instance
             */
            ExecutionArg.create = function create(properties) {
                return new ExecutionArg(properties);
            };

            /**
             * Encodes the specified ExecutionArg message. Does not implicitly {@link gauge.messages.ExecutionArg.verify|verify} messages.
             * @function encode
             * @memberof gauge.messages.ExecutionArg
             * @static
             * @param {gauge.messages.IExecutionArg} message ExecutionArg message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExecutionArg.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.flagName != null && message.hasOwnProperty("flagName"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.flagName);
                if (message.flagValue != null && message.flagValue.length)
                    for (var i = 0; i < message.flagValue.length; ++i)
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.flagValue[i]);
                return writer;
            };

            /**
             * Encodes the specified ExecutionArg message, length delimited. Does not implicitly {@link gauge.messages.ExecutionArg.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gauge.messages.ExecutionArg
             * @static
             * @param {gauge.messages.IExecutionArg} message ExecutionArg message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExecutionArg.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an ExecutionArg message from the specified reader or buffer.
             * @function decode
             * @memberof gauge.messages.ExecutionArg
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gauge.messages.ExecutionArg} ExecutionArg
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExecutionArg.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gauge.messages.ExecutionArg();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.flagName = reader.string();
                        break;
                    case 2:
                        if (!(message.flagValue && message.flagValue.length))
                            message.flagValue = [];
                        message.flagValue.push(reader.string());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an ExecutionArg message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gauge.messages.ExecutionArg
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gauge.messages.ExecutionArg} ExecutionArg
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExecutionArg.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an ExecutionArg message.
             * @function verify
             * @memberof gauge.messages.ExecutionArg
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ExecutionArg.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.flagName != null && message.hasOwnProperty("flagName"))
                    if (!$util.isString(message.flagName))
                        return "flagName: string expected";
                if (message.flagValue != null && message.hasOwnProperty("flagValue")) {
                    if (!Array.isArray(message.flagValue))
                        return "flagValue: array expected";
                    for (var i = 0; i < message.flagValue.length; ++i)
                        if (!$util.isString(message.flagValue[i]))
                            return "flagValue: string[] expected";
                }
                return null;
            };

            /**
             * Creates an ExecutionArg message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gauge.messages.ExecutionArg
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gauge.messages.ExecutionArg} ExecutionArg
             */
            ExecutionArg.fromObject = function fromObject(object) {
                if (object instanceof $root.gauge.messages.ExecutionArg)
                    return object;
                var message = new $root.gauge.messages.ExecutionArg();
                if (object.flagName != null)
                    message.flagName = String(object.flagName);
                if (object.flagValue) {
                    if (!Array.isArray(object.flagValue))
                        throw TypeError(".gauge.messages.ExecutionArg.flagValue: array expected");
                    message.flagValue = [];
                    for (var i = 0; i < object.flagValue.length; ++i)
                        message.flagValue[i] = String(object.flagValue[i]);
                }
                return message;
            };

            /**
             * Creates a plain object from an ExecutionArg message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gauge.messages.ExecutionArg
             * @static
             * @param {gauge.messages.ExecutionArg} message ExecutionArg
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ExecutionArg.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.flagValue = [];
                if (options.defaults)
                    object.flagName = "";
                if (message.flagName != null && message.hasOwnProperty("flagName"))
                    object.flagName = message.flagName;
                if (message.flagValue && message.flagValue.length) {
                    object.flagValue = [];
                    for (var j = 0; j < message.flagValue.length; ++j)
                        object.flagValue[j] = message.flagValue[j];
                }
                return object;
            };

            /**
             * Converts this ExecutionArg to JSON.
             * @function toJSON
             * @memberof gauge.messages.ExecutionArg
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ExecutionArg.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ExecutionArg;
        })();

        messages.ExecutionInfo = (function() {

            /**
             * Properties of an ExecutionInfo.
             * @memberof gauge.messages
             * @interface IExecutionInfo
             * @property {gauge.messages.ISpecInfo|null} [currentSpec] Holds the information of the current Spec. Valid in context of Spec execution.
             * @property {gauge.messages.IScenarioInfo|null} [currentScenario] Holds the information of the current Scenario. Valid in context of Scenario execution.
             * @property {gauge.messages.IStepInfo|null} [currentStep] Holds the information of the current Step. Valid in context of Step execution.
             * @property {string|null} [stacktrace] Stacktrace of the execution. Valid only if there is an error in execution.
             * @property {string|null} [projectName] Holds the project name
             * @property {Array.<gauge.messages.IExecutionArg>|null} [ExecutionArgs] Holds the command line arguments.
             * @property {number|null} [numberOfExecutionStreams] Holds the number of running execution streams.
             * @property {number|null} [runnerId] Holds the runner id for parallel execution.
             */

            /**
             * Constructs a new ExecutionInfo.
             * @memberof gauge.messages
             * @classdesc Depending on the context (Step, Scenario, Spec or Suite), the respective fields are set.
             * @implements IExecutionInfo
             * @constructor
             * @param {gauge.messages.IExecutionInfo=} [properties] Properties to set
             */
            function ExecutionInfo(properties) {
                this.ExecutionArgs = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Holds the information of the current Spec. Valid in context of Spec execution.
             * @member {gauge.messages.ISpecInfo|null|undefined} currentSpec
             * @memberof gauge.messages.ExecutionInfo
             * @instance
             */
            ExecutionInfo.prototype.currentSpec = null;

            /**
             * Holds the information of the current Scenario. Valid in context of Scenario execution.
             * @member {gauge.messages.IScenarioInfo|null|undefined} currentScenario
             * @memberof gauge.messages.ExecutionInfo
             * @instance
             */
            ExecutionInfo.prototype.currentScenario = null;

            /**
             * Holds the information of the current Step. Valid in context of Step execution.
             * @member {gauge.messages.IStepInfo|null|undefined} currentStep
             * @memberof gauge.messages.ExecutionInfo
             * @instance
             */
            ExecutionInfo.prototype.currentStep = null;

            /**
             * Stacktrace of the execution. Valid only if there is an error in execution.
             * @member {string} stacktrace
             * @memberof gauge.messages.ExecutionInfo
             * @instance
             */
            ExecutionInfo.prototype.stacktrace = "";

            /**
             * Holds the project name
             * @member {string} projectName
             * @memberof gauge.messages.ExecutionInfo
             * @instance
             */
            ExecutionInfo.prototype.projectName = "";

            /**
             * Holds the command line arguments.
             * @member {Array.<gauge.messages.IExecutionArg>} ExecutionArgs
             * @memberof gauge.messages.ExecutionInfo
             * @instance
             */
            ExecutionInfo.prototype.ExecutionArgs = $util.emptyArray;

            /**
             * Holds the number of running execution streams.
             * @member {number} numberOfExecutionStreams
             * @memberof gauge.messages.ExecutionInfo
             * @instance
             */
            ExecutionInfo.prototype.numberOfExecutionStreams = 0;

            /**
             * Holds the runner id for parallel execution.
             * @member {number} runnerId
             * @memberof gauge.messages.ExecutionInfo
             * @instance
             */
            ExecutionInfo.prototype.runnerId = 0;

            /**
             * Creates a new ExecutionInfo instance using the specified properties.
             * @function create
             * @memberof gauge.messages.ExecutionInfo
             * @static
             * @param {gauge.messages.IExecutionInfo=} [properties] Properties to set
             * @returns {gauge.messages.ExecutionInfo} ExecutionInfo instance
             */
            ExecutionInfo.create = function create(properties) {
                return new ExecutionInfo(properties);
            };

            /**
             * Encodes the specified ExecutionInfo message. Does not implicitly {@link gauge.messages.ExecutionInfo.verify|verify} messages.
             * @function encode
             * @memberof gauge.messages.ExecutionInfo
             * @static
             * @param {gauge.messages.IExecutionInfo} message ExecutionInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExecutionInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.currentSpec != null && message.hasOwnProperty("currentSpec"))
                    $root.gauge.messages.SpecInfo.encode(message.currentSpec, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.currentScenario != null && message.hasOwnProperty("currentScenario"))
                    $root.gauge.messages.ScenarioInfo.encode(message.currentScenario, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.currentStep != null && message.hasOwnProperty("currentStep"))
                    $root.gauge.messages.StepInfo.encode(message.currentStep, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.stacktrace != null && message.hasOwnProperty("stacktrace"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.stacktrace);
                if (message.projectName != null && message.hasOwnProperty("projectName"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.projectName);
                if (message.ExecutionArgs != null && message.ExecutionArgs.length)
                    for (var i = 0; i < message.ExecutionArgs.length; ++i)
                        $root.gauge.messages.ExecutionArg.encode(message.ExecutionArgs[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.numberOfExecutionStreams != null && message.hasOwnProperty("numberOfExecutionStreams"))
                    writer.uint32(/* id 7, wireType 0 =*/56).int32(message.numberOfExecutionStreams);
                if (message.runnerId != null && message.hasOwnProperty("runnerId"))
                    writer.uint32(/* id 8, wireType 0 =*/64).int32(message.runnerId);
                return writer;
            };

            /**
             * Encodes the specified ExecutionInfo message, length delimited. Does not implicitly {@link gauge.messages.ExecutionInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gauge.messages.ExecutionInfo
             * @static
             * @param {gauge.messages.IExecutionInfo} message ExecutionInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExecutionInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an ExecutionInfo message from the specified reader or buffer.
             * @function decode
             * @memberof gauge.messages.ExecutionInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gauge.messages.ExecutionInfo} ExecutionInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExecutionInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gauge.messages.ExecutionInfo();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.currentSpec = $root.gauge.messages.SpecInfo.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.currentScenario = $root.gauge.messages.ScenarioInfo.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.currentStep = $root.gauge.messages.StepInfo.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.stacktrace = reader.string();
                        break;
                    case 5:
                        message.projectName = reader.string();
                        break;
                    case 6:
                        if (!(message.ExecutionArgs && message.ExecutionArgs.length))
                            message.ExecutionArgs = [];
                        message.ExecutionArgs.push($root.gauge.messages.ExecutionArg.decode(reader, reader.uint32()));
                        break;
                    case 7:
                        message.numberOfExecutionStreams = reader.int32();
                        break;
                    case 8:
                        message.runnerId = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an ExecutionInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gauge.messages.ExecutionInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gauge.messages.ExecutionInfo} ExecutionInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExecutionInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an ExecutionInfo message.
             * @function verify
             * @memberof gauge.messages.ExecutionInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ExecutionInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.currentSpec != null && message.hasOwnProperty("currentSpec")) {
                    var error = $root.gauge.messages.SpecInfo.verify(message.currentSpec);
                    if (error)
                        return "currentSpec." + error;
                }
                if (message.currentScenario != null && message.hasOwnProperty("currentScenario")) {
                    var error = $root.gauge.messages.ScenarioInfo.verify(message.currentScenario);
                    if (error)
                        return "currentScenario." + error;
                }
                if (message.currentStep != null && message.hasOwnProperty("currentStep")) {
                    var error = $root.gauge.messages.StepInfo.verify(message.currentStep);
                    if (error)
                        return "currentStep." + error;
                }
                if (message.stacktrace != null && message.hasOwnProperty("stacktrace"))
                    if (!$util.isString(message.stacktrace))
                        return "stacktrace: string expected";
                if (message.projectName != null && message.hasOwnProperty("projectName"))
                    if (!$util.isString(message.projectName))
                        return "projectName: string expected";
                if (message.ExecutionArgs != null && message.hasOwnProperty("ExecutionArgs")) {
                    if (!Array.isArray(message.ExecutionArgs))
                        return "ExecutionArgs: array expected";
                    for (var i = 0; i < message.ExecutionArgs.length; ++i) {
                        var error = $root.gauge.messages.ExecutionArg.verify(message.ExecutionArgs[i]);
                        if (error)
                            return "ExecutionArgs." + error;
                    }
                }
                if (message.numberOfExecutionStreams != null && message.hasOwnProperty("numberOfExecutionStreams"))
                    if (!$util.isInteger(message.numberOfExecutionStreams))
                        return "numberOfExecutionStreams: integer expected";
                if (message.runnerId != null && message.hasOwnProperty("runnerId"))
                    if (!$util.isInteger(message.runnerId))
                        return "runnerId: integer expected";
                return null;
            };

            /**
             * Creates an ExecutionInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gauge.messages.ExecutionInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gauge.messages.ExecutionInfo} ExecutionInfo
             */
            ExecutionInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.gauge.messages.ExecutionInfo)
                    return object;
                var message = new $root.gauge.messages.ExecutionInfo();
                if (object.currentSpec != null) {
                    if (typeof object.currentSpec !== "object")
                        throw TypeError(".gauge.messages.ExecutionInfo.currentSpec: object expected");
                    message.currentSpec = $root.gauge.messages.SpecInfo.fromObject(object.currentSpec);
                }
                if (object.currentScenario != null) {
                    if (typeof object.currentScenario !== "object")
                        throw TypeError(".gauge.messages.ExecutionInfo.currentScenario: object expected");
                    message.currentScenario = $root.gauge.messages.ScenarioInfo.fromObject(object.currentScenario);
                }
                if (object.currentStep != null) {
                    if (typeof object.currentStep !== "object")
                        throw TypeError(".gauge.messages.ExecutionInfo.currentStep: object expected");
                    message.currentStep = $root.gauge.messages.StepInfo.fromObject(object.currentStep);
                }
                if (object.stacktrace != null)
                    message.stacktrace = String(object.stacktrace);
                if (object.projectName != null)
                    message.projectName = String(object.projectName);
                if (object.ExecutionArgs) {
                    if (!Array.isArray(object.ExecutionArgs))
                        throw TypeError(".gauge.messages.ExecutionInfo.ExecutionArgs: array expected");
                    message.ExecutionArgs = [];
                    for (var i = 0; i < object.ExecutionArgs.length; ++i) {
                        if (typeof object.ExecutionArgs[i] !== "object")
                            throw TypeError(".gauge.messages.ExecutionInfo.ExecutionArgs: object expected");
                        message.ExecutionArgs[i] = $root.gauge.messages.ExecutionArg.fromObject(object.ExecutionArgs[i]);
                    }
                }
                if (object.numberOfExecutionStreams != null)
                    message.numberOfExecutionStreams = object.numberOfExecutionStreams | 0;
                if (object.runnerId != null)
                    message.runnerId = object.runnerId | 0;
                return message;
            };

            /**
             * Creates a plain object from an ExecutionInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gauge.messages.ExecutionInfo
             * @static
             * @param {gauge.messages.ExecutionInfo} message ExecutionInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ExecutionInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.ExecutionArgs = [];
                if (options.defaults) {
                    object.currentSpec = null;
                    object.currentScenario = null;
                    object.currentStep = null;
                    object.stacktrace = "";
                    object.projectName = "";
                    object.numberOfExecutionStreams = 0;
                    object.runnerId = 0;
                }
                if (message.currentSpec != null && message.hasOwnProperty("currentSpec"))
                    object.currentSpec = $root.gauge.messages.SpecInfo.toObject(message.currentSpec, options);
                if (message.currentScenario != null && message.hasOwnProperty("currentScenario"))
                    object.currentScenario = $root.gauge.messages.ScenarioInfo.toObject(message.currentScenario, options);
                if (message.currentStep != null && message.hasOwnProperty("currentStep"))
                    object.currentStep = $root.gauge.messages.StepInfo.toObject(message.currentStep, options);
                if (message.stacktrace != null && message.hasOwnProperty("stacktrace"))
                    object.stacktrace = message.stacktrace;
                if (message.projectName != null && message.hasOwnProperty("projectName"))
                    object.projectName = message.projectName;
                if (message.ExecutionArgs && message.ExecutionArgs.length) {
                    object.ExecutionArgs = [];
                    for (var j = 0; j < message.ExecutionArgs.length; ++j)
                        object.ExecutionArgs[j] = $root.gauge.messages.ExecutionArg.toObject(message.ExecutionArgs[j], options);
                }
                if (message.numberOfExecutionStreams != null && message.hasOwnProperty("numberOfExecutionStreams"))
                    object.numberOfExecutionStreams = message.numberOfExecutionStreams;
                if (message.runnerId != null && message.hasOwnProperty("runnerId"))
                    object.runnerId = message.runnerId;
                return object;
            };

            /**
             * Converts this ExecutionInfo to JSON.
             * @function toJSON
             * @memberof gauge.messages.ExecutionInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ExecutionInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ExecutionInfo;
        })();

        messages.SpecInfo = (function() {

            /**
             * Properties of a SpecInfo.
             * @memberof gauge.messages
             * @interface ISpecInfo
             * @property {string|null} [name] Name of the current Spec being executed.
             * @property {string|null} [fileName] Full File path containing the current Spec being executed.
             * @property {boolean|null} [isFailed] Flag to indicate if the current Spec execution failed.
             * @property {Array.<string>|null} [tags] Tags relevant to the current Spec execution.
             */

            /**
             * Constructs a new SpecInfo.
             * @memberof gauge.messages
             * @classdesc Contains details of the Spec execution.
             * @implements ISpecInfo
             * @constructor
             * @param {gauge.messages.ISpecInfo=} [properties] Properties to set
             */
            function SpecInfo(properties) {
                this.tags = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Name of the current Spec being executed.
             * @member {string} name
             * @memberof gauge.messages.SpecInfo
             * @instance
             */
            SpecInfo.prototype.name = "";

            /**
             * Full File path containing the current Spec being executed.
             * @member {string} fileName
             * @memberof gauge.messages.SpecInfo
             * @instance
             */
            SpecInfo.prototype.fileName = "";

            /**
             * Flag to indicate if the current Spec execution failed.
             * @member {boolean} isFailed
             * @memberof gauge.messages.SpecInfo
             * @instance
             */
            SpecInfo.prototype.isFailed = false;

            /**
             * Tags relevant to the current Spec execution.
             * @member {Array.<string>} tags
             * @memberof gauge.messages.SpecInfo
             * @instance
             */
            SpecInfo.prototype.tags = $util.emptyArray;

            /**
             * Creates a new SpecInfo instance using the specified properties.
             * @function create
             * @memberof gauge.messages.SpecInfo
             * @static
             * @param {gauge.messages.ISpecInfo=} [properties] Properties to set
             * @returns {gauge.messages.SpecInfo} SpecInfo instance
             */
            SpecInfo.create = function create(properties) {
                return new SpecInfo(properties);
            };

            /**
             * Encodes the specified SpecInfo message. Does not implicitly {@link gauge.messages.SpecInfo.verify|verify} messages.
             * @function encode
             * @memberof gauge.messages.SpecInfo
             * @static
             * @param {gauge.messages.ISpecInfo} message SpecInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SpecInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && message.hasOwnProperty("name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.fileName != null && message.hasOwnProperty("fileName"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.fileName);
                if (message.isFailed != null && message.hasOwnProperty("isFailed"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.isFailed);
                if (message.tags != null && message.tags.length)
                    for (var i = 0; i < message.tags.length; ++i)
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.tags[i]);
                return writer;
            };

            /**
             * Encodes the specified SpecInfo message, length delimited. Does not implicitly {@link gauge.messages.SpecInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gauge.messages.SpecInfo
             * @static
             * @param {gauge.messages.ISpecInfo} message SpecInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SpecInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SpecInfo message from the specified reader or buffer.
             * @function decode
             * @memberof gauge.messages.SpecInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gauge.messages.SpecInfo} SpecInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SpecInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gauge.messages.SpecInfo();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        message.fileName = reader.string();
                        break;
                    case 3:
                        message.isFailed = reader.bool();
                        break;
                    case 4:
                        if (!(message.tags && message.tags.length))
                            message.tags = [];
                        message.tags.push(reader.string());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SpecInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gauge.messages.SpecInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gauge.messages.SpecInfo} SpecInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SpecInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SpecInfo message.
             * @function verify
             * @memberof gauge.messages.SpecInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SpecInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.fileName != null && message.hasOwnProperty("fileName"))
                    if (!$util.isString(message.fileName))
                        return "fileName: string expected";
                if (message.isFailed != null && message.hasOwnProperty("isFailed"))
                    if (typeof message.isFailed !== "boolean")
                        return "isFailed: boolean expected";
                if (message.tags != null && message.hasOwnProperty("tags")) {
                    if (!Array.isArray(message.tags))
                        return "tags: array expected";
                    for (var i = 0; i < message.tags.length; ++i)
                        if (!$util.isString(message.tags[i]))
                            return "tags: string[] expected";
                }
                return null;
            };

            /**
             * Creates a SpecInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gauge.messages.SpecInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gauge.messages.SpecInfo} SpecInfo
             */
            SpecInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.gauge.messages.SpecInfo)
                    return object;
                var message = new $root.gauge.messages.SpecInfo();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.fileName != null)
                    message.fileName = String(object.fileName);
                if (object.isFailed != null)
                    message.isFailed = Boolean(object.isFailed);
                if (object.tags) {
                    if (!Array.isArray(object.tags))
                        throw TypeError(".gauge.messages.SpecInfo.tags: array expected");
                    message.tags = [];
                    for (var i = 0; i < object.tags.length; ++i)
                        message.tags[i] = String(object.tags[i]);
                }
                return message;
            };

            /**
             * Creates a plain object from a SpecInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gauge.messages.SpecInfo
             * @static
             * @param {gauge.messages.SpecInfo} message SpecInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SpecInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.tags = [];
                if (options.defaults) {
                    object.name = "";
                    object.fileName = "";
                    object.isFailed = false;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.fileName != null && message.hasOwnProperty("fileName"))
                    object.fileName = message.fileName;
                if (message.isFailed != null && message.hasOwnProperty("isFailed"))
                    object.isFailed = message.isFailed;
                if (message.tags && message.tags.length) {
                    object.tags = [];
                    for (var j = 0; j < message.tags.length; ++j)
                        object.tags[j] = message.tags[j];
                }
                return object;
            };

            /**
             * Converts this SpecInfo to JSON.
             * @function toJSON
             * @memberof gauge.messages.SpecInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SpecInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return SpecInfo;
        })();

        messages.ScenarioInfo = (function() {

            /**
             * Properties of a ScenarioInfo.
             * @memberof gauge.messages
             * @interface IScenarioInfo
             * @property {string|null} [name] Name of the current Scenario being executed.
             * @property {boolean|null} [isFailed] Flag to indicate if the current Scenario execution failed.
             * @property {Array.<string>|null} [tags] Tags relevant to the current Scenario execution.
             */

            /**
             * Constructs a new ScenarioInfo.
             * @memberof gauge.messages
             * @classdesc Contains details of the Scenario execution.
             * @implements IScenarioInfo
             * @constructor
             * @param {gauge.messages.IScenarioInfo=} [properties] Properties to set
             */
            function ScenarioInfo(properties) {
                this.tags = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Name of the current Scenario being executed.
             * @member {string} name
             * @memberof gauge.messages.ScenarioInfo
             * @instance
             */
            ScenarioInfo.prototype.name = "";

            /**
             * Flag to indicate if the current Scenario execution failed.
             * @member {boolean} isFailed
             * @memberof gauge.messages.ScenarioInfo
             * @instance
             */
            ScenarioInfo.prototype.isFailed = false;

            /**
             * Tags relevant to the current Scenario execution.
             * @member {Array.<string>} tags
             * @memberof gauge.messages.ScenarioInfo
             * @instance
             */
            ScenarioInfo.prototype.tags = $util.emptyArray;

            /**
             * Creates a new ScenarioInfo instance using the specified properties.
             * @function create
             * @memberof gauge.messages.ScenarioInfo
             * @static
             * @param {gauge.messages.IScenarioInfo=} [properties] Properties to set
             * @returns {gauge.messages.ScenarioInfo} ScenarioInfo instance
             */
            ScenarioInfo.create = function create(properties) {
                return new ScenarioInfo(properties);
            };

            /**
             * Encodes the specified ScenarioInfo message. Does not implicitly {@link gauge.messages.ScenarioInfo.verify|verify} messages.
             * @function encode
             * @memberof gauge.messages.ScenarioInfo
             * @static
             * @param {gauge.messages.IScenarioInfo} message ScenarioInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ScenarioInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && message.hasOwnProperty("name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.isFailed != null && message.hasOwnProperty("isFailed"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.isFailed);
                if (message.tags != null && message.tags.length)
                    for (var i = 0; i < message.tags.length; ++i)
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.tags[i]);
                return writer;
            };

            /**
             * Encodes the specified ScenarioInfo message, length delimited. Does not implicitly {@link gauge.messages.ScenarioInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gauge.messages.ScenarioInfo
             * @static
             * @param {gauge.messages.IScenarioInfo} message ScenarioInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ScenarioInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ScenarioInfo message from the specified reader or buffer.
             * @function decode
             * @memberof gauge.messages.ScenarioInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gauge.messages.ScenarioInfo} ScenarioInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ScenarioInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gauge.messages.ScenarioInfo();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        message.isFailed = reader.bool();
                        break;
                    case 3:
                        if (!(message.tags && message.tags.length))
                            message.tags = [];
                        message.tags.push(reader.string());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ScenarioInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gauge.messages.ScenarioInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gauge.messages.ScenarioInfo} ScenarioInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ScenarioInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ScenarioInfo message.
             * @function verify
             * @memberof gauge.messages.ScenarioInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ScenarioInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.isFailed != null && message.hasOwnProperty("isFailed"))
                    if (typeof message.isFailed !== "boolean")
                        return "isFailed: boolean expected";
                if (message.tags != null && message.hasOwnProperty("tags")) {
                    if (!Array.isArray(message.tags))
                        return "tags: array expected";
                    for (var i = 0; i < message.tags.length; ++i)
                        if (!$util.isString(message.tags[i]))
                            return "tags: string[] expected";
                }
                return null;
            };

            /**
             * Creates a ScenarioInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gauge.messages.ScenarioInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gauge.messages.ScenarioInfo} ScenarioInfo
             */
            ScenarioInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.gauge.messages.ScenarioInfo)
                    return object;
                var message = new $root.gauge.messages.ScenarioInfo();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.isFailed != null)
                    message.isFailed = Boolean(object.isFailed);
                if (object.tags) {
                    if (!Array.isArray(object.tags))
                        throw TypeError(".gauge.messages.ScenarioInfo.tags: array expected");
                    message.tags = [];
                    for (var i = 0; i < object.tags.length; ++i)
                        message.tags[i] = String(object.tags[i]);
                }
                return message;
            };

            /**
             * Creates a plain object from a ScenarioInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gauge.messages.ScenarioInfo
             * @static
             * @param {gauge.messages.ScenarioInfo} message ScenarioInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ScenarioInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.tags = [];
                if (options.defaults) {
                    object.name = "";
                    object.isFailed = false;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.isFailed != null && message.hasOwnProperty("isFailed"))
                    object.isFailed = message.isFailed;
                if (message.tags && message.tags.length) {
                    object.tags = [];
                    for (var j = 0; j < message.tags.length; ++j)
                        object.tags[j] = message.tags[j];
                }
                return object;
            };

            /**
             * Converts this ScenarioInfo to JSON.
             * @function toJSON
             * @memberof gauge.messages.ScenarioInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ScenarioInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ScenarioInfo;
        })();

        messages.StepInfo = (function() {

            /**
             * Properties of a StepInfo.
             * @memberof gauge.messages
             * @interface IStepInfo
             * @property {gauge.messages.IExecuteStepRequest|null} [step] The current request to execute Step
             * @property {boolean|null} [isFailed] Flag to indicate if the current Step execution failed.
             * @property {string|null} [stackTrace] The current stack trace in case of failure
             * @property {string|null} [errorMessage] The error message in case of failure
             */

            /**
             * Constructs a new StepInfo.
             * @memberof gauge.messages
             * @classdesc Contains details of the Step execution.
             * @implements IStepInfo
             * @constructor
             * @param {gauge.messages.IStepInfo=} [properties] Properties to set
             */
            function StepInfo(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * The current request to execute Step
             * @member {gauge.messages.IExecuteStepRequest|null|undefined} step
             * @memberof gauge.messages.StepInfo
             * @instance
             */
            StepInfo.prototype.step = null;

            /**
             * Flag to indicate if the current Step execution failed.
             * @member {boolean} isFailed
             * @memberof gauge.messages.StepInfo
             * @instance
             */
            StepInfo.prototype.isFailed = false;

            /**
             * The current stack trace in case of failure
             * @member {string} stackTrace
             * @memberof gauge.messages.StepInfo
             * @instance
             */
            StepInfo.prototype.stackTrace = "";

            /**
             * The error message in case of failure
             * @member {string} errorMessage
             * @memberof gauge.messages.StepInfo
             * @instance
             */
            StepInfo.prototype.errorMessage = "";

            /**
             * Creates a new StepInfo instance using the specified properties.
             * @function create
             * @memberof gauge.messages.StepInfo
             * @static
             * @param {gauge.messages.IStepInfo=} [properties] Properties to set
             * @returns {gauge.messages.StepInfo} StepInfo instance
             */
            StepInfo.create = function create(properties) {
                return new StepInfo(properties);
            };

            /**
             * Encodes the specified StepInfo message. Does not implicitly {@link gauge.messages.StepInfo.verify|verify} messages.
             * @function encode
             * @memberof gauge.messages.StepInfo
             * @static
             * @param {gauge.messages.IStepInfo} message StepInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StepInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.step != null && message.hasOwnProperty("step"))
                    $root.gauge.messages.ExecuteStepRequest.encode(message.step, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.isFailed != null && message.hasOwnProperty("isFailed"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.isFailed);
                if (message.stackTrace != null && message.hasOwnProperty("stackTrace"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.stackTrace);
                if (message.errorMessage != null && message.hasOwnProperty("errorMessage"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.errorMessage);
                return writer;
            };

            /**
             * Encodes the specified StepInfo message, length delimited. Does not implicitly {@link gauge.messages.StepInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gauge.messages.StepInfo
             * @static
             * @param {gauge.messages.IStepInfo} message StepInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StepInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a StepInfo message from the specified reader or buffer.
             * @function decode
             * @memberof gauge.messages.StepInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gauge.messages.StepInfo} StepInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StepInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gauge.messages.StepInfo();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.step = $root.gauge.messages.ExecuteStepRequest.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.isFailed = reader.bool();
                        break;
                    case 3:
                        message.stackTrace = reader.string();
                        break;
                    case 4:
                        message.errorMessage = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a StepInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gauge.messages.StepInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gauge.messages.StepInfo} StepInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StepInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a StepInfo message.
             * @function verify
             * @memberof gauge.messages.StepInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            StepInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.step != null && message.hasOwnProperty("step")) {
                    var error = $root.gauge.messages.ExecuteStepRequest.verify(message.step);
                    if (error)
                        return "step." + error;
                }
                if (message.isFailed != null && message.hasOwnProperty("isFailed"))
                    if (typeof message.isFailed !== "boolean")
                        return "isFailed: boolean expected";
                if (message.stackTrace != null && message.hasOwnProperty("stackTrace"))
                    if (!$util.isString(message.stackTrace))
                        return "stackTrace: string expected";
                if (message.errorMessage != null && message.hasOwnProperty("errorMessage"))
                    if (!$util.isString(message.errorMessage))
                        return "errorMessage: string expected";
                return null;
            };

            /**
             * Creates a StepInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gauge.messages.StepInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gauge.messages.StepInfo} StepInfo
             */
            StepInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.gauge.messages.StepInfo)
                    return object;
                var message = new $root.gauge.messages.StepInfo();
                if (object.step != null) {
                    if (typeof object.step !== "object")
                        throw TypeError(".gauge.messages.StepInfo.step: object expected");
                    message.step = $root.gauge.messages.ExecuteStepRequest.fromObject(object.step);
                }
                if (object.isFailed != null)
                    message.isFailed = Boolean(object.isFailed);
                if (object.stackTrace != null)
                    message.stackTrace = String(object.stackTrace);
                if (object.errorMessage != null)
                    message.errorMessage = String(object.errorMessage);
                return message;
            };

            /**
             * Creates a plain object from a StepInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gauge.messages.StepInfo
             * @static
             * @param {gauge.messages.StepInfo} message StepInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            StepInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.step = null;
                    object.isFailed = false;
                    object.stackTrace = "";
                    object.errorMessage = "";
                }
                if (message.step != null && message.hasOwnProperty("step"))
                    object.step = $root.gauge.messages.ExecuteStepRequest.toObject(message.step, options);
                if (message.isFailed != null && message.hasOwnProperty("isFailed"))
                    object.isFailed = message.isFailed;
                if (message.stackTrace != null && message.hasOwnProperty("stackTrace"))
                    object.stackTrace = message.stackTrace;
                if (message.errorMessage != null && message.hasOwnProperty("errorMessage"))
                    object.errorMessage = message.errorMessage;
                return object;
            };

            /**
             * Converts this StepInfo to JSON.
             * @function toJSON
             * @memberof gauge.messages.StepInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            StepInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return StepInfo;
        })();

        messages.ExecuteStepRequest = (function() {

            /**
             * Properties of an ExecuteStepRequest.
             * @memberof gauge.messages
             * @interface IExecuteStepRequest
             * @property {string|null} [actualStepText] This contains the parameters as defined in the Spec.
             * @property {string|null} [parsedStepText] The paramters are replaced with placeholders.
             * @property {boolean|null} [scenarioFailing] Flag to indicate if the execution of the Scenario, containing the current Step, failed.
             * @property {Array.<gauge.messages.IParameter>|null} [parameters] Collection of parameters applicable to the current Step.
             * @property {number|null} [stream] ExecuteStepRequest stream
             */

            /**
             * Constructs a new ExecuteStepRequest.
             * @memberof gauge.messages
             * @classdesc Request sent ot the runner to Execute a Step
             * @implements IExecuteStepRequest
             * @constructor
             * @param {gauge.messages.IExecuteStepRequest=} [properties] Properties to set
             */
            function ExecuteStepRequest(properties) {
                this.parameters = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * This contains the parameters as defined in the Spec.
             * @member {string} actualStepText
             * @memberof gauge.messages.ExecuteStepRequest
             * @instance
             */
            ExecuteStepRequest.prototype.actualStepText = "";

            /**
             * The paramters are replaced with placeholders.
             * @member {string} parsedStepText
             * @memberof gauge.messages.ExecuteStepRequest
             * @instance
             */
            ExecuteStepRequest.prototype.parsedStepText = "";

            /**
             * Flag to indicate if the execution of the Scenario, containing the current Step, failed.
             * @member {boolean} scenarioFailing
             * @memberof gauge.messages.ExecuteStepRequest
             * @instance
             */
            ExecuteStepRequest.prototype.scenarioFailing = false;

            /**
             * Collection of parameters applicable to the current Step.
             * @member {Array.<gauge.messages.IParameter>} parameters
             * @memberof gauge.messages.ExecuteStepRequest
             * @instance
             */
            ExecuteStepRequest.prototype.parameters = $util.emptyArray;

            /**
             * ExecuteStepRequest stream.
             * @member {number} stream
             * @memberof gauge.messages.ExecuteStepRequest
             * @instance
             */
            ExecuteStepRequest.prototype.stream = 0;

            /**
             * Creates a new ExecuteStepRequest instance using the specified properties.
             * @function create
             * @memberof gauge.messages.ExecuteStepRequest
             * @static
             * @param {gauge.messages.IExecuteStepRequest=} [properties] Properties to set
             * @returns {gauge.messages.ExecuteStepRequest} ExecuteStepRequest instance
             */
            ExecuteStepRequest.create = function create(properties) {
                return new ExecuteStepRequest(properties);
            };

            /**
             * Encodes the specified ExecuteStepRequest message. Does not implicitly {@link gauge.messages.ExecuteStepRequest.verify|verify} messages.
             * @function encode
             * @memberof gauge.messages.ExecuteStepRequest
             * @static
             * @param {gauge.messages.IExecuteStepRequest} message ExecuteStepRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExecuteStepRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.actualStepText != null && message.hasOwnProperty("actualStepText"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.actualStepText);
                if (message.parsedStepText != null && message.hasOwnProperty("parsedStepText"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.parsedStepText);
                if (message.scenarioFailing != null && message.hasOwnProperty("scenarioFailing"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.scenarioFailing);
                if (message.parameters != null && message.parameters.length)
                    for (var i = 0; i < message.parameters.length; ++i)
                        $root.gauge.messages.Parameter.encode(message.parameters[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.stream != null && message.hasOwnProperty("stream"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int32(message.stream);
                return writer;
            };

            /**
             * Encodes the specified ExecuteStepRequest message, length delimited. Does not implicitly {@link gauge.messages.ExecuteStepRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gauge.messages.ExecuteStepRequest
             * @static
             * @param {gauge.messages.IExecuteStepRequest} message ExecuteStepRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExecuteStepRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an ExecuteStepRequest message from the specified reader or buffer.
             * @function decode
             * @memberof gauge.messages.ExecuteStepRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gauge.messages.ExecuteStepRequest} ExecuteStepRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExecuteStepRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gauge.messages.ExecuteStepRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.actualStepText = reader.string();
                        break;
                    case 2:
                        message.parsedStepText = reader.string();
                        break;
                    case 3:
                        message.scenarioFailing = reader.bool();
                        break;
                    case 4:
                        if (!(message.parameters && message.parameters.length))
                            message.parameters = [];
                        message.parameters.push($root.gauge.messages.Parameter.decode(reader, reader.uint32()));
                        break;
                    case 5:
                        message.stream = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an ExecuteStepRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gauge.messages.ExecuteStepRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gauge.messages.ExecuteStepRequest} ExecuteStepRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExecuteStepRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an ExecuteStepRequest message.
             * @function verify
             * @memberof gauge.messages.ExecuteStepRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ExecuteStepRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.actualStepText != null && message.hasOwnProperty("actualStepText"))
                    if (!$util.isString(message.actualStepText))
                        return "actualStepText: string expected";
                if (message.parsedStepText != null && message.hasOwnProperty("parsedStepText"))
                    if (!$util.isString(message.parsedStepText))
                        return "parsedStepText: string expected";
                if (message.scenarioFailing != null && message.hasOwnProperty("scenarioFailing"))
                    if (typeof message.scenarioFailing !== "boolean")
                        return "scenarioFailing: boolean expected";
                if (message.parameters != null && message.hasOwnProperty("parameters")) {
                    if (!Array.isArray(message.parameters))
                        return "parameters: array expected";
                    for (var i = 0; i < message.parameters.length; ++i) {
                        var error = $root.gauge.messages.Parameter.verify(message.parameters[i]);
                        if (error)
                            return "parameters." + error;
                    }
                }
                if (message.stream != null && message.hasOwnProperty("stream"))
                    if (!$util.isInteger(message.stream))
                        return "stream: integer expected";
                return null;
            };

            /**
             * Creates an ExecuteStepRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gauge.messages.ExecuteStepRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gauge.messages.ExecuteStepRequest} ExecuteStepRequest
             */
            ExecuteStepRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.gauge.messages.ExecuteStepRequest)
                    return object;
                var message = new $root.gauge.messages.ExecuteStepRequest();
                if (object.actualStepText != null)
                    message.actualStepText = String(object.actualStepText);
                if (object.parsedStepText != null)
                    message.parsedStepText = String(object.parsedStepText);
                if (object.scenarioFailing != null)
                    message.scenarioFailing = Boolean(object.scenarioFailing);
                if (object.parameters) {
                    if (!Array.isArray(object.parameters))
                        throw TypeError(".gauge.messages.ExecuteStepRequest.parameters: array expected");
                    message.parameters = [];
                    for (var i = 0; i < object.parameters.length; ++i) {
                        if (typeof object.parameters[i] !== "object")
                            throw TypeError(".gauge.messages.ExecuteStepRequest.parameters: object expected");
                        message.parameters[i] = $root.gauge.messages.Parameter.fromObject(object.parameters[i]);
                    }
                }
                if (object.stream != null)
                    message.stream = object.stream | 0;
                return message;
            };

            /**
             * Creates a plain object from an ExecuteStepRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gauge.messages.ExecuteStepRequest
             * @static
             * @param {gauge.messages.ExecuteStepRequest} message ExecuteStepRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ExecuteStepRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.parameters = [];
                if (options.defaults) {
                    object.actualStepText = "";
                    object.parsedStepText = "";
                    object.scenarioFailing = false;
                    object.stream = 0;
                }
                if (message.actualStepText != null && message.hasOwnProperty("actualStepText"))
                    object.actualStepText = message.actualStepText;
                if (message.parsedStepText != null && message.hasOwnProperty("parsedStepText"))
                    object.parsedStepText = message.parsedStepText;
                if (message.scenarioFailing != null && message.hasOwnProperty("scenarioFailing"))
                    object.scenarioFailing = message.scenarioFailing;
                if (message.parameters && message.parameters.length) {
                    object.parameters = [];
                    for (var j = 0; j < message.parameters.length; ++j)
                        object.parameters[j] = $root.gauge.messages.Parameter.toObject(message.parameters[j], options);
                }
                if (message.stream != null && message.hasOwnProperty("stream"))
                    object.stream = message.stream;
                return object;
            };

            /**
             * Converts this ExecuteStepRequest to JSON.
             * @function toJSON
             * @memberof gauge.messages.ExecuteStepRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ExecuteStepRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ExecuteStepRequest;
        })();

        messages.StepValidateRequest = (function() {

            /**
             * Properties of a StepValidateRequest.
             * @memberof gauge.messages
             * @interface IStepValidateRequest
             * @property {string|null} [stepText] The text is used to lookup Step implementation
             * @property {number|null} [numberOfParameters] The number of paramters in the Step
             * @property {gauge.messages.IProtoStepValue|null} [stepValue] This is use to generate step implementation template
             */

            /**
             * Constructs a new StepValidateRequest.
             * @memberof gauge.messages
             * @classdesc The runner should check if there is an implementation defined for the given Step Text.
             * @implements IStepValidateRequest
             * @constructor
             * @param {gauge.messages.IStepValidateRequest=} [properties] Properties to set
             */
            function StepValidateRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * The text is used to lookup Step implementation
             * @member {string} stepText
             * @memberof gauge.messages.StepValidateRequest
             * @instance
             */
            StepValidateRequest.prototype.stepText = "";

            /**
             * The number of paramters in the Step
             * @member {number} numberOfParameters
             * @memberof gauge.messages.StepValidateRequest
             * @instance
             */
            StepValidateRequest.prototype.numberOfParameters = 0;

            /**
             * This is use to generate step implementation template
             * @member {gauge.messages.IProtoStepValue|null|undefined} stepValue
             * @memberof gauge.messages.StepValidateRequest
             * @instance
             */
            StepValidateRequest.prototype.stepValue = null;

            /**
             * Creates a new StepValidateRequest instance using the specified properties.
             * @function create
             * @memberof gauge.messages.StepValidateRequest
             * @static
             * @param {gauge.messages.IStepValidateRequest=} [properties] Properties to set
             * @returns {gauge.messages.StepValidateRequest} StepValidateRequest instance
             */
            StepValidateRequest.create = function create(properties) {
                return new StepValidateRequest(properties);
            };

            /**
             * Encodes the specified StepValidateRequest message. Does not implicitly {@link gauge.messages.StepValidateRequest.verify|verify} messages.
             * @function encode
             * @memberof gauge.messages.StepValidateRequest
             * @static
             * @param {gauge.messages.IStepValidateRequest} message StepValidateRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StepValidateRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.stepText != null && message.hasOwnProperty("stepText"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.stepText);
                if (message.numberOfParameters != null && message.hasOwnProperty("numberOfParameters"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.numberOfParameters);
                if (message.stepValue != null && message.hasOwnProperty("stepValue"))
                    $root.gauge.messages.ProtoStepValue.encode(message.stepValue, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified StepValidateRequest message, length delimited. Does not implicitly {@link gauge.messages.StepValidateRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gauge.messages.StepValidateRequest
             * @static
             * @param {gauge.messages.IStepValidateRequest} message StepValidateRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StepValidateRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a StepValidateRequest message from the specified reader or buffer.
             * @function decode
             * @memberof gauge.messages.StepValidateRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gauge.messages.StepValidateRequest} StepValidateRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StepValidateRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gauge.messages.StepValidateRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.stepText = reader.string();
                        break;
                    case 2:
                        message.numberOfParameters = reader.int32();
                        break;
                    case 3:
                        message.stepValue = $root.gauge.messages.ProtoStepValue.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a StepValidateRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gauge.messages.StepValidateRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gauge.messages.StepValidateRequest} StepValidateRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StepValidateRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a StepValidateRequest message.
             * @function verify
             * @memberof gauge.messages.StepValidateRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            StepValidateRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.stepText != null && message.hasOwnProperty("stepText"))
                    if (!$util.isString(message.stepText))
                        return "stepText: string expected";
                if (message.numberOfParameters != null && message.hasOwnProperty("numberOfParameters"))
                    if (!$util.isInteger(message.numberOfParameters))
                        return "numberOfParameters: integer expected";
                if (message.stepValue != null && message.hasOwnProperty("stepValue")) {
                    var error = $root.gauge.messages.ProtoStepValue.verify(message.stepValue);
                    if (error)
                        return "stepValue." + error;
                }
                return null;
            };

            /**
             * Creates a StepValidateRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gauge.messages.StepValidateRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gauge.messages.StepValidateRequest} StepValidateRequest
             */
            StepValidateRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.gauge.messages.StepValidateRequest)
                    return object;
                var message = new $root.gauge.messages.StepValidateRequest();
                if (object.stepText != null)
                    message.stepText = String(object.stepText);
                if (object.numberOfParameters != null)
                    message.numberOfParameters = object.numberOfParameters | 0;
                if (object.stepValue != null) {
                    if (typeof object.stepValue !== "object")
                        throw TypeError(".gauge.messages.StepValidateRequest.stepValue: object expected");
                    message.stepValue = $root.gauge.messages.ProtoStepValue.fromObject(object.stepValue);
                }
                return message;
            };

            /**
             * Creates a plain object from a StepValidateRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gauge.messages.StepValidateRequest
             * @static
             * @param {gauge.messages.StepValidateRequest} message StepValidateRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            StepValidateRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.stepText = "";
                    object.numberOfParameters = 0;
                    object.stepValue = null;
                }
                if (message.stepText != null && message.hasOwnProperty("stepText"))
                    object.stepText = message.stepText;
                if (message.numberOfParameters != null && message.hasOwnProperty("numberOfParameters"))
                    object.numberOfParameters = message.numberOfParameters;
                if (message.stepValue != null && message.hasOwnProperty("stepValue"))
                    object.stepValue = $root.gauge.messages.ProtoStepValue.toObject(message.stepValue, options);
                return object;
            };

            /**
             * Converts this StepValidateRequest to JSON.
             * @function toJSON
             * @memberof gauge.messages.StepValidateRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            StepValidateRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return StepValidateRequest;
        })();

        messages.StepValidateResponse = (function() {

            /**
             * Properties of a StepValidateResponse.
             * @memberof gauge.messages
             * @interface IStepValidateResponse
             * @property {boolean|null} [isValid] StepValidateResponse isValid
             * @property {string|null} [errorMessage] StepValidateResponse errorMessage
             * @property {gauge.messages.StepValidateResponse.ErrorType|null} [errorType] StepValidateResponse errorType
             * @property {string|null} [suggestion] StepValidateResponse suggestion
             */

            /**
             * Constructs a new StepValidateResponse.
             * @memberof gauge.messages
             * @classdesc Returns an error message if it is an error response.
             * @implements IStepValidateResponse
             * @constructor
             * @param {gauge.messages.IStepValidateResponse=} [properties] Properties to set
             */
            function StepValidateResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * StepValidateResponse isValid.
             * @member {boolean} isValid
             * @memberof gauge.messages.StepValidateResponse
             * @instance
             */
            StepValidateResponse.prototype.isValid = false;

            /**
             * StepValidateResponse errorMessage.
             * @member {string} errorMessage
             * @memberof gauge.messages.StepValidateResponse
             * @instance
             */
            StepValidateResponse.prototype.errorMessage = "";

            /**
             * StepValidateResponse errorType.
             * @member {gauge.messages.StepValidateResponse.ErrorType} errorType
             * @memberof gauge.messages.StepValidateResponse
             * @instance
             */
            StepValidateResponse.prototype.errorType = 0;

            /**
             * StepValidateResponse suggestion.
             * @member {string} suggestion
             * @memberof gauge.messages.StepValidateResponse
             * @instance
             */
            StepValidateResponse.prototype.suggestion = "";

            /**
             * Creates a new StepValidateResponse instance using the specified properties.
             * @function create
             * @memberof gauge.messages.StepValidateResponse
             * @static
             * @param {gauge.messages.IStepValidateResponse=} [properties] Properties to set
             * @returns {gauge.messages.StepValidateResponse} StepValidateResponse instance
             */
            StepValidateResponse.create = function create(properties) {
                return new StepValidateResponse(properties);
            };

            /**
             * Encodes the specified StepValidateResponse message. Does not implicitly {@link gauge.messages.StepValidateResponse.verify|verify} messages.
             * @function encode
             * @memberof gauge.messages.StepValidateResponse
             * @static
             * @param {gauge.messages.IStepValidateResponse} message StepValidateResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StepValidateResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.isValid != null && message.hasOwnProperty("isValid"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.isValid);
                if (message.errorMessage != null && message.hasOwnProperty("errorMessage"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.errorMessage);
                if (message.errorType != null && message.hasOwnProperty("errorType"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.errorType);
                if (message.suggestion != null && message.hasOwnProperty("suggestion"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.suggestion);
                return writer;
            };

            /**
             * Encodes the specified StepValidateResponse message, length delimited. Does not implicitly {@link gauge.messages.StepValidateResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gauge.messages.StepValidateResponse
             * @static
             * @param {gauge.messages.IStepValidateResponse} message StepValidateResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StepValidateResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a StepValidateResponse message from the specified reader or buffer.
             * @function decode
             * @memberof gauge.messages.StepValidateResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gauge.messages.StepValidateResponse} StepValidateResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StepValidateResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gauge.messages.StepValidateResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.isValid = reader.bool();
                        break;
                    case 2:
                        message.errorMessage = reader.string();
                        break;
                    case 3:
                        message.errorType = reader.int32();
                        break;
                    case 4:
                        message.suggestion = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a StepValidateResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gauge.messages.StepValidateResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gauge.messages.StepValidateResponse} StepValidateResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StepValidateResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a StepValidateResponse message.
             * @function verify
             * @memberof gauge.messages.StepValidateResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            StepValidateResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.isValid != null && message.hasOwnProperty("isValid"))
                    if (typeof message.isValid !== "boolean")
                        return "isValid: boolean expected";
                if (message.errorMessage != null && message.hasOwnProperty("errorMessage"))
                    if (!$util.isString(message.errorMessage))
                        return "errorMessage: string expected";
                if (message.errorType != null && message.hasOwnProperty("errorType"))
                    switch (message.errorType) {
                    default:
                        return "errorType: enum value expected";
                    case 0:
                    case 1:
                        break;
                    }
                if (message.suggestion != null && message.hasOwnProperty("suggestion"))
                    if (!$util.isString(message.suggestion))
                        return "suggestion: string expected";
                return null;
            };

            /**
             * Creates a StepValidateResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gauge.messages.StepValidateResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gauge.messages.StepValidateResponse} StepValidateResponse
             */
            StepValidateResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.gauge.messages.StepValidateResponse)
                    return object;
                var message = new $root.gauge.messages.StepValidateResponse();
                if (object.isValid != null)
                    message.isValid = Boolean(object.isValid);
                if (object.errorMessage != null)
                    message.errorMessage = String(object.errorMessage);
                switch (object.errorType) {
                case "STEP_IMPLEMENTATION_NOT_FOUND":
                case 0:
                    message.errorType = 0;
                    break;
                case "DUPLICATE_STEP_IMPLEMENTATION":
                case 1:
                    message.errorType = 1;
                    break;
                }
                if (object.suggestion != null)
                    message.suggestion = String(object.suggestion);
                return message;
            };

            /**
             * Creates a plain object from a StepValidateResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gauge.messages.StepValidateResponse
             * @static
             * @param {gauge.messages.StepValidateResponse} message StepValidateResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            StepValidateResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.isValid = false;
                    object.errorMessage = "";
                    object.errorType = options.enums === String ? "STEP_IMPLEMENTATION_NOT_FOUND" : 0;
                    object.suggestion = "";
                }
                if (message.isValid != null && message.hasOwnProperty("isValid"))
                    object.isValid = message.isValid;
                if (message.errorMessage != null && message.hasOwnProperty("errorMessage"))
                    object.errorMessage = message.errorMessage;
                if (message.errorType != null && message.hasOwnProperty("errorType"))
                    object.errorType = options.enums === String ? $root.gauge.messages.StepValidateResponse.ErrorType[message.errorType] : message.errorType;
                if (message.suggestion != null && message.hasOwnProperty("suggestion"))
                    object.suggestion = message.suggestion;
                return object;
            };

            /**
             * Converts this StepValidateResponse to JSON.
             * @function toJSON
             * @memberof gauge.messages.StepValidateResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            StepValidateResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * ErrorType enum.
             * @name gauge.messages.StepValidateResponse.ErrorType
             * @enum {string}
             * @property {number} STEP_IMPLEMENTATION_NOT_FOUND=0 STEP_IMPLEMENTATION_NOT_FOUND value
             * @property {number} DUPLICATE_STEP_IMPLEMENTATION=1 DUPLICATE_STEP_IMPLEMENTATION value
             */
            StepValidateResponse.ErrorType = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "STEP_IMPLEMENTATION_NOT_FOUND"] = 0;
                values[valuesById[1] = "DUPLICATE_STEP_IMPLEMENTATION"] = 1;
                return values;
            })();

            return StepValidateResponse;
        })();

        messages.SuiteExecutionResult = (function() {

            /**
             * Properties of a SuiteExecutionResult.
             * @memberof gauge.messages
             * @interface ISuiteExecutionResult
             * @property {gauge.messages.IProtoSuiteResult|null} [suiteResult] SuiteExecutionResult suiteResult
             */

            /**
             * Constructs a new SuiteExecutionResult.
             * @memberof gauge.messages
             * @classdesc Result of the Suite Execution.
             * @implements ISuiteExecutionResult
             * @constructor
             * @param {gauge.messages.ISuiteExecutionResult=} [properties] Properties to set
             */
            function SuiteExecutionResult(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SuiteExecutionResult suiteResult.
             * @member {gauge.messages.IProtoSuiteResult|null|undefined} suiteResult
             * @memberof gauge.messages.SuiteExecutionResult
             * @instance
             */
            SuiteExecutionResult.prototype.suiteResult = null;

            /**
             * Creates a new SuiteExecutionResult instance using the specified properties.
             * @function create
             * @memberof gauge.messages.SuiteExecutionResult
             * @static
             * @param {gauge.messages.ISuiteExecutionResult=} [properties] Properties to set
             * @returns {gauge.messages.SuiteExecutionResult} SuiteExecutionResult instance
             */
            SuiteExecutionResult.create = function create(properties) {
                return new SuiteExecutionResult(properties);
            };

            /**
             * Encodes the specified SuiteExecutionResult message. Does not implicitly {@link gauge.messages.SuiteExecutionResult.verify|verify} messages.
             * @function encode
             * @memberof gauge.messages.SuiteExecutionResult
             * @static
             * @param {gauge.messages.ISuiteExecutionResult} message SuiteExecutionResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SuiteExecutionResult.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.suiteResult != null && message.hasOwnProperty("suiteResult"))
                    $root.gauge.messages.ProtoSuiteResult.encode(message.suiteResult, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified SuiteExecutionResult message, length delimited. Does not implicitly {@link gauge.messages.SuiteExecutionResult.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gauge.messages.SuiteExecutionResult
             * @static
             * @param {gauge.messages.ISuiteExecutionResult} message SuiteExecutionResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SuiteExecutionResult.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SuiteExecutionResult message from the specified reader or buffer.
             * @function decode
             * @memberof gauge.messages.SuiteExecutionResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gauge.messages.SuiteExecutionResult} SuiteExecutionResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SuiteExecutionResult.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gauge.messages.SuiteExecutionResult();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.suiteResult = $root.gauge.messages.ProtoSuiteResult.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SuiteExecutionResult message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gauge.messages.SuiteExecutionResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gauge.messages.SuiteExecutionResult} SuiteExecutionResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SuiteExecutionResult.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SuiteExecutionResult message.
             * @function verify
             * @memberof gauge.messages.SuiteExecutionResult
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SuiteExecutionResult.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.suiteResult != null && message.hasOwnProperty("suiteResult")) {
                    var error = $root.gauge.messages.ProtoSuiteResult.verify(message.suiteResult);
                    if (error)
                        return "suiteResult." + error;
                }
                return null;
            };

            /**
             * Creates a SuiteExecutionResult message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gauge.messages.SuiteExecutionResult
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gauge.messages.SuiteExecutionResult} SuiteExecutionResult
             */
            SuiteExecutionResult.fromObject = function fromObject(object) {
                if (object instanceof $root.gauge.messages.SuiteExecutionResult)
                    return object;
                var message = new $root.gauge.messages.SuiteExecutionResult();
                if (object.suiteResult != null) {
                    if (typeof object.suiteResult !== "object")
                        throw TypeError(".gauge.messages.SuiteExecutionResult.suiteResult: object expected");
                    message.suiteResult = $root.gauge.messages.ProtoSuiteResult.fromObject(object.suiteResult);
                }
                return message;
            };

            /**
             * Creates a plain object from a SuiteExecutionResult message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gauge.messages.SuiteExecutionResult
             * @static
             * @param {gauge.messages.SuiteExecutionResult} message SuiteExecutionResult
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SuiteExecutionResult.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.suiteResult = null;
                if (message.suiteResult != null && message.hasOwnProperty("suiteResult"))
                    object.suiteResult = $root.gauge.messages.ProtoSuiteResult.toObject(message.suiteResult, options);
                return object;
            };

            /**
             * Converts this SuiteExecutionResult to JSON.
             * @function toJSON
             * @memberof gauge.messages.SuiteExecutionResult
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SuiteExecutionResult.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return SuiteExecutionResult;
        })();

        messages.SuiteExecutionResultItem = (function() {

            /**
             * Properties of a SuiteExecutionResultItem.
             * @memberof gauge.messages
             * @interface ISuiteExecutionResultItem
             * @property {gauge.messages.IProtoItem|null} [resultItem] SuiteExecutionResultItem resultItem
             */

            /**
             * Constructs a new SuiteExecutionResultItem.
             * @memberof gauge.messages
             * @classdesc Represents a SuiteExecutionResultItem.
             * @implements ISuiteExecutionResultItem
             * @constructor
             * @param {gauge.messages.ISuiteExecutionResultItem=} [properties] Properties to set
             */
            function SuiteExecutionResultItem(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SuiteExecutionResultItem resultItem.
             * @member {gauge.messages.IProtoItem|null|undefined} resultItem
             * @memberof gauge.messages.SuiteExecutionResultItem
             * @instance
             */
            SuiteExecutionResultItem.prototype.resultItem = null;

            /**
             * Creates a new SuiteExecutionResultItem instance using the specified properties.
             * @function create
             * @memberof gauge.messages.SuiteExecutionResultItem
             * @static
             * @param {gauge.messages.ISuiteExecutionResultItem=} [properties] Properties to set
             * @returns {gauge.messages.SuiteExecutionResultItem} SuiteExecutionResultItem instance
             */
            SuiteExecutionResultItem.create = function create(properties) {
                return new SuiteExecutionResultItem(properties);
            };

            /**
             * Encodes the specified SuiteExecutionResultItem message. Does not implicitly {@link gauge.messages.SuiteExecutionResultItem.verify|verify} messages.
             * @function encode
             * @memberof gauge.messages.SuiteExecutionResultItem
             * @static
             * @param {gauge.messages.ISuiteExecutionResultItem} message SuiteExecutionResultItem message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SuiteExecutionResultItem.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.resultItem != null && message.hasOwnProperty("resultItem"))
                    $root.gauge.messages.ProtoItem.encode(message.resultItem, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified SuiteExecutionResultItem message, length delimited. Does not implicitly {@link gauge.messages.SuiteExecutionResultItem.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gauge.messages.SuiteExecutionResultItem
             * @static
             * @param {gauge.messages.ISuiteExecutionResultItem} message SuiteExecutionResultItem message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SuiteExecutionResultItem.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SuiteExecutionResultItem message from the specified reader or buffer.
             * @function decode
             * @memberof gauge.messages.SuiteExecutionResultItem
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gauge.messages.SuiteExecutionResultItem} SuiteExecutionResultItem
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SuiteExecutionResultItem.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gauge.messages.SuiteExecutionResultItem();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.resultItem = $root.gauge.messages.ProtoItem.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SuiteExecutionResultItem message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gauge.messages.SuiteExecutionResultItem
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gauge.messages.SuiteExecutionResultItem} SuiteExecutionResultItem
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SuiteExecutionResultItem.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SuiteExecutionResultItem message.
             * @function verify
             * @memberof gauge.messages.SuiteExecutionResultItem
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SuiteExecutionResultItem.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.resultItem != null && message.hasOwnProperty("resultItem")) {
                    var error = $root.gauge.messages.ProtoItem.verify(message.resultItem);
                    if (error)
                        return "resultItem." + error;
                }
                return null;
            };

            /**
             * Creates a SuiteExecutionResultItem message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gauge.messages.SuiteExecutionResultItem
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gauge.messages.SuiteExecutionResultItem} SuiteExecutionResultItem
             */
            SuiteExecutionResultItem.fromObject = function fromObject(object) {
                if (object instanceof $root.gauge.messages.SuiteExecutionResultItem)
                    return object;
                var message = new $root.gauge.messages.SuiteExecutionResultItem();
                if (object.resultItem != null) {
                    if (typeof object.resultItem !== "object")
                        throw TypeError(".gauge.messages.SuiteExecutionResultItem.resultItem: object expected");
                    message.resultItem = $root.gauge.messages.ProtoItem.fromObject(object.resultItem);
                }
                return message;
            };

            /**
             * Creates a plain object from a SuiteExecutionResultItem message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gauge.messages.SuiteExecutionResultItem
             * @static
             * @param {gauge.messages.SuiteExecutionResultItem} message SuiteExecutionResultItem
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SuiteExecutionResultItem.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.resultItem = null;
                if (message.resultItem != null && message.hasOwnProperty("resultItem"))
                    object.resultItem = $root.gauge.messages.ProtoItem.toObject(message.resultItem, options);
                return object;
            };

            /**
             * Converts this SuiteExecutionResultItem to JSON.
             * @function toJSON
             * @memberof gauge.messages.SuiteExecutionResultItem
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SuiteExecutionResultItem.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return SuiteExecutionResultItem;
        })();

        messages.StepNamesRequest = (function() {

            /**
             * Properties of a StepNamesRequest.
             * @memberof gauge.messages
             * @interface IStepNamesRequest
             */

            /**
             * Constructs a new StepNamesRequest.
             * @memberof gauge.messages
             * @classdesc Requests Gauge to give all Step Names.
             * @implements IStepNamesRequest
             * @constructor
             * @param {gauge.messages.IStepNamesRequest=} [properties] Properties to set
             */
            function StepNamesRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new StepNamesRequest instance using the specified properties.
             * @function create
             * @memberof gauge.messages.StepNamesRequest
             * @static
             * @param {gauge.messages.IStepNamesRequest=} [properties] Properties to set
             * @returns {gauge.messages.StepNamesRequest} StepNamesRequest instance
             */
            StepNamesRequest.create = function create(properties) {
                return new StepNamesRequest(properties);
            };

            /**
             * Encodes the specified StepNamesRequest message. Does not implicitly {@link gauge.messages.StepNamesRequest.verify|verify} messages.
             * @function encode
             * @memberof gauge.messages.StepNamesRequest
             * @static
             * @param {gauge.messages.IStepNamesRequest} message StepNamesRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StepNamesRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified StepNamesRequest message, length delimited. Does not implicitly {@link gauge.messages.StepNamesRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gauge.messages.StepNamesRequest
             * @static
             * @param {gauge.messages.IStepNamesRequest} message StepNamesRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StepNamesRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a StepNamesRequest message from the specified reader or buffer.
             * @function decode
             * @memberof gauge.messages.StepNamesRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gauge.messages.StepNamesRequest} StepNamesRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StepNamesRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gauge.messages.StepNamesRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a StepNamesRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gauge.messages.StepNamesRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gauge.messages.StepNamesRequest} StepNamesRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StepNamesRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a StepNamesRequest message.
             * @function verify
             * @memberof gauge.messages.StepNamesRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            StepNamesRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a StepNamesRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gauge.messages.StepNamesRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gauge.messages.StepNamesRequest} StepNamesRequest
             */
            StepNamesRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.gauge.messages.StepNamesRequest)
                    return object;
                return new $root.gauge.messages.StepNamesRequest();
            };

            /**
             * Creates a plain object from a StepNamesRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gauge.messages.StepNamesRequest
             * @static
             * @param {gauge.messages.StepNamesRequest} message StepNamesRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            StepNamesRequest.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this StepNamesRequest to JSON.
             * @function toJSON
             * @memberof gauge.messages.StepNamesRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            StepNamesRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return StepNamesRequest;
        })();

        messages.StepNamesResponse = (function() {

            /**
             * Properties of a StepNamesResponse.
             * @memberof gauge.messages
             * @interface IStepNamesResponse
             * @property {Array.<string>|null} [steps] Collection of strings corresponding to Step texts.
             */

            /**
             * Constructs a new StepNamesResponse.
             * @memberof gauge.messages
             * @classdesc Response to StepNamesRequest
             * @implements IStepNamesResponse
             * @constructor
             * @param {gauge.messages.IStepNamesResponse=} [properties] Properties to set
             */
            function StepNamesResponse(properties) {
                this.steps = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Collection of strings corresponding to Step texts.
             * @member {Array.<string>} steps
             * @memberof gauge.messages.StepNamesResponse
             * @instance
             */
            StepNamesResponse.prototype.steps = $util.emptyArray;

            /**
             * Creates a new StepNamesResponse instance using the specified properties.
             * @function create
             * @memberof gauge.messages.StepNamesResponse
             * @static
             * @param {gauge.messages.IStepNamesResponse=} [properties] Properties to set
             * @returns {gauge.messages.StepNamesResponse} StepNamesResponse instance
             */
            StepNamesResponse.create = function create(properties) {
                return new StepNamesResponse(properties);
            };

            /**
             * Encodes the specified StepNamesResponse message. Does not implicitly {@link gauge.messages.StepNamesResponse.verify|verify} messages.
             * @function encode
             * @memberof gauge.messages.StepNamesResponse
             * @static
             * @param {gauge.messages.IStepNamesResponse} message StepNamesResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StepNamesResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.steps != null && message.steps.length)
                    for (var i = 0; i < message.steps.length; ++i)
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.steps[i]);
                return writer;
            };

            /**
             * Encodes the specified StepNamesResponse message, length delimited. Does not implicitly {@link gauge.messages.StepNamesResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gauge.messages.StepNamesResponse
             * @static
             * @param {gauge.messages.IStepNamesResponse} message StepNamesResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StepNamesResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a StepNamesResponse message from the specified reader or buffer.
             * @function decode
             * @memberof gauge.messages.StepNamesResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gauge.messages.StepNamesResponse} StepNamesResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StepNamesResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gauge.messages.StepNamesResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.steps && message.steps.length))
                            message.steps = [];
                        message.steps.push(reader.string());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a StepNamesResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gauge.messages.StepNamesResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gauge.messages.StepNamesResponse} StepNamesResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StepNamesResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a StepNamesResponse message.
             * @function verify
             * @memberof gauge.messages.StepNamesResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            StepNamesResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.steps != null && message.hasOwnProperty("steps")) {
                    if (!Array.isArray(message.steps))
                        return "steps: array expected";
                    for (var i = 0; i < message.steps.length; ++i)
                        if (!$util.isString(message.steps[i]))
                            return "steps: string[] expected";
                }
                return null;
            };

            /**
             * Creates a StepNamesResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gauge.messages.StepNamesResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gauge.messages.StepNamesResponse} StepNamesResponse
             */
            StepNamesResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.gauge.messages.StepNamesResponse)
                    return object;
                var message = new $root.gauge.messages.StepNamesResponse();
                if (object.steps) {
                    if (!Array.isArray(object.steps))
                        throw TypeError(".gauge.messages.StepNamesResponse.steps: array expected");
                    message.steps = [];
                    for (var i = 0; i < object.steps.length; ++i)
                        message.steps[i] = String(object.steps[i]);
                }
                return message;
            };

            /**
             * Creates a plain object from a StepNamesResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gauge.messages.StepNamesResponse
             * @static
             * @param {gauge.messages.StepNamesResponse} message StepNamesResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            StepNamesResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.steps = [];
                if (message.steps && message.steps.length) {
                    object.steps = [];
                    for (var j = 0; j < message.steps.length; ++j)
                        object.steps[j] = message.steps[j];
                }
                return object;
            };

            /**
             * Converts this StepNamesResponse to JSON.
             * @function toJSON
             * @memberof gauge.messages.StepNamesResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            StepNamesResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return StepNamesResponse;
        })();

        messages.ScenarioDataStoreInitRequest = (function() {

            /**
             * Properties of a ScenarioDataStoreInitRequest.
             * @memberof gauge.messages
             * @interface IScenarioDataStoreInitRequest
             * @property {number|null} [stream] ScenarioDataStoreInitRequest stream
             */

            /**
             * Constructs a new ScenarioDataStoreInitRequest.
             * @memberof gauge.messages
             * @classdesc Scenario Datastore is reset after every Scenario execution.
             * @implements IScenarioDataStoreInitRequest
             * @constructor
             * @param {gauge.messages.IScenarioDataStoreInitRequest=} [properties] Properties to set
             */
            function ScenarioDataStoreInitRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ScenarioDataStoreInitRequest stream.
             * @member {number} stream
             * @memberof gauge.messages.ScenarioDataStoreInitRequest
             * @instance
             */
            ScenarioDataStoreInitRequest.prototype.stream = 0;

            /**
             * Creates a new ScenarioDataStoreInitRequest instance using the specified properties.
             * @function create
             * @memberof gauge.messages.ScenarioDataStoreInitRequest
             * @static
             * @param {gauge.messages.IScenarioDataStoreInitRequest=} [properties] Properties to set
             * @returns {gauge.messages.ScenarioDataStoreInitRequest} ScenarioDataStoreInitRequest instance
             */
            ScenarioDataStoreInitRequest.create = function create(properties) {
                return new ScenarioDataStoreInitRequest(properties);
            };

            /**
             * Encodes the specified ScenarioDataStoreInitRequest message. Does not implicitly {@link gauge.messages.ScenarioDataStoreInitRequest.verify|verify} messages.
             * @function encode
             * @memberof gauge.messages.ScenarioDataStoreInitRequest
             * @static
             * @param {gauge.messages.IScenarioDataStoreInitRequest} message ScenarioDataStoreInitRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ScenarioDataStoreInitRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.stream != null && message.hasOwnProperty("stream"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.stream);
                return writer;
            };

            /**
             * Encodes the specified ScenarioDataStoreInitRequest message, length delimited. Does not implicitly {@link gauge.messages.ScenarioDataStoreInitRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gauge.messages.ScenarioDataStoreInitRequest
             * @static
             * @param {gauge.messages.IScenarioDataStoreInitRequest} message ScenarioDataStoreInitRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ScenarioDataStoreInitRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ScenarioDataStoreInitRequest message from the specified reader or buffer.
             * @function decode
             * @memberof gauge.messages.ScenarioDataStoreInitRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gauge.messages.ScenarioDataStoreInitRequest} ScenarioDataStoreInitRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ScenarioDataStoreInitRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gauge.messages.ScenarioDataStoreInitRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.stream = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ScenarioDataStoreInitRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gauge.messages.ScenarioDataStoreInitRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gauge.messages.ScenarioDataStoreInitRequest} ScenarioDataStoreInitRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ScenarioDataStoreInitRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ScenarioDataStoreInitRequest message.
             * @function verify
             * @memberof gauge.messages.ScenarioDataStoreInitRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ScenarioDataStoreInitRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.stream != null && message.hasOwnProperty("stream"))
                    if (!$util.isInteger(message.stream))
                        return "stream: integer expected";
                return null;
            };

            /**
             * Creates a ScenarioDataStoreInitRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gauge.messages.ScenarioDataStoreInitRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gauge.messages.ScenarioDataStoreInitRequest} ScenarioDataStoreInitRequest
             */
            ScenarioDataStoreInitRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.gauge.messages.ScenarioDataStoreInitRequest)
                    return object;
                var message = new $root.gauge.messages.ScenarioDataStoreInitRequest();
                if (object.stream != null)
                    message.stream = object.stream | 0;
                return message;
            };

            /**
             * Creates a plain object from a ScenarioDataStoreInitRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gauge.messages.ScenarioDataStoreInitRequest
             * @static
             * @param {gauge.messages.ScenarioDataStoreInitRequest} message ScenarioDataStoreInitRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ScenarioDataStoreInitRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.stream = 0;
                if (message.stream != null && message.hasOwnProperty("stream"))
                    object.stream = message.stream;
                return object;
            };

            /**
             * Converts this ScenarioDataStoreInitRequest to JSON.
             * @function toJSON
             * @memberof gauge.messages.ScenarioDataStoreInitRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ScenarioDataStoreInitRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ScenarioDataStoreInitRequest;
        })();

        messages.SpecDataStoreInitRequest = (function() {

            /**
             * Properties of a SpecDataStoreInitRequest.
             * @memberof gauge.messages
             * @interface ISpecDataStoreInitRequest
             * @property {number|null} [stream] SpecDataStoreInitRequest stream
             */

            /**
             * Constructs a new SpecDataStoreInitRequest.
             * @memberof gauge.messages
             * @classdesc Spec Datastore is reset after every Spec execution.
             * @implements ISpecDataStoreInitRequest
             * @constructor
             * @param {gauge.messages.ISpecDataStoreInitRequest=} [properties] Properties to set
             */
            function SpecDataStoreInitRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SpecDataStoreInitRequest stream.
             * @member {number} stream
             * @memberof gauge.messages.SpecDataStoreInitRequest
             * @instance
             */
            SpecDataStoreInitRequest.prototype.stream = 0;

            /**
             * Creates a new SpecDataStoreInitRequest instance using the specified properties.
             * @function create
             * @memberof gauge.messages.SpecDataStoreInitRequest
             * @static
             * @param {gauge.messages.ISpecDataStoreInitRequest=} [properties] Properties to set
             * @returns {gauge.messages.SpecDataStoreInitRequest} SpecDataStoreInitRequest instance
             */
            SpecDataStoreInitRequest.create = function create(properties) {
                return new SpecDataStoreInitRequest(properties);
            };

            /**
             * Encodes the specified SpecDataStoreInitRequest message. Does not implicitly {@link gauge.messages.SpecDataStoreInitRequest.verify|verify} messages.
             * @function encode
             * @memberof gauge.messages.SpecDataStoreInitRequest
             * @static
             * @param {gauge.messages.ISpecDataStoreInitRequest} message SpecDataStoreInitRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SpecDataStoreInitRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.stream != null && message.hasOwnProperty("stream"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.stream);
                return writer;
            };

            /**
             * Encodes the specified SpecDataStoreInitRequest message, length delimited. Does not implicitly {@link gauge.messages.SpecDataStoreInitRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gauge.messages.SpecDataStoreInitRequest
             * @static
             * @param {gauge.messages.ISpecDataStoreInitRequest} message SpecDataStoreInitRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SpecDataStoreInitRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SpecDataStoreInitRequest message from the specified reader or buffer.
             * @function decode
             * @memberof gauge.messages.SpecDataStoreInitRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gauge.messages.SpecDataStoreInitRequest} SpecDataStoreInitRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SpecDataStoreInitRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gauge.messages.SpecDataStoreInitRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.stream = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SpecDataStoreInitRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gauge.messages.SpecDataStoreInitRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gauge.messages.SpecDataStoreInitRequest} SpecDataStoreInitRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SpecDataStoreInitRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SpecDataStoreInitRequest message.
             * @function verify
             * @memberof gauge.messages.SpecDataStoreInitRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SpecDataStoreInitRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.stream != null && message.hasOwnProperty("stream"))
                    if (!$util.isInteger(message.stream))
                        return "stream: integer expected";
                return null;
            };

            /**
             * Creates a SpecDataStoreInitRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gauge.messages.SpecDataStoreInitRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gauge.messages.SpecDataStoreInitRequest} SpecDataStoreInitRequest
             */
            SpecDataStoreInitRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.gauge.messages.SpecDataStoreInitRequest)
                    return object;
                var message = new $root.gauge.messages.SpecDataStoreInitRequest();
                if (object.stream != null)
                    message.stream = object.stream | 0;
                return message;
            };

            /**
             * Creates a plain object from a SpecDataStoreInitRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gauge.messages.SpecDataStoreInitRequest
             * @static
             * @param {gauge.messages.SpecDataStoreInitRequest} message SpecDataStoreInitRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SpecDataStoreInitRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.stream = 0;
                if (message.stream != null && message.hasOwnProperty("stream"))
                    object.stream = message.stream;
                return object;
            };

            /**
             * Converts this SpecDataStoreInitRequest to JSON.
             * @function toJSON
             * @memberof gauge.messages.SpecDataStoreInitRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SpecDataStoreInitRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return SpecDataStoreInitRequest;
        })();

        messages.SuiteDataStoreInitRequest = (function() {

            /**
             * Properties of a SuiteDataStoreInitRequest.
             * @memberof gauge.messages
             * @interface ISuiteDataStoreInitRequest
             * @property {number|null} [stream] SuiteDataStoreInitRequest stream
             */

            /**
             * Constructs a new SuiteDataStoreInitRequest.
             * @memberof gauge.messages
             * @classdesc Suite Datastore is reset after every Suite execution.
             * @implements ISuiteDataStoreInitRequest
             * @constructor
             * @param {gauge.messages.ISuiteDataStoreInitRequest=} [properties] Properties to set
             */
            function SuiteDataStoreInitRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SuiteDataStoreInitRequest stream.
             * @member {number} stream
             * @memberof gauge.messages.SuiteDataStoreInitRequest
             * @instance
             */
            SuiteDataStoreInitRequest.prototype.stream = 0;

            /**
             * Creates a new SuiteDataStoreInitRequest instance using the specified properties.
             * @function create
             * @memberof gauge.messages.SuiteDataStoreInitRequest
             * @static
             * @param {gauge.messages.ISuiteDataStoreInitRequest=} [properties] Properties to set
             * @returns {gauge.messages.SuiteDataStoreInitRequest} SuiteDataStoreInitRequest instance
             */
            SuiteDataStoreInitRequest.create = function create(properties) {
                return new SuiteDataStoreInitRequest(properties);
            };

            /**
             * Encodes the specified SuiteDataStoreInitRequest message. Does not implicitly {@link gauge.messages.SuiteDataStoreInitRequest.verify|verify} messages.
             * @function encode
             * @memberof gauge.messages.SuiteDataStoreInitRequest
             * @static
             * @param {gauge.messages.ISuiteDataStoreInitRequest} message SuiteDataStoreInitRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SuiteDataStoreInitRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.stream != null && message.hasOwnProperty("stream"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.stream);
                return writer;
            };

            /**
             * Encodes the specified SuiteDataStoreInitRequest message, length delimited. Does not implicitly {@link gauge.messages.SuiteDataStoreInitRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gauge.messages.SuiteDataStoreInitRequest
             * @static
             * @param {gauge.messages.ISuiteDataStoreInitRequest} message SuiteDataStoreInitRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SuiteDataStoreInitRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SuiteDataStoreInitRequest message from the specified reader or buffer.
             * @function decode
             * @memberof gauge.messages.SuiteDataStoreInitRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gauge.messages.SuiteDataStoreInitRequest} SuiteDataStoreInitRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SuiteDataStoreInitRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gauge.messages.SuiteDataStoreInitRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.stream = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SuiteDataStoreInitRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gauge.messages.SuiteDataStoreInitRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gauge.messages.SuiteDataStoreInitRequest} SuiteDataStoreInitRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SuiteDataStoreInitRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SuiteDataStoreInitRequest message.
             * @function verify
             * @memberof gauge.messages.SuiteDataStoreInitRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SuiteDataStoreInitRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.stream != null && message.hasOwnProperty("stream"))
                    if (!$util.isInteger(message.stream))
                        return "stream: integer expected";
                return null;
            };

            /**
             * Creates a SuiteDataStoreInitRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gauge.messages.SuiteDataStoreInitRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gauge.messages.SuiteDataStoreInitRequest} SuiteDataStoreInitRequest
             */
            SuiteDataStoreInitRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.gauge.messages.SuiteDataStoreInitRequest)
                    return object;
                var message = new $root.gauge.messages.SuiteDataStoreInitRequest();
                if (object.stream != null)
                    message.stream = object.stream | 0;
                return message;
            };

            /**
             * Creates a plain object from a SuiteDataStoreInitRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gauge.messages.SuiteDataStoreInitRequest
             * @static
             * @param {gauge.messages.SuiteDataStoreInitRequest} message SuiteDataStoreInitRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SuiteDataStoreInitRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.stream = 0;
                if (message.stream != null && message.hasOwnProperty("stream"))
                    object.stream = message.stream;
                return object;
            };

            /**
             * Converts this SuiteDataStoreInitRequest to JSON.
             * @function toJSON
             * @memberof gauge.messages.SuiteDataStoreInitRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SuiteDataStoreInitRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return SuiteDataStoreInitRequest;
        })();

        messages.ParameterPosition = (function() {

            /**
             * Properties of a ParameterPosition.
             * @memberof gauge.messages
             * @interface IParameterPosition
             * @property {number|null} [oldPosition] ParameterPosition oldPosition
             * @property {number|null} [newPosition] ParameterPosition newPosition
             */

            /**
             * Constructs a new ParameterPosition.
             * @memberof gauge.messages
             * @classdesc Used when refactoring a Step.
             * @implements IParameterPosition
             * @constructor
             * @param {gauge.messages.IParameterPosition=} [properties] Properties to set
             */
            function ParameterPosition(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ParameterPosition oldPosition.
             * @member {number} oldPosition
             * @memberof gauge.messages.ParameterPosition
             * @instance
             */
            ParameterPosition.prototype.oldPosition = 0;

            /**
             * ParameterPosition newPosition.
             * @member {number} newPosition
             * @memberof gauge.messages.ParameterPosition
             * @instance
             */
            ParameterPosition.prototype.newPosition = 0;

            /**
             * Creates a new ParameterPosition instance using the specified properties.
             * @function create
             * @memberof gauge.messages.ParameterPosition
             * @static
             * @param {gauge.messages.IParameterPosition=} [properties] Properties to set
             * @returns {gauge.messages.ParameterPosition} ParameterPosition instance
             */
            ParameterPosition.create = function create(properties) {
                return new ParameterPosition(properties);
            };

            /**
             * Encodes the specified ParameterPosition message. Does not implicitly {@link gauge.messages.ParameterPosition.verify|verify} messages.
             * @function encode
             * @memberof gauge.messages.ParameterPosition
             * @static
             * @param {gauge.messages.IParameterPosition} message ParameterPosition message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ParameterPosition.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.oldPosition != null && message.hasOwnProperty("oldPosition"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.oldPosition);
                if (message.newPosition != null && message.hasOwnProperty("newPosition"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.newPosition);
                return writer;
            };

            /**
             * Encodes the specified ParameterPosition message, length delimited. Does not implicitly {@link gauge.messages.ParameterPosition.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gauge.messages.ParameterPosition
             * @static
             * @param {gauge.messages.IParameterPosition} message ParameterPosition message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ParameterPosition.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ParameterPosition message from the specified reader or buffer.
             * @function decode
             * @memberof gauge.messages.ParameterPosition
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gauge.messages.ParameterPosition} ParameterPosition
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ParameterPosition.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gauge.messages.ParameterPosition();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.oldPosition = reader.int32();
                        break;
                    case 2:
                        message.newPosition = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ParameterPosition message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gauge.messages.ParameterPosition
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gauge.messages.ParameterPosition} ParameterPosition
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ParameterPosition.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ParameterPosition message.
             * @function verify
             * @memberof gauge.messages.ParameterPosition
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ParameterPosition.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.oldPosition != null && message.hasOwnProperty("oldPosition"))
                    if (!$util.isInteger(message.oldPosition))
                        return "oldPosition: integer expected";
                if (message.newPosition != null && message.hasOwnProperty("newPosition"))
                    if (!$util.isInteger(message.newPosition))
                        return "newPosition: integer expected";
                return null;
            };

            /**
             * Creates a ParameterPosition message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gauge.messages.ParameterPosition
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gauge.messages.ParameterPosition} ParameterPosition
             */
            ParameterPosition.fromObject = function fromObject(object) {
                if (object instanceof $root.gauge.messages.ParameterPosition)
                    return object;
                var message = new $root.gauge.messages.ParameterPosition();
                if (object.oldPosition != null)
                    message.oldPosition = object.oldPosition | 0;
                if (object.newPosition != null)
                    message.newPosition = object.newPosition | 0;
                return message;
            };

            /**
             * Creates a plain object from a ParameterPosition message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gauge.messages.ParameterPosition
             * @static
             * @param {gauge.messages.ParameterPosition} message ParameterPosition
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ParameterPosition.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.oldPosition = 0;
                    object.newPosition = 0;
                }
                if (message.oldPosition != null && message.hasOwnProperty("oldPosition"))
                    object.oldPosition = message.oldPosition;
                if (message.newPosition != null && message.hasOwnProperty("newPosition"))
                    object.newPosition = message.newPosition;
                return object;
            };

            /**
             * Converts this ParameterPosition to JSON.
             * @function toJSON
             * @memberof gauge.messages.ParameterPosition
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ParameterPosition.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ParameterPosition;
        })();

        messages.RefactorRequest = (function() {

            /**
             * Properties of a RefactorRequest.
             * @memberof gauge.messages
             * @interface IRefactorRequest
             * @property {gauge.messages.IProtoStepValue|null} [oldStepValue] Old value, used to lookup Step to refactor
             * @property {gauge.messages.IProtoStepValue|null} [newStepValue] New value, the to-be value of Step being refactored.
             * @property {Array.<gauge.messages.IParameterPosition>|null} [paramPositions] Holds parameter positions of all parameters. Contains old and new parameter positions.
             * @property {boolean|null} [saveChanges] If set to true, the refactored files should be saved to the file system before returning the response.
             */

            /**
             * Constructs a new RefactorRequest.
             * @memberof gauge.messages
             * @classdesc Tells the runner to refactor the specified Step.
             * @implements IRefactorRequest
             * @constructor
             * @param {gauge.messages.IRefactorRequest=} [properties] Properties to set
             */
            function RefactorRequest(properties) {
                this.paramPositions = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Old value, used to lookup Step to refactor
             * @member {gauge.messages.IProtoStepValue|null|undefined} oldStepValue
             * @memberof gauge.messages.RefactorRequest
             * @instance
             */
            RefactorRequest.prototype.oldStepValue = null;

            /**
             * New value, the to-be value of Step being refactored.
             * @member {gauge.messages.IProtoStepValue|null|undefined} newStepValue
             * @memberof gauge.messages.RefactorRequest
             * @instance
             */
            RefactorRequest.prototype.newStepValue = null;

            /**
             * Holds parameter positions of all parameters. Contains old and new parameter positions.
             * @member {Array.<gauge.messages.IParameterPosition>} paramPositions
             * @memberof gauge.messages.RefactorRequest
             * @instance
             */
            RefactorRequest.prototype.paramPositions = $util.emptyArray;

            /**
             * If set to true, the refactored files should be saved to the file system before returning the response.
             * @member {boolean} saveChanges
             * @memberof gauge.messages.RefactorRequest
             * @instance
             */
            RefactorRequest.prototype.saveChanges = false;

            /**
             * Creates a new RefactorRequest instance using the specified properties.
             * @function create
             * @memberof gauge.messages.RefactorRequest
             * @static
             * @param {gauge.messages.IRefactorRequest=} [properties] Properties to set
             * @returns {gauge.messages.RefactorRequest} RefactorRequest instance
             */
            RefactorRequest.create = function create(properties) {
                return new RefactorRequest(properties);
            };

            /**
             * Encodes the specified RefactorRequest message. Does not implicitly {@link gauge.messages.RefactorRequest.verify|verify} messages.
             * @function encode
             * @memberof gauge.messages.RefactorRequest
             * @static
             * @param {gauge.messages.IRefactorRequest} message RefactorRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RefactorRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.oldStepValue != null && message.hasOwnProperty("oldStepValue"))
                    $root.gauge.messages.ProtoStepValue.encode(message.oldStepValue, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.newStepValue != null && message.hasOwnProperty("newStepValue"))
                    $root.gauge.messages.ProtoStepValue.encode(message.newStepValue, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.paramPositions != null && message.paramPositions.length)
                    for (var i = 0; i < message.paramPositions.length; ++i)
                        $root.gauge.messages.ParameterPosition.encode(message.paramPositions[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.saveChanges != null && message.hasOwnProperty("saveChanges"))
                    writer.uint32(/* id 4, wireType 0 =*/32).bool(message.saveChanges);
                return writer;
            };

            /**
             * Encodes the specified RefactorRequest message, length delimited. Does not implicitly {@link gauge.messages.RefactorRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gauge.messages.RefactorRequest
             * @static
             * @param {gauge.messages.IRefactorRequest} message RefactorRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RefactorRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RefactorRequest message from the specified reader or buffer.
             * @function decode
             * @memberof gauge.messages.RefactorRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gauge.messages.RefactorRequest} RefactorRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RefactorRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gauge.messages.RefactorRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.oldStepValue = $root.gauge.messages.ProtoStepValue.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.newStepValue = $root.gauge.messages.ProtoStepValue.decode(reader, reader.uint32());
                        break;
                    case 3:
                        if (!(message.paramPositions && message.paramPositions.length))
                            message.paramPositions = [];
                        message.paramPositions.push($root.gauge.messages.ParameterPosition.decode(reader, reader.uint32()));
                        break;
                    case 4:
                        message.saveChanges = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RefactorRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gauge.messages.RefactorRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gauge.messages.RefactorRequest} RefactorRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RefactorRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RefactorRequest message.
             * @function verify
             * @memberof gauge.messages.RefactorRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RefactorRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.oldStepValue != null && message.hasOwnProperty("oldStepValue")) {
                    var error = $root.gauge.messages.ProtoStepValue.verify(message.oldStepValue);
                    if (error)
                        return "oldStepValue." + error;
                }
                if (message.newStepValue != null && message.hasOwnProperty("newStepValue")) {
                    var error = $root.gauge.messages.ProtoStepValue.verify(message.newStepValue);
                    if (error)
                        return "newStepValue." + error;
                }
                if (message.paramPositions != null && message.hasOwnProperty("paramPositions")) {
                    if (!Array.isArray(message.paramPositions))
                        return "paramPositions: array expected";
                    for (var i = 0; i < message.paramPositions.length; ++i) {
                        var error = $root.gauge.messages.ParameterPosition.verify(message.paramPositions[i]);
                        if (error)
                            return "paramPositions." + error;
                    }
                }
                if (message.saveChanges != null && message.hasOwnProperty("saveChanges"))
                    if (typeof message.saveChanges !== "boolean")
                        return "saveChanges: boolean expected";
                return null;
            };

            /**
             * Creates a RefactorRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gauge.messages.RefactorRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gauge.messages.RefactorRequest} RefactorRequest
             */
            RefactorRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.gauge.messages.RefactorRequest)
                    return object;
                var message = new $root.gauge.messages.RefactorRequest();
                if (object.oldStepValue != null) {
                    if (typeof object.oldStepValue !== "object")
                        throw TypeError(".gauge.messages.RefactorRequest.oldStepValue: object expected");
                    message.oldStepValue = $root.gauge.messages.ProtoStepValue.fromObject(object.oldStepValue);
                }
                if (object.newStepValue != null) {
                    if (typeof object.newStepValue !== "object")
                        throw TypeError(".gauge.messages.RefactorRequest.newStepValue: object expected");
                    message.newStepValue = $root.gauge.messages.ProtoStepValue.fromObject(object.newStepValue);
                }
                if (object.paramPositions) {
                    if (!Array.isArray(object.paramPositions))
                        throw TypeError(".gauge.messages.RefactorRequest.paramPositions: array expected");
                    message.paramPositions = [];
                    for (var i = 0; i < object.paramPositions.length; ++i) {
                        if (typeof object.paramPositions[i] !== "object")
                            throw TypeError(".gauge.messages.RefactorRequest.paramPositions: object expected");
                        message.paramPositions[i] = $root.gauge.messages.ParameterPosition.fromObject(object.paramPositions[i]);
                    }
                }
                if (object.saveChanges != null)
                    message.saveChanges = Boolean(object.saveChanges);
                return message;
            };

            /**
             * Creates a plain object from a RefactorRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gauge.messages.RefactorRequest
             * @static
             * @param {gauge.messages.RefactorRequest} message RefactorRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RefactorRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.paramPositions = [];
                if (options.defaults) {
                    object.oldStepValue = null;
                    object.newStepValue = null;
                    object.saveChanges = false;
                }
                if (message.oldStepValue != null && message.hasOwnProperty("oldStepValue"))
                    object.oldStepValue = $root.gauge.messages.ProtoStepValue.toObject(message.oldStepValue, options);
                if (message.newStepValue != null && message.hasOwnProperty("newStepValue"))
                    object.newStepValue = $root.gauge.messages.ProtoStepValue.toObject(message.newStepValue, options);
                if (message.paramPositions && message.paramPositions.length) {
                    object.paramPositions = [];
                    for (var j = 0; j < message.paramPositions.length; ++j)
                        object.paramPositions[j] = $root.gauge.messages.ParameterPosition.toObject(message.paramPositions[j], options);
                }
                if (message.saveChanges != null && message.hasOwnProperty("saveChanges"))
                    object.saveChanges = message.saveChanges;
                return object;
            };

            /**
             * Converts this RefactorRequest to JSON.
             * @function toJSON
             * @memberof gauge.messages.RefactorRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RefactorRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RefactorRequest;
        })();

        messages.FileChanges = (function() {

            /**
             * Properties of a FileChanges.
             * @memberof gauge.messages
             * @interface IFileChanges
             * @property {string|null} [fileName] FileChanges fileName
             * @property {string|null} [fileContent] FileChanges fileContent
             * @property {Array.<gauge.messages.ITextDiff>|null} [diffs] FileChanges diffs
             */

            /**
             * Constructs a new FileChanges.
             * @memberof gauge.messages
             * @classdesc Give all file changes to be made to file system
             * @implements IFileChanges
             * @constructor
             * @param {gauge.messages.IFileChanges=} [properties] Properties to set
             */
            function FileChanges(properties) {
                this.diffs = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * FileChanges fileName.
             * @member {string} fileName
             * @memberof gauge.messages.FileChanges
             * @instance
             */
            FileChanges.prototype.fileName = "";

            /**
             * FileChanges fileContent.
             * @member {string} fileContent
             * @memberof gauge.messages.FileChanges
             * @instance
             */
            FileChanges.prototype.fileContent = "";

            /**
             * FileChanges diffs.
             * @member {Array.<gauge.messages.ITextDiff>} diffs
             * @memberof gauge.messages.FileChanges
             * @instance
             */
            FileChanges.prototype.diffs = $util.emptyArray;

            /**
             * Creates a new FileChanges instance using the specified properties.
             * @function create
             * @memberof gauge.messages.FileChanges
             * @static
             * @param {gauge.messages.IFileChanges=} [properties] Properties to set
             * @returns {gauge.messages.FileChanges} FileChanges instance
             */
            FileChanges.create = function create(properties) {
                return new FileChanges(properties);
            };

            /**
             * Encodes the specified FileChanges message. Does not implicitly {@link gauge.messages.FileChanges.verify|verify} messages.
             * @function encode
             * @memberof gauge.messages.FileChanges
             * @static
             * @param {gauge.messages.IFileChanges} message FileChanges message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FileChanges.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.fileName != null && message.hasOwnProperty("fileName"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.fileName);
                if (message.fileContent != null && message.hasOwnProperty("fileContent"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.fileContent);
                if (message.diffs != null && message.diffs.length)
                    for (var i = 0; i < message.diffs.length; ++i)
                        $root.gauge.messages.TextDiff.encode(message.diffs[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified FileChanges message, length delimited. Does not implicitly {@link gauge.messages.FileChanges.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gauge.messages.FileChanges
             * @static
             * @param {gauge.messages.IFileChanges} message FileChanges message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FileChanges.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a FileChanges message from the specified reader or buffer.
             * @function decode
             * @memberof gauge.messages.FileChanges
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gauge.messages.FileChanges} FileChanges
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FileChanges.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gauge.messages.FileChanges();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.fileName = reader.string();
                        break;
                    case 2:
                        message.fileContent = reader.string();
                        break;
                    case 3:
                        if (!(message.diffs && message.diffs.length))
                            message.diffs = [];
                        message.diffs.push($root.gauge.messages.TextDiff.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a FileChanges message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gauge.messages.FileChanges
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gauge.messages.FileChanges} FileChanges
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FileChanges.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a FileChanges message.
             * @function verify
             * @memberof gauge.messages.FileChanges
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FileChanges.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.fileName != null && message.hasOwnProperty("fileName"))
                    if (!$util.isString(message.fileName))
                        return "fileName: string expected";
                if (message.fileContent != null && message.hasOwnProperty("fileContent"))
                    if (!$util.isString(message.fileContent))
                        return "fileContent: string expected";
                if (message.diffs != null && message.hasOwnProperty("diffs")) {
                    if (!Array.isArray(message.diffs))
                        return "diffs: array expected";
                    for (var i = 0; i < message.diffs.length; ++i) {
                        var error = $root.gauge.messages.TextDiff.verify(message.diffs[i]);
                        if (error)
                            return "diffs." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a FileChanges message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gauge.messages.FileChanges
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gauge.messages.FileChanges} FileChanges
             */
            FileChanges.fromObject = function fromObject(object) {
                if (object instanceof $root.gauge.messages.FileChanges)
                    return object;
                var message = new $root.gauge.messages.FileChanges();
                if (object.fileName != null)
                    message.fileName = String(object.fileName);
                if (object.fileContent != null)
                    message.fileContent = String(object.fileContent);
                if (object.diffs) {
                    if (!Array.isArray(object.diffs))
                        throw TypeError(".gauge.messages.FileChanges.diffs: array expected");
                    message.diffs = [];
                    for (var i = 0; i < object.diffs.length; ++i) {
                        if (typeof object.diffs[i] !== "object")
                            throw TypeError(".gauge.messages.FileChanges.diffs: object expected");
                        message.diffs[i] = $root.gauge.messages.TextDiff.fromObject(object.diffs[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a FileChanges message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gauge.messages.FileChanges
             * @static
             * @param {gauge.messages.FileChanges} message FileChanges
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FileChanges.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.diffs = [];
                if (options.defaults) {
                    object.fileName = "";
                    object.fileContent = "";
                }
                if (message.fileName != null && message.hasOwnProperty("fileName"))
                    object.fileName = message.fileName;
                if (message.fileContent != null && message.hasOwnProperty("fileContent"))
                    object.fileContent = message.fileContent;
                if (message.diffs && message.diffs.length) {
                    object.diffs = [];
                    for (var j = 0; j < message.diffs.length; ++j)
                        object.diffs[j] = $root.gauge.messages.TextDiff.toObject(message.diffs[j], options);
                }
                return object;
            };

            /**
             * Converts this FileChanges to JSON.
             * @function toJSON
             * @memberof gauge.messages.FileChanges
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FileChanges.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return FileChanges;
        })();

        messages.RefactorResponse = (function() {

            /**
             * Properties of a RefactorResponse.
             * @memberof gauge.messages
             * @interface IRefactorResponse
             * @property {boolean|null} [success] Flag indicating the success of Refactor operation.
             * @property {string|null} [error] Error message, valid only if Refactor wasn't successful
             * @property {Array.<string>|null} [filesChanged] List of files that were affected because of the refactoring.
             * @property {Array.<gauge.messages.IFileChanges>|null} [fileChanges] List of file changes to be made to successfully achieve refactoring.
             */

            /**
             * Constructs a new RefactorResponse.
             * @memberof gauge.messages
             * @classdesc Response of a RefactorRequest
             * @implements IRefactorResponse
             * @constructor
             * @param {gauge.messages.IRefactorResponse=} [properties] Properties to set
             */
            function RefactorResponse(properties) {
                this.filesChanged = [];
                this.fileChanges = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Flag indicating the success of Refactor operation.
             * @member {boolean} success
             * @memberof gauge.messages.RefactorResponse
             * @instance
             */
            RefactorResponse.prototype.success = false;

            /**
             * Error message, valid only if Refactor wasn't successful
             * @member {string} error
             * @memberof gauge.messages.RefactorResponse
             * @instance
             */
            RefactorResponse.prototype.error = "";

            /**
             * List of files that were affected because of the refactoring.
             * @member {Array.<string>} filesChanged
             * @memberof gauge.messages.RefactorResponse
             * @instance
             */
            RefactorResponse.prototype.filesChanged = $util.emptyArray;

            /**
             * List of file changes to be made to successfully achieve refactoring.
             * @member {Array.<gauge.messages.IFileChanges>} fileChanges
             * @memberof gauge.messages.RefactorResponse
             * @instance
             */
            RefactorResponse.prototype.fileChanges = $util.emptyArray;

            /**
             * Creates a new RefactorResponse instance using the specified properties.
             * @function create
             * @memberof gauge.messages.RefactorResponse
             * @static
             * @param {gauge.messages.IRefactorResponse=} [properties] Properties to set
             * @returns {gauge.messages.RefactorResponse} RefactorResponse instance
             */
            RefactorResponse.create = function create(properties) {
                return new RefactorResponse(properties);
            };

            /**
             * Encodes the specified RefactorResponse message. Does not implicitly {@link gauge.messages.RefactorResponse.verify|verify} messages.
             * @function encode
             * @memberof gauge.messages.RefactorResponse
             * @static
             * @param {gauge.messages.IRefactorResponse} message RefactorResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RefactorResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.success != null && message.hasOwnProperty("success"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.success);
                if (message.error != null && message.hasOwnProperty("error"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.error);
                if (message.filesChanged != null && message.filesChanged.length)
                    for (var i = 0; i < message.filesChanged.length; ++i)
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.filesChanged[i]);
                if (message.fileChanges != null && message.fileChanges.length)
                    for (var i = 0; i < message.fileChanges.length; ++i)
                        $root.gauge.messages.FileChanges.encode(message.fileChanges[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified RefactorResponse message, length delimited. Does not implicitly {@link gauge.messages.RefactorResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gauge.messages.RefactorResponse
             * @static
             * @param {gauge.messages.IRefactorResponse} message RefactorResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RefactorResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RefactorResponse message from the specified reader or buffer.
             * @function decode
             * @memberof gauge.messages.RefactorResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gauge.messages.RefactorResponse} RefactorResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RefactorResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gauge.messages.RefactorResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.success = reader.bool();
                        break;
                    case 2:
                        message.error = reader.string();
                        break;
                    case 3:
                        if (!(message.filesChanged && message.filesChanged.length))
                            message.filesChanged = [];
                        message.filesChanged.push(reader.string());
                        break;
                    case 4:
                        if (!(message.fileChanges && message.fileChanges.length))
                            message.fileChanges = [];
                        message.fileChanges.push($root.gauge.messages.FileChanges.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RefactorResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gauge.messages.RefactorResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gauge.messages.RefactorResponse} RefactorResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RefactorResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RefactorResponse message.
             * @function verify
             * @memberof gauge.messages.RefactorResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RefactorResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.success != null && message.hasOwnProperty("success"))
                    if (typeof message.success !== "boolean")
                        return "success: boolean expected";
                if (message.error != null && message.hasOwnProperty("error"))
                    if (!$util.isString(message.error))
                        return "error: string expected";
                if (message.filesChanged != null && message.hasOwnProperty("filesChanged")) {
                    if (!Array.isArray(message.filesChanged))
                        return "filesChanged: array expected";
                    for (var i = 0; i < message.filesChanged.length; ++i)
                        if (!$util.isString(message.filesChanged[i]))
                            return "filesChanged: string[] expected";
                }
                if (message.fileChanges != null && message.hasOwnProperty("fileChanges")) {
                    if (!Array.isArray(message.fileChanges))
                        return "fileChanges: array expected";
                    for (var i = 0; i < message.fileChanges.length; ++i) {
                        var error = $root.gauge.messages.FileChanges.verify(message.fileChanges[i]);
                        if (error)
                            return "fileChanges." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a RefactorResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gauge.messages.RefactorResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gauge.messages.RefactorResponse} RefactorResponse
             */
            RefactorResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.gauge.messages.RefactorResponse)
                    return object;
                var message = new $root.gauge.messages.RefactorResponse();
                if (object.success != null)
                    message.success = Boolean(object.success);
                if (object.error != null)
                    message.error = String(object.error);
                if (object.filesChanged) {
                    if (!Array.isArray(object.filesChanged))
                        throw TypeError(".gauge.messages.RefactorResponse.filesChanged: array expected");
                    message.filesChanged = [];
                    for (var i = 0; i < object.filesChanged.length; ++i)
                        message.filesChanged[i] = String(object.filesChanged[i]);
                }
                if (object.fileChanges) {
                    if (!Array.isArray(object.fileChanges))
                        throw TypeError(".gauge.messages.RefactorResponse.fileChanges: array expected");
                    message.fileChanges = [];
                    for (var i = 0; i < object.fileChanges.length; ++i) {
                        if (typeof object.fileChanges[i] !== "object")
                            throw TypeError(".gauge.messages.RefactorResponse.fileChanges: object expected");
                        message.fileChanges[i] = $root.gauge.messages.FileChanges.fromObject(object.fileChanges[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a RefactorResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gauge.messages.RefactorResponse
             * @static
             * @param {gauge.messages.RefactorResponse} message RefactorResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RefactorResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults) {
                    object.filesChanged = [];
                    object.fileChanges = [];
                }
                if (options.defaults) {
                    object.success = false;
                    object.error = "";
                }
                if (message.success != null && message.hasOwnProperty("success"))
                    object.success = message.success;
                if (message.error != null && message.hasOwnProperty("error"))
                    object.error = message.error;
                if (message.filesChanged && message.filesChanged.length) {
                    object.filesChanged = [];
                    for (var j = 0; j < message.filesChanged.length; ++j)
                        object.filesChanged[j] = message.filesChanged[j];
                }
                if (message.fileChanges && message.fileChanges.length) {
                    object.fileChanges = [];
                    for (var j = 0; j < message.fileChanges.length; ++j)
                        object.fileChanges[j] = $root.gauge.messages.FileChanges.toObject(message.fileChanges[j], options);
                }
                return object;
            };

            /**
             * Converts this RefactorResponse to JSON.
             * @function toJSON
             * @memberof gauge.messages.RefactorResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RefactorResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RefactorResponse;
        })();

        messages.StepNameRequest = (function() {

            /**
             * Properties of a StepNameRequest.
             * @memberof gauge.messages
             * @interface IStepNameRequest
             * @property {string|null} [stepValue] This is the parsed step value, i.e. with placeholders for parameters.
             */

            /**
             * Constructs a new StepNameRequest.
             * @memberof gauge.messages
             * @classdesc Request for details on a Single Step.
             * @implements IStepNameRequest
             * @constructor
             * @param {gauge.messages.IStepNameRequest=} [properties] Properties to set
             */
            function StepNameRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * This is the parsed step value, i.e. with placeholders for parameters.
             * @member {string} stepValue
             * @memberof gauge.messages.StepNameRequest
             * @instance
             */
            StepNameRequest.prototype.stepValue = "";

            /**
             * Creates a new StepNameRequest instance using the specified properties.
             * @function create
             * @memberof gauge.messages.StepNameRequest
             * @static
             * @param {gauge.messages.IStepNameRequest=} [properties] Properties to set
             * @returns {gauge.messages.StepNameRequest} StepNameRequest instance
             */
            StepNameRequest.create = function create(properties) {
                return new StepNameRequest(properties);
            };

            /**
             * Encodes the specified StepNameRequest message. Does not implicitly {@link gauge.messages.StepNameRequest.verify|verify} messages.
             * @function encode
             * @memberof gauge.messages.StepNameRequest
             * @static
             * @param {gauge.messages.IStepNameRequest} message StepNameRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StepNameRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.stepValue != null && message.hasOwnProperty("stepValue"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.stepValue);
                return writer;
            };

            /**
             * Encodes the specified StepNameRequest message, length delimited. Does not implicitly {@link gauge.messages.StepNameRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gauge.messages.StepNameRequest
             * @static
             * @param {gauge.messages.IStepNameRequest} message StepNameRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StepNameRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a StepNameRequest message from the specified reader or buffer.
             * @function decode
             * @memberof gauge.messages.StepNameRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gauge.messages.StepNameRequest} StepNameRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StepNameRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gauge.messages.StepNameRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.stepValue = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a StepNameRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gauge.messages.StepNameRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gauge.messages.StepNameRequest} StepNameRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StepNameRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a StepNameRequest message.
             * @function verify
             * @memberof gauge.messages.StepNameRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            StepNameRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.stepValue != null && message.hasOwnProperty("stepValue"))
                    if (!$util.isString(message.stepValue))
                        return "stepValue: string expected";
                return null;
            };

            /**
             * Creates a StepNameRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gauge.messages.StepNameRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gauge.messages.StepNameRequest} StepNameRequest
             */
            StepNameRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.gauge.messages.StepNameRequest)
                    return object;
                var message = new $root.gauge.messages.StepNameRequest();
                if (object.stepValue != null)
                    message.stepValue = String(object.stepValue);
                return message;
            };

            /**
             * Creates a plain object from a StepNameRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gauge.messages.StepNameRequest
             * @static
             * @param {gauge.messages.StepNameRequest} message StepNameRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            StepNameRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.stepValue = "";
                if (message.stepValue != null && message.hasOwnProperty("stepValue"))
                    object.stepValue = message.stepValue;
                return object;
            };

            /**
             * Converts this StepNameRequest to JSON.
             * @function toJSON
             * @memberof gauge.messages.StepNameRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            StepNameRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return StepNameRequest;
        })();

        messages.StepNameResponse = (function() {

            /**
             * Properties of a StepNameResponse.
             * @memberof gauge.messages
             * @interface IStepNameResponse
             * @property {boolean|null} [isStepPresent] Flag indicating if there is a match for the given Step Text.
             * @property {Array.<string>|null} [stepName] The Step name of the given step.
             * @property {boolean|null} [hasAlias] Flag indicating if the given Step is an alias.
             * @property {string|null} [fileName] File name in which the step implementation exists
             * @property {gauge.messages.ISpan|null} [span] Range of step
             */

            /**
             * Constructs a new StepNameResponse.
             * @memberof gauge.messages
             * @classdesc Response to StepNameRequest.
             * @implements IStepNameResponse
             * @constructor
             * @param {gauge.messages.IStepNameResponse=} [properties] Properties to set
             */
            function StepNameResponse(properties) {
                this.stepName = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Flag indicating if there is a match for the given Step Text.
             * @member {boolean} isStepPresent
             * @memberof gauge.messages.StepNameResponse
             * @instance
             */
            StepNameResponse.prototype.isStepPresent = false;

            /**
             * The Step name of the given step.
             * @member {Array.<string>} stepName
             * @memberof gauge.messages.StepNameResponse
             * @instance
             */
            StepNameResponse.prototype.stepName = $util.emptyArray;

            /**
             * Flag indicating if the given Step is an alias.
             * @member {boolean} hasAlias
             * @memberof gauge.messages.StepNameResponse
             * @instance
             */
            StepNameResponse.prototype.hasAlias = false;

            /**
             * File name in which the step implementation exists
             * @member {string} fileName
             * @memberof gauge.messages.StepNameResponse
             * @instance
             */
            StepNameResponse.prototype.fileName = "";

            /**
             * Range of step
             * @member {gauge.messages.ISpan|null|undefined} span
             * @memberof gauge.messages.StepNameResponse
             * @instance
             */
            StepNameResponse.prototype.span = null;

            /**
             * Creates a new StepNameResponse instance using the specified properties.
             * @function create
             * @memberof gauge.messages.StepNameResponse
             * @static
             * @param {gauge.messages.IStepNameResponse=} [properties] Properties to set
             * @returns {gauge.messages.StepNameResponse} StepNameResponse instance
             */
            StepNameResponse.create = function create(properties) {
                return new StepNameResponse(properties);
            };

            /**
             * Encodes the specified StepNameResponse message. Does not implicitly {@link gauge.messages.StepNameResponse.verify|verify} messages.
             * @function encode
             * @memberof gauge.messages.StepNameResponse
             * @static
             * @param {gauge.messages.IStepNameResponse} message StepNameResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StepNameResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.isStepPresent != null && message.hasOwnProperty("isStepPresent"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.isStepPresent);
                if (message.stepName != null && message.stepName.length)
                    for (var i = 0; i < message.stepName.length; ++i)
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.stepName[i]);
                if (message.hasAlias != null && message.hasOwnProperty("hasAlias"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.hasAlias);
                if (message.fileName != null && message.hasOwnProperty("fileName"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.fileName);
                if (message.span != null && message.hasOwnProperty("span"))
                    $root.gauge.messages.Span.encode(message.span, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified StepNameResponse message, length delimited. Does not implicitly {@link gauge.messages.StepNameResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gauge.messages.StepNameResponse
             * @static
             * @param {gauge.messages.IStepNameResponse} message StepNameResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StepNameResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a StepNameResponse message from the specified reader or buffer.
             * @function decode
             * @memberof gauge.messages.StepNameResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gauge.messages.StepNameResponse} StepNameResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StepNameResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gauge.messages.StepNameResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.isStepPresent = reader.bool();
                        break;
                    case 2:
                        if (!(message.stepName && message.stepName.length))
                            message.stepName = [];
                        message.stepName.push(reader.string());
                        break;
                    case 3:
                        message.hasAlias = reader.bool();
                        break;
                    case 4:
                        message.fileName = reader.string();
                        break;
                    case 5:
                        message.span = $root.gauge.messages.Span.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a StepNameResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gauge.messages.StepNameResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gauge.messages.StepNameResponse} StepNameResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StepNameResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a StepNameResponse message.
             * @function verify
             * @memberof gauge.messages.StepNameResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            StepNameResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.isStepPresent != null && message.hasOwnProperty("isStepPresent"))
                    if (typeof message.isStepPresent !== "boolean")
                        return "isStepPresent: boolean expected";
                if (message.stepName != null && message.hasOwnProperty("stepName")) {
                    if (!Array.isArray(message.stepName))
                        return "stepName: array expected";
                    for (var i = 0; i < message.stepName.length; ++i)
                        if (!$util.isString(message.stepName[i]))
                            return "stepName: string[] expected";
                }
                if (message.hasAlias != null && message.hasOwnProperty("hasAlias"))
                    if (typeof message.hasAlias !== "boolean")
                        return "hasAlias: boolean expected";
                if (message.fileName != null && message.hasOwnProperty("fileName"))
                    if (!$util.isString(message.fileName))
                        return "fileName: string expected";
                if (message.span != null && message.hasOwnProperty("span")) {
                    var error = $root.gauge.messages.Span.verify(message.span);
                    if (error)
                        return "span." + error;
                }
                return null;
            };

            /**
             * Creates a StepNameResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gauge.messages.StepNameResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gauge.messages.StepNameResponse} StepNameResponse
             */
            StepNameResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.gauge.messages.StepNameResponse)
                    return object;
                var message = new $root.gauge.messages.StepNameResponse();
                if (object.isStepPresent != null)
                    message.isStepPresent = Boolean(object.isStepPresent);
                if (object.stepName) {
                    if (!Array.isArray(object.stepName))
                        throw TypeError(".gauge.messages.StepNameResponse.stepName: array expected");
                    message.stepName = [];
                    for (var i = 0; i < object.stepName.length; ++i)
                        message.stepName[i] = String(object.stepName[i]);
                }
                if (object.hasAlias != null)
                    message.hasAlias = Boolean(object.hasAlias);
                if (object.fileName != null)
                    message.fileName = String(object.fileName);
                if (object.span != null) {
                    if (typeof object.span !== "object")
                        throw TypeError(".gauge.messages.StepNameResponse.span: object expected");
                    message.span = $root.gauge.messages.Span.fromObject(object.span);
                }
                return message;
            };

            /**
             * Creates a plain object from a StepNameResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gauge.messages.StepNameResponse
             * @static
             * @param {gauge.messages.StepNameResponse} message StepNameResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            StepNameResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.stepName = [];
                if (options.defaults) {
                    object.isStepPresent = false;
                    object.hasAlias = false;
                    object.fileName = "";
                    object.span = null;
                }
                if (message.isStepPresent != null && message.hasOwnProperty("isStepPresent"))
                    object.isStepPresent = message.isStepPresent;
                if (message.stepName && message.stepName.length) {
                    object.stepName = [];
                    for (var j = 0; j < message.stepName.length; ++j)
                        object.stepName[j] = message.stepName[j];
                }
                if (message.hasAlias != null && message.hasOwnProperty("hasAlias"))
                    object.hasAlias = message.hasAlias;
                if (message.fileName != null && message.hasOwnProperty("fileName"))
                    object.fileName = message.fileName;
                if (message.span != null && message.hasOwnProperty("span"))
                    object.span = $root.gauge.messages.Span.toObject(message.span, options);
                return object;
            };

            /**
             * Converts this StepNameResponse to JSON.
             * @function toJSON
             * @memberof gauge.messages.StepNameResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            StepNameResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return StepNameResponse;
        })();

        messages.UnsupportedMessageResponse = (function() {

            /**
             * Properties of an UnsupportedMessageResponse.
             * @memberof gauge.messages
             * @interface IUnsupportedMessageResponse
             * @property {string|null} [message] UnsupportedMessageResponse message
             */

            /**
             * Constructs a new UnsupportedMessageResponse.
             * @memberof gauge.messages
             * @classdesc Response when a unsupported message request is sent.
             * @implements IUnsupportedMessageResponse
             * @constructor
             * @param {gauge.messages.IUnsupportedMessageResponse=} [properties] Properties to set
             */
            function UnsupportedMessageResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * UnsupportedMessageResponse message.
             * @member {string} message
             * @memberof gauge.messages.UnsupportedMessageResponse
             * @instance
             */
            UnsupportedMessageResponse.prototype.message = "";

            /**
             * Creates a new UnsupportedMessageResponse instance using the specified properties.
             * @function create
             * @memberof gauge.messages.UnsupportedMessageResponse
             * @static
             * @param {gauge.messages.IUnsupportedMessageResponse=} [properties] Properties to set
             * @returns {gauge.messages.UnsupportedMessageResponse} UnsupportedMessageResponse instance
             */
            UnsupportedMessageResponse.create = function create(properties) {
                return new UnsupportedMessageResponse(properties);
            };

            /**
             * Encodes the specified UnsupportedMessageResponse message. Does not implicitly {@link gauge.messages.UnsupportedMessageResponse.verify|verify} messages.
             * @function encode
             * @memberof gauge.messages.UnsupportedMessageResponse
             * @static
             * @param {gauge.messages.IUnsupportedMessageResponse} message UnsupportedMessageResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UnsupportedMessageResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.message != null && message.hasOwnProperty("message"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.message);
                return writer;
            };

            /**
             * Encodes the specified UnsupportedMessageResponse message, length delimited. Does not implicitly {@link gauge.messages.UnsupportedMessageResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gauge.messages.UnsupportedMessageResponse
             * @static
             * @param {gauge.messages.IUnsupportedMessageResponse} message UnsupportedMessageResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UnsupportedMessageResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an UnsupportedMessageResponse message from the specified reader or buffer.
             * @function decode
             * @memberof gauge.messages.UnsupportedMessageResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gauge.messages.UnsupportedMessageResponse} UnsupportedMessageResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UnsupportedMessageResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gauge.messages.UnsupportedMessageResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.message = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an UnsupportedMessageResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gauge.messages.UnsupportedMessageResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gauge.messages.UnsupportedMessageResponse} UnsupportedMessageResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UnsupportedMessageResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an UnsupportedMessageResponse message.
             * @function verify
             * @memberof gauge.messages.UnsupportedMessageResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            UnsupportedMessageResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.message != null && message.hasOwnProperty("message"))
                    if (!$util.isString(message.message))
                        return "message: string expected";
                return null;
            };

            /**
             * Creates an UnsupportedMessageResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gauge.messages.UnsupportedMessageResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gauge.messages.UnsupportedMessageResponse} UnsupportedMessageResponse
             */
            UnsupportedMessageResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.gauge.messages.UnsupportedMessageResponse)
                    return object;
                var message = new $root.gauge.messages.UnsupportedMessageResponse();
                if (object.message != null)
                    message.message = String(object.message);
                return message;
            };

            /**
             * Creates a plain object from an UnsupportedMessageResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gauge.messages.UnsupportedMessageResponse
             * @static
             * @param {gauge.messages.UnsupportedMessageResponse} message UnsupportedMessageResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            UnsupportedMessageResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.message = "";
                if (message.message != null && message.hasOwnProperty("message"))
                    object.message = message.message;
                return object;
            };

            /**
             * Converts this UnsupportedMessageResponse to JSON.
             * @function toJSON
             * @memberof gauge.messages.UnsupportedMessageResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            UnsupportedMessageResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return UnsupportedMessageResponse;
        })();

        messages.CacheFileRequest = (function() {

            /**
             * Properties of a CacheFileRequest.
             * @memberof gauge.messages
             * @interface ICacheFileRequest
             * @property {string|null} [content] File content of the file to be cached
             * @property {string|null} [filePath] File path of the file to be cached
             * @property {boolean|null} [isClosed] Specifies if the file is closed
             * @property {gauge.messages.CacheFileRequest.FileStatus|null} [status] Specifies the status of the file
             */

            /**
             * Constructs a new CacheFileRequest.
             * @memberof gauge.messages
             * @classdesc so runner can cache file contents present on the client(an editor).
             * @implements ICacheFileRequest
             * @constructor
             * @param {gauge.messages.ICacheFileRequest=} [properties] Properties to set
             */
            function CacheFileRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * File content of the file to be cached
             * @member {string} content
             * @memberof gauge.messages.CacheFileRequest
             * @instance
             */
            CacheFileRequest.prototype.content = "";

            /**
             * File path of the file to be cached
             * @member {string} filePath
             * @memberof gauge.messages.CacheFileRequest
             * @instance
             */
            CacheFileRequest.prototype.filePath = "";

            /**
             * Specifies if the file is closed
             * @member {boolean} isClosed
             * @memberof gauge.messages.CacheFileRequest
             * @instance
             */
            CacheFileRequest.prototype.isClosed = false;

            /**
             * Specifies the status of the file
             * @member {gauge.messages.CacheFileRequest.FileStatus} status
             * @memberof gauge.messages.CacheFileRequest
             * @instance
             */
            CacheFileRequest.prototype.status = 0;

            /**
             * Creates a new CacheFileRequest instance using the specified properties.
             * @function create
             * @memberof gauge.messages.CacheFileRequest
             * @static
             * @param {gauge.messages.ICacheFileRequest=} [properties] Properties to set
             * @returns {gauge.messages.CacheFileRequest} CacheFileRequest instance
             */
            CacheFileRequest.create = function create(properties) {
                return new CacheFileRequest(properties);
            };

            /**
             * Encodes the specified CacheFileRequest message. Does not implicitly {@link gauge.messages.CacheFileRequest.verify|verify} messages.
             * @function encode
             * @memberof gauge.messages.CacheFileRequest
             * @static
             * @param {gauge.messages.ICacheFileRequest} message CacheFileRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CacheFileRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.content != null && message.hasOwnProperty("content"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.content);
                if (message.filePath != null && message.hasOwnProperty("filePath"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.filePath);
                if (message.isClosed != null && message.hasOwnProperty("isClosed"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.isClosed);
                if (message.status != null && message.hasOwnProperty("status"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.status);
                return writer;
            };

            /**
             * Encodes the specified CacheFileRequest message, length delimited. Does not implicitly {@link gauge.messages.CacheFileRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gauge.messages.CacheFileRequest
             * @static
             * @param {gauge.messages.ICacheFileRequest} message CacheFileRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CacheFileRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a CacheFileRequest message from the specified reader or buffer.
             * @function decode
             * @memberof gauge.messages.CacheFileRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gauge.messages.CacheFileRequest} CacheFileRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CacheFileRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gauge.messages.CacheFileRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.content = reader.string();
                        break;
                    case 2:
                        message.filePath = reader.string();
                        break;
                    case 3:
                        message.isClosed = reader.bool();
                        break;
                    case 4:
                        message.status = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a CacheFileRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gauge.messages.CacheFileRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gauge.messages.CacheFileRequest} CacheFileRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CacheFileRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a CacheFileRequest message.
             * @function verify
             * @memberof gauge.messages.CacheFileRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CacheFileRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.content != null && message.hasOwnProperty("content"))
                    if (!$util.isString(message.content))
                        return "content: string expected";
                if (message.filePath != null && message.hasOwnProperty("filePath"))
                    if (!$util.isString(message.filePath))
                        return "filePath: string expected";
                if (message.isClosed != null && message.hasOwnProperty("isClosed"))
                    if (typeof message.isClosed !== "boolean")
                        return "isClosed: boolean expected";
                if (message.status != null && message.hasOwnProperty("status"))
                    switch (message.status) {
                    default:
                        return "status: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                        break;
                    }
                return null;
            };

            /**
             * Creates a CacheFileRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gauge.messages.CacheFileRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gauge.messages.CacheFileRequest} CacheFileRequest
             */
            CacheFileRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.gauge.messages.CacheFileRequest)
                    return object;
                var message = new $root.gauge.messages.CacheFileRequest();
                if (object.content != null)
                    message.content = String(object.content);
                if (object.filePath != null)
                    message.filePath = String(object.filePath);
                if (object.isClosed != null)
                    message.isClosed = Boolean(object.isClosed);
                switch (object.status) {
                case "CHANGED":
                case 0:
                    message.status = 0;
                    break;
                case "CLOSED":
                case 1:
                    message.status = 1;
                    break;
                case "CREATED":
                case 2:
                    message.status = 2;
                    break;
                case "DELETED":
                case 3:
                    message.status = 3;
                    break;
                case "OPENED":
                case 4:
                    message.status = 4;
                    break;
                }
                return message;
            };

            /**
             * Creates a plain object from a CacheFileRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gauge.messages.CacheFileRequest
             * @static
             * @param {gauge.messages.CacheFileRequest} message CacheFileRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CacheFileRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.content = "";
                    object.filePath = "";
                    object.isClosed = false;
                    object.status = options.enums === String ? "CHANGED" : 0;
                }
                if (message.content != null && message.hasOwnProperty("content"))
                    object.content = message.content;
                if (message.filePath != null && message.hasOwnProperty("filePath"))
                    object.filePath = message.filePath;
                if (message.isClosed != null && message.hasOwnProperty("isClosed"))
                    object.isClosed = message.isClosed;
                if (message.status != null && message.hasOwnProperty("status"))
                    object.status = options.enums === String ? $root.gauge.messages.CacheFileRequest.FileStatus[message.status] : message.status;
                return object;
            };

            /**
             * Converts this CacheFileRequest to JSON.
             * @function toJSON
             * @memberof gauge.messages.CacheFileRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CacheFileRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * FileStatus enum.
             * @name gauge.messages.CacheFileRequest.FileStatus
             * @enum {string}
             * @property {number} CHANGED=0 The file content was changed in the client
             * @property {number} CLOSED=1 The file was closed in the client
             * @property {number} CREATED=2 The file was created on the client
             * @property {number} DELETED=3 The file was deleted on the client
             * @property {number} OPENED=4 The file is opened in the client
             */
            CacheFileRequest.FileStatus = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "CHANGED"] = 0;
                values[valuesById[1] = "CLOSED"] = 1;
                values[valuesById[2] = "CREATED"] = 2;
                values[valuesById[3] = "DELETED"] = 3;
                values[valuesById[4] = "OPENED"] = 4;
                return values;
            })();

            return CacheFileRequest;
        })();

        messages.StepPositionsRequest = (function() {

            /**
             * Properties of a StepPositionsRequest.
             * @memberof gauge.messages
             * @interface IStepPositionsRequest
             * @property {string|null} [filePath] Get step positions for file path
             */

            /**
             * Constructs a new StepPositionsRequest.
             * @memberof gauge.messages
             * @classdesc Request for find step positions
             * @implements IStepPositionsRequest
             * @constructor
             * @param {gauge.messages.IStepPositionsRequest=} [properties] Properties to set
             */
            function StepPositionsRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Get step positions for file path
             * @member {string} filePath
             * @memberof gauge.messages.StepPositionsRequest
             * @instance
             */
            StepPositionsRequest.prototype.filePath = "";

            /**
             * Creates a new StepPositionsRequest instance using the specified properties.
             * @function create
             * @memberof gauge.messages.StepPositionsRequest
             * @static
             * @param {gauge.messages.IStepPositionsRequest=} [properties] Properties to set
             * @returns {gauge.messages.StepPositionsRequest} StepPositionsRequest instance
             */
            StepPositionsRequest.create = function create(properties) {
                return new StepPositionsRequest(properties);
            };

            /**
             * Encodes the specified StepPositionsRequest message. Does not implicitly {@link gauge.messages.StepPositionsRequest.verify|verify} messages.
             * @function encode
             * @memberof gauge.messages.StepPositionsRequest
             * @static
             * @param {gauge.messages.IStepPositionsRequest} message StepPositionsRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StepPositionsRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.filePath != null && message.hasOwnProperty("filePath"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.filePath);
                return writer;
            };

            /**
             * Encodes the specified StepPositionsRequest message, length delimited. Does not implicitly {@link gauge.messages.StepPositionsRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gauge.messages.StepPositionsRequest
             * @static
             * @param {gauge.messages.IStepPositionsRequest} message StepPositionsRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StepPositionsRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a StepPositionsRequest message from the specified reader or buffer.
             * @function decode
             * @memberof gauge.messages.StepPositionsRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gauge.messages.StepPositionsRequest} StepPositionsRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StepPositionsRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gauge.messages.StepPositionsRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.filePath = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a StepPositionsRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gauge.messages.StepPositionsRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gauge.messages.StepPositionsRequest} StepPositionsRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StepPositionsRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a StepPositionsRequest message.
             * @function verify
             * @memberof gauge.messages.StepPositionsRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            StepPositionsRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.filePath != null && message.hasOwnProperty("filePath"))
                    if (!$util.isString(message.filePath))
                        return "filePath: string expected";
                return null;
            };

            /**
             * Creates a StepPositionsRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gauge.messages.StepPositionsRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gauge.messages.StepPositionsRequest} StepPositionsRequest
             */
            StepPositionsRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.gauge.messages.StepPositionsRequest)
                    return object;
                var message = new $root.gauge.messages.StepPositionsRequest();
                if (object.filePath != null)
                    message.filePath = String(object.filePath);
                return message;
            };

            /**
             * Creates a plain object from a StepPositionsRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gauge.messages.StepPositionsRequest
             * @static
             * @param {gauge.messages.StepPositionsRequest} message StepPositionsRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            StepPositionsRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.filePath = "";
                if (message.filePath != null && message.hasOwnProperty("filePath"))
                    object.filePath = message.filePath;
                return object;
            };

            /**
             * Converts this StepPositionsRequest to JSON.
             * @function toJSON
             * @memberof gauge.messages.StepPositionsRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            StepPositionsRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return StepPositionsRequest;
        })();

        messages.StepPositionsResponse = (function() {

            /**
             * Properties of a StepPositionsResponse.
             * @memberof gauge.messages
             * @interface IStepPositionsResponse
             * @property {Array.<gauge.messages.StepPositionsResponse.IStepPosition>|null} [stepPositions] Step Position
             * @property {string|null} [error] Error message
             */

            /**
             * Constructs a new StepPositionsResponse.
             * @memberof gauge.messages
             * @classdesc Response for find step positions
             * @implements IStepPositionsResponse
             * @constructor
             * @param {gauge.messages.IStepPositionsResponse=} [properties] Properties to set
             */
            function StepPositionsResponse(properties) {
                this.stepPositions = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Step Position
             * @member {Array.<gauge.messages.StepPositionsResponse.IStepPosition>} stepPositions
             * @memberof gauge.messages.StepPositionsResponse
             * @instance
             */
            StepPositionsResponse.prototype.stepPositions = $util.emptyArray;

            /**
             * Error message
             * @member {string} error
             * @memberof gauge.messages.StepPositionsResponse
             * @instance
             */
            StepPositionsResponse.prototype.error = "";

            /**
             * Creates a new StepPositionsResponse instance using the specified properties.
             * @function create
             * @memberof gauge.messages.StepPositionsResponse
             * @static
             * @param {gauge.messages.IStepPositionsResponse=} [properties] Properties to set
             * @returns {gauge.messages.StepPositionsResponse} StepPositionsResponse instance
             */
            StepPositionsResponse.create = function create(properties) {
                return new StepPositionsResponse(properties);
            };

            /**
             * Encodes the specified StepPositionsResponse message. Does not implicitly {@link gauge.messages.StepPositionsResponse.verify|verify} messages.
             * @function encode
             * @memberof gauge.messages.StepPositionsResponse
             * @static
             * @param {gauge.messages.IStepPositionsResponse} message StepPositionsResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StepPositionsResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.stepPositions != null && message.stepPositions.length)
                    for (var i = 0; i < message.stepPositions.length; ++i)
                        $root.gauge.messages.StepPositionsResponse.StepPosition.encode(message.stepPositions[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.error != null && message.hasOwnProperty("error"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.error);
                return writer;
            };

            /**
             * Encodes the specified StepPositionsResponse message, length delimited. Does not implicitly {@link gauge.messages.StepPositionsResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gauge.messages.StepPositionsResponse
             * @static
             * @param {gauge.messages.IStepPositionsResponse} message StepPositionsResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StepPositionsResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a StepPositionsResponse message from the specified reader or buffer.
             * @function decode
             * @memberof gauge.messages.StepPositionsResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gauge.messages.StepPositionsResponse} StepPositionsResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StepPositionsResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gauge.messages.StepPositionsResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.stepPositions && message.stepPositions.length))
                            message.stepPositions = [];
                        message.stepPositions.push($root.gauge.messages.StepPositionsResponse.StepPosition.decode(reader, reader.uint32()));
                        break;
                    case 2:
                        message.error = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a StepPositionsResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gauge.messages.StepPositionsResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gauge.messages.StepPositionsResponse} StepPositionsResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StepPositionsResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a StepPositionsResponse message.
             * @function verify
             * @memberof gauge.messages.StepPositionsResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            StepPositionsResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.stepPositions != null && message.hasOwnProperty("stepPositions")) {
                    if (!Array.isArray(message.stepPositions))
                        return "stepPositions: array expected";
                    for (var i = 0; i < message.stepPositions.length; ++i) {
                        var error = $root.gauge.messages.StepPositionsResponse.StepPosition.verify(message.stepPositions[i]);
                        if (error)
                            return "stepPositions." + error;
                    }
                }
                if (message.error != null && message.hasOwnProperty("error"))
                    if (!$util.isString(message.error))
                        return "error: string expected";
                return null;
            };

            /**
             * Creates a StepPositionsResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gauge.messages.StepPositionsResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gauge.messages.StepPositionsResponse} StepPositionsResponse
             */
            StepPositionsResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.gauge.messages.StepPositionsResponse)
                    return object;
                var message = new $root.gauge.messages.StepPositionsResponse();
                if (object.stepPositions) {
                    if (!Array.isArray(object.stepPositions))
                        throw TypeError(".gauge.messages.StepPositionsResponse.stepPositions: array expected");
                    message.stepPositions = [];
                    for (var i = 0; i < object.stepPositions.length; ++i) {
                        if (typeof object.stepPositions[i] !== "object")
                            throw TypeError(".gauge.messages.StepPositionsResponse.stepPositions: object expected");
                        message.stepPositions[i] = $root.gauge.messages.StepPositionsResponse.StepPosition.fromObject(object.stepPositions[i]);
                    }
                }
                if (object.error != null)
                    message.error = String(object.error);
                return message;
            };

            /**
             * Creates a plain object from a StepPositionsResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gauge.messages.StepPositionsResponse
             * @static
             * @param {gauge.messages.StepPositionsResponse} message StepPositionsResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            StepPositionsResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.stepPositions = [];
                if (options.defaults)
                    object.error = "";
                if (message.stepPositions && message.stepPositions.length) {
                    object.stepPositions = [];
                    for (var j = 0; j < message.stepPositions.length; ++j)
                        object.stepPositions[j] = $root.gauge.messages.StepPositionsResponse.StepPosition.toObject(message.stepPositions[j], options);
                }
                if (message.error != null && message.hasOwnProperty("error"))
                    object.error = message.error;
                return object;
            };

            /**
             * Converts this StepPositionsResponse to JSON.
             * @function toJSON
             * @memberof gauge.messages.StepPositionsResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            StepPositionsResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            StepPositionsResponse.StepPosition = (function() {

                /**
                 * Properties of a StepPosition.
                 * @memberof gauge.messages.StepPositionsResponse
                 * @interface IStepPosition
                 * @property {string|null} [stepValue] Step Value
                 * @property {gauge.messages.ISpan|null} [span] Range of step
                 */

                /**
                 * Constructs a new StepPosition.
                 * @memberof gauge.messages.StepPositionsResponse
                 * @classdesc Step position for each step implementation
                 * @implements IStepPosition
                 * @constructor
                 * @param {gauge.messages.StepPositionsResponse.IStepPosition=} [properties] Properties to set
                 */
                function StepPosition(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Step Value
                 * @member {string} stepValue
                 * @memberof gauge.messages.StepPositionsResponse.StepPosition
                 * @instance
                 */
                StepPosition.prototype.stepValue = "";

                /**
                 * Range of step
                 * @member {gauge.messages.ISpan|null|undefined} span
                 * @memberof gauge.messages.StepPositionsResponse.StepPosition
                 * @instance
                 */
                StepPosition.prototype.span = null;

                /**
                 * Creates a new StepPosition instance using the specified properties.
                 * @function create
                 * @memberof gauge.messages.StepPositionsResponse.StepPosition
                 * @static
                 * @param {gauge.messages.StepPositionsResponse.IStepPosition=} [properties] Properties to set
                 * @returns {gauge.messages.StepPositionsResponse.StepPosition} StepPosition instance
                 */
                StepPosition.create = function create(properties) {
                    return new StepPosition(properties);
                };

                /**
                 * Encodes the specified StepPosition message. Does not implicitly {@link gauge.messages.StepPositionsResponse.StepPosition.verify|verify} messages.
                 * @function encode
                 * @memberof gauge.messages.StepPositionsResponse.StepPosition
                 * @static
                 * @param {gauge.messages.StepPositionsResponse.IStepPosition} message StepPosition message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                StepPosition.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.stepValue != null && message.hasOwnProperty("stepValue"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.stepValue);
                    if (message.span != null && message.hasOwnProperty("span"))
                        $root.gauge.messages.Span.encode(message.span, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified StepPosition message, length delimited. Does not implicitly {@link gauge.messages.StepPositionsResponse.StepPosition.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof gauge.messages.StepPositionsResponse.StepPosition
                 * @static
                 * @param {gauge.messages.StepPositionsResponse.IStepPosition} message StepPosition message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                StepPosition.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a StepPosition message from the specified reader or buffer.
                 * @function decode
                 * @memberof gauge.messages.StepPositionsResponse.StepPosition
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {gauge.messages.StepPositionsResponse.StepPosition} StepPosition
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                StepPosition.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gauge.messages.StepPositionsResponse.StepPosition();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.stepValue = reader.string();
                            break;
                        case 2:
                            message.span = $root.gauge.messages.Span.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a StepPosition message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof gauge.messages.StepPositionsResponse.StepPosition
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {gauge.messages.StepPositionsResponse.StepPosition} StepPosition
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                StepPosition.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a StepPosition message.
                 * @function verify
                 * @memberof gauge.messages.StepPositionsResponse.StepPosition
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                StepPosition.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.stepValue != null && message.hasOwnProperty("stepValue"))
                        if (!$util.isString(message.stepValue))
                            return "stepValue: string expected";
                    if (message.span != null && message.hasOwnProperty("span")) {
                        var error = $root.gauge.messages.Span.verify(message.span);
                        if (error)
                            return "span." + error;
                    }
                    return null;
                };

                /**
                 * Creates a StepPosition message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof gauge.messages.StepPositionsResponse.StepPosition
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {gauge.messages.StepPositionsResponse.StepPosition} StepPosition
                 */
                StepPosition.fromObject = function fromObject(object) {
                    if (object instanceof $root.gauge.messages.StepPositionsResponse.StepPosition)
                        return object;
                    var message = new $root.gauge.messages.StepPositionsResponse.StepPosition();
                    if (object.stepValue != null)
                        message.stepValue = String(object.stepValue);
                    if (object.span != null) {
                        if (typeof object.span !== "object")
                            throw TypeError(".gauge.messages.StepPositionsResponse.StepPosition.span: object expected");
                        message.span = $root.gauge.messages.Span.fromObject(object.span);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a StepPosition message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof gauge.messages.StepPositionsResponse.StepPosition
                 * @static
                 * @param {gauge.messages.StepPositionsResponse.StepPosition} message StepPosition
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                StepPosition.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.stepValue = "";
                        object.span = null;
                    }
                    if (message.stepValue != null && message.hasOwnProperty("stepValue"))
                        object.stepValue = message.stepValue;
                    if (message.span != null && message.hasOwnProperty("span"))
                        object.span = $root.gauge.messages.Span.toObject(message.span, options);
                    return object;
                };

                /**
                 * Converts this StepPosition to JSON.
                 * @function toJSON
                 * @memberof gauge.messages.StepPositionsResponse.StepPosition
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                StepPosition.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return StepPosition;
            })();

            return StepPositionsResponse;
        })();

        messages.ImplementationFileGlobPatternRequest = (function() {

            /**
             * Properties of an ImplementationFileGlobPatternRequest.
             * @memberof gauge.messages
             * @interface IImplementationFileGlobPatternRequest
             */

            /**
             * Constructs a new ImplementationFileGlobPatternRequest.
             * @memberof gauge.messages
             * @classdesc Request for getting Implementation file glob pattern
             * @implements IImplementationFileGlobPatternRequest
             * @constructor
             * @param {gauge.messages.IImplementationFileGlobPatternRequest=} [properties] Properties to set
             */
            function ImplementationFileGlobPatternRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new ImplementationFileGlobPatternRequest instance using the specified properties.
             * @function create
             * @memberof gauge.messages.ImplementationFileGlobPatternRequest
             * @static
             * @param {gauge.messages.IImplementationFileGlobPatternRequest=} [properties] Properties to set
             * @returns {gauge.messages.ImplementationFileGlobPatternRequest} ImplementationFileGlobPatternRequest instance
             */
            ImplementationFileGlobPatternRequest.create = function create(properties) {
                return new ImplementationFileGlobPatternRequest(properties);
            };

            /**
             * Encodes the specified ImplementationFileGlobPatternRequest message. Does not implicitly {@link gauge.messages.ImplementationFileGlobPatternRequest.verify|verify} messages.
             * @function encode
             * @memberof gauge.messages.ImplementationFileGlobPatternRequest
             * @static
             * @param {gauge.messages.IImplementationFileGlobPatternRequest} message ImplementationFileGlobPatternRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ImplementationFileGlobPatternRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified ImplementationFileGlobPatternRequest message, length delimited. Does not implicitly {@link gauge.messages.ImplementationFileGlobPatternRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gauge.messages.ImplementationFileGlobPatternRequest
             * @static
             * @param {gauge.messages.IImplementationFileGlobPatternRequest} message ImplementationFileGlobPatternRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ImplementationFileGlobPatternRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an ImplementationFileGlobPatternRequest message from the specified reader or buffer.
             * @function decode
             * @memberof gauge.messages.ImplementationFileGlobPatternRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gauge.messages.ImplementationFileGlobPatternRequest} ImplementationFileGlobPatternRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ImplementationFileGlobPatternRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gauge.messages.ImplementationFileGlobPatternRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an ImplementationFileGlobPatternRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gauge.messages.ImplementationFileGlobPatternRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gauge.messages.ImplementationFileGlobPatternRequest} ImplementationFileGlobPatternRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ImplementationFileGlobPatternRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an ImplementationFileGlobPatternRequest message.
             * @function verify
             * @memberof gauge.messages.ImplementationFileGlobPatternRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ImplementationFileGlobPatternRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates an ImplementationFileGlobPatternRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gauge.messages.ImplementationFileGlobPatternRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gauge.messages.ImplementationFileGlobPatternRequest} ImplementationFileGlobPatternRequest
             */
            ImplementationFileGlobPatternRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.gauge.messages.ImplementationFileGlobPatternRequest)
                    return object;
                return new $root.gauge.messages.ImplementationFileGlobPatternRequest();
            };

            /**
             * Creates a plain object from an ImplementationFileGlobPatternRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gauge.messages.ImplementationFileGlobPatternRequest
             * @static
             * @param {gauge.messages.ImplementationFileGlobPatternRequest} message ImplementationFileGlobPatternRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ImplementationFileGlobPatternRequest.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this ImplementationFileGlobPatternRequest to JSON.
             * @function toJSON
             * @memberof gauge.messages.ImplementationFileGlobPatternRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ImplementationFileGlobPatternRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ImplementationFileGlobPatternRequest;
        })();

        messages.ImplementationFileGlobPatternResponse = (function() {

            /**
             * Properties of an ImplementationFileGlobPatternResponse.
             * @memberof gauge.messages
             * @interface IImplementationFileGlobPatternResponse
             * @property {Array.<string>|null} [globPatterns] List of implementation file glob patterns
             */

            /**
             * Constructs a new ImplementationFileGlobPatternResponse.
             * @memberof gauge.messages
             * @classdesc Response for getting Implementation file glob pattern
             * @implements IImplementationFileGlobPatternResponse
             * @constructor
             * @param {gauge.messages.IImplementationFileGlobPatternResponse=} [properties] Properties to set
             */
            function ImplementationFileGlobPatternResponse(properties) {
                this.globPatterns = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * List of implementation file glob patterns
             * @member {Array.<string>} globPatterns
             * @memberof gauge.messages.ImplementationFileGlobPatternResponse
             * @instance
             */
            ImplementationFileGlobPatternResponse.prototype.globPatterns = $util.emptyArray;

            /**
             * Creates a new ImplementationFileGlobPatternResponse instance using the specified properties.
             * @function create
             * @memberof gauge.messages.ImplementationFileGlobPatternResponse
             * @static
             * @param {gauge.messages.IImplementationFileGlobPatternResponse=} [properties] Properties to set
             * @returns {gauge.messages.ImplementationFileGlobPatternResponse} ImplementationFileGlobPatternResponse instance
             */
            ImplementationFileGlobPatternResponse.create = function create(properties) {
                return new ImplementationFileGlobPatternResponse(properties);
            };

            /**
             * Encodes the specified ImplementationFileGlobPatternResponse message. Does not implicitly {@link gauge.messages.ImplementationFileGlobPatternResponse.verify|verify} messages.
             * @function encode
             * @memberof gauge.messages.ImplementationFileGlobPatternResponse
             * @static
             * @param {gauge.messages.IImplementationFileGlobPatternResponse} message ImplementationFileGlobPatternResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ImplementationFileGlobPatternResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.globPatterns != null && message.globPatterns.length)
                    for (var i = 0; i < message.globPatterns.length; ++i)
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.globPatterns[i]);
                return writer;
            };

            /**
             * Encodes the specified ImplementationFileGlobPatternResponse message, length delimited. Does not implicitly {@link gauge.messages.ImplementationFileGlobPatternResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gauge.messages.ImplementationFileGlobPatternResponse
             * @static
             * @param {gauge.messages.IImplementationFileGlobPatternResponse} message ImplementationFileGlobPatternResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ImplementationFileGlobPatternResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an ImplementationFileGlobPatternResponse message from the specified reader or buffer.
             * @function decode
             * @memberof gauge.messages.ImplementationFileGlobPatternResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gauge.messages.ImplementationFileGlobPatternResponse} ImplementationFileGlobPatternResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ImplementationFileGlobPatternResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gauge.messages.ImplementationFileGlobPatternResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.globPatterns && message.globPatterns.length))
                            message.globPatterns = [];
                        message.globPatterns.push(reader.string());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an ImplementationFileGlobPatternResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gauge.messages.ImplementationFileGlobPatternResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gauge.messages.ImplementationFileGlobPatternResponse} ImplementationFileGlobPatternResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ImplementationFileGlobPatternResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an ImplementationFileGlobPatternResponse message.
             * @function verify
             * @memberof gauge.messages.ImplementationFileGlobPatternResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ImplementationFileGlobPatternResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.globPatterns != null && message.hasOwnProperty("globPatterns")) {
                    if (!Array.isArray(message.globPatterns))
                        return "globPatterns: array expected";
                    for (var i = 0; i < message.globPatterns.length; ++i)
                        if (!$util.isString(message.globPatterns[i]))
                            return "globPatterns: string[] expected";
                }
                return null;
            };

            /**
             * Creates an ImplementationFileGlobPatternResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gauge.messages.ImplementationFileGlobPatternResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gauge.messages.ImplementationFileGlobPatternResponse} ImplementationFileGlobPatternResponse
             */
            ImplementationFileGlobPatternResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.gauge.messages.ImplementationFileGlobPatternResponse)
                    return object;
                var message = new $root.gauge.messages.ImplementationFileGlobPatternResponse();
                if (object.globPatterns) {
                    if (!Array.isArray(object.globPatterns))
                        throw TypeError(".gauge.messages.ImplementationFileGlobPatternResponse.globPatterns: array expected");
                    message.globPatterns = [];
                    for (var i = 0; i < object.globPatterns.length; ++i)
                        message.globPatterns[i] = String(object.globPatterns[i]);
                }
                return message;
            };

            /**
             * Creates a plain object from an ImplementationFileGlobPatternResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gauge.messages.ImplementationFileGlobPatternResponse
             * @static
             * @param {gauge.messages.ImplementationFileGlobPatternResponse} message ImplementationFileGlobPatternResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ImplementationFileGlobPatternResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.globPatterns = [];
                if (message.globPatterns && message.globPatterns.length) {
                    object.globPatterns = [];
                    for (var j = 0; j < message.globPatterns.length; ++j)
                        object.globPatterns[j] = message.globPatterns[j];
                }
                return object;
            };

            /**
             * Converts this ImplementationFileGlobPatternResponse to JSON.
             * @function toJSON
             * @memberof gauge.messages.ImplementationFileGlobPatternResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ImplementationFileGlobPatternResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ImplementationFileGlobPatternResponse;
        })();

        messages.ImplementationFileListRequest = (function() {

            /**
             * Properties of an ImplementationFileListRequest.
             * @memberof gauge.messages
             * @interface IImplementationFileListRequest
             */

            /**
             * Constructs a new ImplementationFileListRequest.
             * @memberof gauge.messages
             * @classdesc Request for getting Implementation file list
             * @implements IImplementationFileListRequest
             * @constructor
             * @param {gauge.messages.IImplementationFileListRequest=} [properties] Properties to set
             */
            function ImplementationFileListRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new ImplementationFileListRequest instance using the specified properties.
             * @function create
             * @memberof gauge.messages.ImplementationFileListRequest
             * @static
             * @param {gauge.messages.IImplementationFileListRequest=} [properties] Properties to set
             * @returns {gauge.messages.ImplementationFileListRequest} ImplementationFileListRequest instance
             */
            ImplementationFileListRequest.create = function create(properties) {
                return new ImplementationFileListRequest(properties);
            };

            /**
             * Encodes the specified ImplementationFileListRequest message. Does not implicitly {@link gauge.messages.ImplementationFileListRequest.verify|verify} messages.
             * @function encode
             * @memberof gauge.messages.ImplementationFileListRequest
             * @static
             * @param {gauge.messages.IImplementationFileListRequest} message ImplementationFileListRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ImplementationFileListRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified ImplementationFileListRequest message, length delimited. Does not implicitly {@link gauge.messages.ImplementationFileListRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gauge.messages.ImplementationFileListRequest
             * @static
             * @param {gauge.messages.IImplementationFileListRequest} message ImplementationFileListRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ImplementationFileListRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an ImplementationFileListRequest message from the specified reader or buffer.
             * @function decode
             * @memberof gauge.messages.ImplementationFileListRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gauge.messages.ImplementationFileListRequest} ImplementationFileListRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ImplementationFileListRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gauge.messages.ImplementationFileListRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an ImplementationFileListRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gauge.messages.ImplementationFileListRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gauge.messages.ImplementationFileListRequest} ImplementationFileListRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ImplementationFileListRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an ImplementationFileListRequest message.
             * @function verify
             * @memberof gauge.messages.ImplementationFileListRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ImplementationFileListRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates an ImplementationFileListRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gauge.messages.ImplementationFileListRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gauge.messages.ImplementationFileListRequest} ImplementationFileListRequest
             */
            ImplementationFileListRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.gauge.messages.ImplementationFileListRequest)
                    return object;
                return new $root.gauge.messages.ImplementationFileListRequest();
            };

            /**
             * Creates a plain object from an ImplementationFileListRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gauge.messages.ImplementationFileListRequest
             * @static
             * @param {gauge.messages.ImplementationFileListRequest} message ImplementationFileListRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ImplementationFileListRequest.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this ImplementationFileListRequest to JSON.
             * @function toJSON
             * @memberof gauge.messages.ImplementationFileListRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ImplementationFileListRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ImplementationFileListRequest;
        })();

        messages.ImplementationFileListResponse = (function() {

            /**
             * Properties of an ImplementationFileListResponse.
             * @memberof gauge.messages
             * @interface IImplementationFileListResponse
             * @property {Array.<string>|null} [implementationFilePaths] List of implementation files
             */

            /**
             * Constructs a new ImplementationFileListResponse.
             * @memberof gauge.messages
             * @classdesc Response for getting Implementation file list
             * @implements IImplementationFileListResponse
             * @constructor
             * @param {gauge.messages.IImplementationFileListResponse=} [properties] Properties to set
             */
            function ImplementationFileListResponse(properties) {
                this.implementationFilePaths = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * List of implementation files
             * @member {Array.<string>} implementationFilePaths
             * @memberof gauge.messages.ImplementationFileListResponse
             * @instance
             */
            ImplementationFileListResponse.prototype.implementationFilePaths = $util.emptyArray;

            /**
             * Creates a new ImplementationFileListResponse instance using the specified properties.
             * @function create
             * @memberof gauge.messages.ImplementationFileListResponse
             * @static
             * @param {gauge.messages.IImplementationFileListResponse=} [properties] Properties to set
             * @returns {gauge.messages.ImplementationFileListResponse} ImplementationFileListResponse instance
             */
            ImplementationFileListResponse.create = function create(properties) {
                return new ImplementationFileListResponse(properties);
            };

            /**
             * Encodes the specified ImplementationFileListResponse message. Does not implicitly {@link gauge.messages.ImplementationFileListResponse.verify|verify} messages.
             * @function encode
             * @memberof gauge.messages.ImplementationFileListResponse
             * @static
             * @param {gauge.messages.IImplementationFileListResponse} message ImplementationFileListResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ImplementationFileListResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.implementationFilePaths != null && message.implementationFilePaths.length)
                    for (var i = 0; i < message.implementationFilePaths.length; ++i)
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.implementationFilePaths[i]);
                return writer;
            };

            /**
             * Encodes the specified ImplementationFileListResponse message, length delimited. Does not implicitly {@link gauge.messages.ImplementationFileListResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gauge.messages.ImplementationFileListResponse
             * @static
             * @param {gauge.messages.IImplementationFileListResponse} message ImplementationFileListResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ImplementationFileListResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an ImplementationFileListResponse message from the specified reader or buffer.
             * @function decode
             * @memberof gauge.messages.ImplementationFileListResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gauge.messages.ImplementationFileListResponse} ImplementationFileListResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ImplementationFileListResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gauge.messages.ImplementationFileListResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.implementationFilePaths && message.implementationFilePaths.length))
                            message.implementationFilePaths = [];
                        message.implementationFilePaths.push(reader.string());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an ImplementationFileListResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gauge.messages.ImplementationFileListResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gauge.messages.ImplementationFileListResponse} ImplementationFileListResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ImplementationFileListResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an ImplementationFileListResponse message.
             * @function verify
             * @memberof gauge.messages.ImplementationFileListResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ImplementationFileListResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.implementationFilePaths != null && message.hasOwnProperty("implementationFilePaths")) {
                    if (!Array.isArray(message.implementationFilePaths))
                        return "implementationFilePaths: array expected";
                    for (var i = 0; i < message.implementationFilePaths.length; ++i)
                        if (!$util.isString(message.implementationFilePaths[i]))
                            return "implementationFilePaths: string[] expected";
                }
                return null;
            };

            /**
             * Creates an ImplementationFileListResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gauge.messages.ImplementationFileListResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gauge.messages.ImplementationFileListResponse} ImplementationFileListResponse
             */
            ImplementationFileListResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.gauge.messages.ImplementationFileListResponse)
                    return object;
                var message = new $root.gauge.messages.ImplementationFileListResponse();
                if (object.implementationFilePaths) {
                    if (!Array.isArray(object.implementationFilePaths))
                        throw TypeError(".gauge.messages.ImplementationFileListResponse.implementationFilePaths: array expected");
                    message.implementationFilePaths = [];
                    for (var i = 0; i < object.implementationFilePaths.length; ++i)
                        message.implementationFilePaths[i] = String(object.implementationFilePaths[i]);
                }
                return message;
            };

            /**
             * Creates a plain object from an ImplementationFileListResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gauge.messages.ImplementationFileListResponse
             * @static
             * @param {gauge.messages.ImplementationFileListResponse} message ImplementationFileListResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ImplementationFileListResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.implementationFilePaths = [];
                if (message.implementationFilePaths && message.implementationFilePaths.length) {
                    object.implementationFilePaths = [];
                    for (var j = 0; j < message.implementationFilePaths.length; ++j)
                        object.implementationFilePaths[j] = message.implementationFilePaths[j];
                }
                return object;
            };

            /**
             * Converts this ImplementationFileListResponse to JSON.
             * @function toJSON
             * @memberof gauge.messages.ImplementationFileListResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ImplementationFileListResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ImplementationFileListResponse;
        })();

        messages.StubImplementationCodeRequest = (function() {

            /**
             * Properties of a StubImplementationCodeRequest.
             * @memberof gauge.messages
             * @interface IStubImplementationCodeRequest
             * @property {string|null} [implementationFilePath] Path of the file where the new stub implementation will be added
             * @property {Array.<string>|null} [codes] List of implementation codes to be appended to implementation file.
             */

            /**
             * Constructs a new StubImplementationCodeRequest.
             * @memberof gauge.messages
             * @classdesc Request for injecting code snippet into implementation file
             * @implements IStubImplementationCodeRequest
             * @constructor
             * @param {gauge.messages.IStubImplementationCodeRequest=} [properties] Properties to set
             */
            function StubImplementationCodeRequest(properties) {
                this.codes = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Path of the file where the new stub implementation will be added
             * @member {string} implementationFilePath
             * @memberof gauge.messages.StubImplementationCodeRequest
             * @instance
             */
            StubImplementationCodeRequest.prototype.implementationFilePath = "";

            /**
             * List of implementation codes to be appended to implementation file.
             * @member {Array.<string>} codes
             * @memberof gauge.messages.StubImplementationCodeRequest
             * @instance
             */
            StubImplementationCodeRequest.prototype.codes = $util.emptyArray;

            /**
             * Creates a new StubImplementationCodeRequest instance using the specified properties.
             * @function create
             * @memberof gauge.messages.StubImplementationCodeRequest
             * @static
             * @param {gauge.messages.IStubImplementationCodeRequest=} [properties] Properties to set
             * @returns {gauge.messages.StubImplementationCodeRequest} StubImplementationCodeRequest instance
             */
            StubImplementationCodeRequest.create = function create(properties) {
                return new StubImplementationCodeRequest(properties);
            };

            /**
             * Encodes the specified StubImplementationCodeRequest message. Does not implicitly {@link gauge.messages.StubImplementationCodeRequest.verify|verify} messages.
             * @function encode
             * @memberof gauge.messages.StubImplementationCodeRequest
             * @static
             * @param {gauge.messages.IStubImplementationCodeRequest} message StubImplementationCodeRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StubImplementationCodeRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.implementationFilePath != null && message.hasOwnProperty("implementationFilePath"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.implementationFilePath);
                if (message.codes != null && message.codes.length)
                    for (var i = 0; i < message.codes.length; ++i)
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.codes[i]);
                return writer;
            };

            /**
             * Encodes the specified StubImplementationCodeRequest message, length delimited. Does not implicitly {@link gauge.messages.StubImplementationCodeRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gauge.messages.StubImplementationCodeRequest
             * @static
             * @param {gauge.messages.IStubImplementationCodeRequest} message StubImplementationCodeRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StubImplementationCodeRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a StubImplementationCodeRequest message from the specified reader or buffer.
             * @function decode
             * @memberof gauge.messages.StubImplementationCodeRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gauge.messages.StubImplementationCodeRequest} StubImplementationCodeRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StubImplementationCodeRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gauge.messages.StubImplementationCodeRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.implementationFilePath = reader.string();
                        break;
                    case 2:
                        if (!(message.codes && message.codes.length))
                            message.codes = [];
                        message.codes.push(reader.string());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a StubImplementationCodeRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gauge.messages.StubImplementationCodeRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gauge.messages.StubImplementationCodeRequest} StubImplementationCodeRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StubImplementationCodeRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a StubImplementationCodeRequest message.
             * @function verify
             * @memberof gauge.messages.StubImplementationCodeRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            StubImplementationCodeRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.implementationFilePath != null && message.hasOwnProperty("implementationFilePath"))
                    if (!$util.isString(message.implementationFilePath))
                        return "implementationFilePath: string expected";
                if (message.codes != null && message.hasOwnProperty("codes")) {
                    if (!Array.isArray(message.codes))
                        return "codes: array expected";
                    for (var i = 0; i < message.codes.length; ++i)
                        if (!$util.isString(message.codes[i]))
                            return "codes: string[] expected";
                }
                return null;
            };

            /**
             * Creates a StubImplementationCodeRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gauge.messages.StubImplementationCodeRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gauge.messages.StubImplementationCodeRequest} StubImplementationCodeRequest
             */
            StubImplementationCodeRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.gauge.messages.StubImplementationCodeRequest)
                    return object;
                var message = new $root.gauge.messages.StubImplementationCodeRequest();
                if (object.implementationFilePath != null)
                    message.implementationFilePath = String(object.implementationFilePath);
                if (object.codes) {
                    if (!Array.isArray(object.codes))
                        throw TypeError(".gauge.messages.StubImplementationCodeRequest.codes: array expected");
                    message.codes = [];
                    for (var i = 0; i < object.codes.length; ++i)
                        message.codes[i] = String(object.codes[i]);
                }
                return message;
            };

            /**
             * Creates a plain object from a StubImplementationCodeRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gauge.messages.StubImplementationCodeRequest
             * @static
             * @param {gauge.messages.StubImplementationCodeRequest} message StubImplementationCodeRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            StubImplementationCodeRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.codes = [];
                if (options.defaults)
                    object.implementationFilePath = "";
                if (message.implementationFilePath != null && message.hasOwnProperty("implementationFilePath"))
                    object.implementationFilePath = message.implementationFilePath;
                if (message.codes && message.codes.length) {
                    object.codes = [];
                    for (var j = 0; j < message.codes.length; ++j)
                        object.codes[j] = message.codes[j];
                }
                return object;
            };

            /**
             * Converts this StubImplementationCodeRequest to JSON.
             * @function toJSON
             * @memberof gauge.messages.StubImplementationCodeRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            StubImplementationCodeRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return StubImplementationCodeRequest;
        })();

        messages.TextDiff = (function() {

            /**
             * Properties of a TextDiff.
             * @memberof gauge.messages
             * @interface ITextDiff
             * @property {gauge.messages.ISpan|null} [span] Range of file to be replaced
             * @property {string|null} [content] New content to replace the content in the span
             */

            /**
             * Constructs a new TextDiff.
             * @memberof gauge.messages
             * @classdesc A Single Replace Diff Element to be applied
             * @implements ITextDiff
             * @constructor
             * @param {gauge.messages.ITextDiff=} [properties] Properties to set
             */
            function TextDiff(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Range of file to be replaced
             * @member {gauge.messages.ISpan|null|undefined} span
             * @memberof gauge.messages.TextDiff
             * @instance
             */
            TextDiff.prototype.span = null;

            /**
             * New content to replace the content in the span
             * @member {string} content
             * @memberof gauge.messages.TextDiff
             * @instance
             */
            TextDiff.prototype.content = "";

            /**
             * Creates a new TextDiff instance using the specified properties.
             * @function create
             * @memberof gauge.messages.TextDiff
             * @static
             * @param {gauge.messages.ITextDiff=} [properties] Properties to set
             * @returns {gauge.messages.TextDiff} TextDiff instance
             */
            TextDiff.create = function create(properties) {
                return new TextDiff(properties);
            };

            /**
             * Encodes the specified TextDiff message. Does not implicitly {@link gauge.messages.TextDiff.verify|verify} messages.
             * @function encode
             * @memberof gauge.messages.TextDiff
             * @static
             * @param {gauge.messages.ITextDiff} message TextDiff message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TextDiff.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.span != null && message.hasOwnProperty("span"))
                    $root.gauge.messages.Span.encode(message.span, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.content != null && message.hasOwnProperty("content"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.content);
                return writer;
            };

            /**
             * Encodes the specified TextDiff message, length delimited. Does not implicitly {@link gauge.messages.TextDiff.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gauge.messages.TextDiff
             * @static
             * @param {gauge.messages.ITextDiff} message TextDiff message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TextDiff.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a TextDiff message from the specified reader or buffer.
             * @function decode
             * @memberof gauge.messages.TextDiff
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gauge.messages.TextDiff} TextDiff
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TextDiff.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gauge.messages.TextDiff();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.span = $root.gauge.messages.Span.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.content = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a TextDiff message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gauge.messages.TextDiff
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gauge.messages.TextDiff} TextDiff
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TextDiff.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a TextDiff message.
             * @function verify
             * @memberof gauge.messages.TextDiff
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TextDiff.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.span != null && message.hasOwnProperty("span")) {
                    var error = $root.gauge.messages.Span.verify(message.span);
                    if (error)
                        return "span." + error;
                }
                if (message.content != null && message.hasOwnProperty("content"))
                    if (!$util.isString(message.content))
                        return "content: string expected";
                return null;
            };

            /**
             * Creates a TextDiff message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gauge.messages.TextDiff
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gauge.messages.TextDiff} TextDiff
             */
            TextDiff.fromObject = function fromObject(object) {
                if (object instanceof $root.gauge.messages.TextDiff)
                    return object;
                var message = new $root.gauge.messages.TextDiff();
                if (object.span != null) {
                    if (typeof object.span !== "object")
                        throw TypeError(".gauge.messages.TextDiff.span: object expected");
                    message.span = $root.gauge.messages.Span.fromObject(object.span);
                }
                if (object.content != null)
                    message.content = String(object.content);
                return message;
            };

            /**
             * Creates a plain object from a TextDiff message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gauge.messages.TextDiff
             * @static
             * @param {gauge.messages.TextDiff} message TextDiff
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            TextDiff.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.span = null;
                    object.content = "";
                }
                if (message.span != null && message.hasOwnProperty("span"))
                    object.span = $root.gauge.messages.Span.toObject(message.span, options);
                if (message.content != null && message.hasOwnProperty("content"))
                    object.content = message.content;
                return object;
            };

            /**
             * Converts this TextDiff to JSON.
             * @function toJSON
             * @memberof gauge.messages.TextDiff
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            TextDiff.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return TextDiff;
        })();

        messages.FileDiff = (function() {

            /**
             * Properties of a FileDiff.
             * @memberof gauge.messages
             * @interface IFileDiff
             * @property {string|null} [filePath] File Path where the new content needs to be put in
             * @property {Array.<gauge.messages.ITextDiff>|null} [textDiffs] The diffs which need to be applied to this file
             */

            /**
             * Constructs a new FileDiff.
             * @memberof gauge.messages
             * @classdesc Diffs to be applied to a file
             * @implements IFileDiff
             * @constructor
             * @param {gauge.messages.IFileDiff=} [properties] Properties to set
             */
            function FileDiff(properties) {
                this.textDiffs = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * File Path where the new content needs to be put in
             * @member {string} filePath
             * @memberof gauge.messages.FileDiff
             * @instance
             */
            FileDiff.prototype.filePath = "";

            /**
             * The diffs which need to be applied to this file
             * @member {Array.<gauge.messages.ITextDiff>} textDiffs
             * @memberof gauge.messages.FileDiff
             * @instance
             */
            FileDiff.prototype.textDiffs = $util.emptyArray;

            /**
             * Creates a new FileDiff instance using the specified properties.
             * @function create
             * @memberof gauge.messages.FileDiff
             * @static
             * @param {gauge.messages.IFileDiff=} [properties] Properties to set
             * @returns {gauge.messages.FileDiff} FileDiff instance
             */
            FileDiff.create = function create(properties) {
                return new FileDiff(properties);
            };

            /**
             * Encodes the specified FileDiff message. Does not implicitly {@link gauge.messages.FileDiff.verify|verify} messages.
             * @function encode
             * @memberof gauge.messages.FileDiff
             * @static
             * @param {gauge.messages.IFileDiff} message FileDiff message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FileDiff.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.filePath != null && message.hasOwnProperty("filePath"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.filePath);
                if (message.textDiffs != null && message.textDiffs.length)
                    for (var i = 0; i < message.textDiffs.length; ++i)
                        $root.gauge.messages.TextDiff.encode(message.textDiffs[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified FileDiff message, length delimited. Does not implicitly {@link gauge.messages.FileDiff.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gauge.messages.FileDiff
             * @static
             * @param {gauge.messages.IFileDiff} message FileDiff message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FileDiff.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a FileDiff message from the specified reader or buffer.
             * @function decode
             * @memberof gauge.messages.FileDiff
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gauge.messages.FileDiff} FileDiff
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FileDiff.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gauge.messages.FileDiff();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.filePath = reader.string();
                        break;
                    case 2:
                        if (!(message.textDiffs && message.textDiffs.length))
                            message.textDiffs = [];
                        message.textDiffs.push($root.gauge.messages.TextDiff.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a FileDiff message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gauge.messages.FileDiff
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gauge.messages.FileDiff} FileDiff
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FileDiff.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a FileDiff message.
             * @function verify
             * @memberof gauge.messages.FileDiff
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FileDiff.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.filePath != null && message.hasOwnProperty("filePath"))
                    if (!$util.isString(message.filePath))
                        return "filePath: string expected";
                if (message.textDiffs != null && message.hasOwnProperty("textDiffs")) {
                    if (!Array.isArray(message.textDiffs))
                        return "textDiffs: array expected";
                    for (var i = 0; i < message.textDiffs.length; ++i) {
                        var error = $root.gauge.messages.TextDiff.verify(message.textDiffs[i]);
                        if (error)
                            return "textDiffs." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a FileDiff message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gauge.messages.FileDiff
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gauge.messages.FileDiff} FileDiff
             */
            FileDiff.fromObject = function fromObject(object) {
                if (object instanceof $root.gauge.messages.FileDiff)
                    return object;
                var message = new $root.gauge.messages.FileDiff();
                if (object.filePath != null)
                    message.filePath = String(object.filePath);
                if (object.textDiffs) {
                    if (!Array.isArray(object.textDiffs))
                        throw TypeError(".gauge.messages.FileDiff.textDiffs: array expected");
                    message.textDiffs = [];
                    for (var i = 0; i < object.textDiffs.length; ++i) {
                        if (typeof object.textDiffs[i] !== "object")
                            throw TypeError(".gauge.messages.FileDiff.textDiffs: object expected");
                        message.textDiffs[i] = $root.gauge.messages.TextDiff.fromObject(object.textDiffs[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a FileDiff message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gauge.messages.FileDiff
             * @static
             * @param {gauge.messages.FileDiff} message FileDiff
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FileDiff.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.textDiffs = [];
                if (options.defaults)
                    object.filePath = "";
                if (message.filePath != null && message.hasOwnProperty("filePath"))
                    object.filePath = message.filePath;
                if (message.textDiffs && message.textDiffs.length) {
                    object.textDiffs = [];
                    for (var j = 0; j < message.textDiffs.length; ++j)
                        object.textDiffs[j] = $root.gauge.messages.TextDiff.toObject(message.textDiffs[j], options);
                }
                return object;
            };

            /**
             * Converts this FileDiff to JSON.
             * @function toJSON
             * @memberof gauge.messages.FileDiff
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FileDiff.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return FileDiff;
        })();

        messages.KeepAlive = (function() {

            /**
             * Properties of a KeepAlive.
             * @memberof gauge.messages
             * @interface IKeepAlive
             * @property {string|null} [pluginId] ID of the plugin initiating this request
             */

            /**
             * Constructs a new KeepAlive.
             * @memberof gauge.messages
             * @classdesc Tell gauge to reset the kill timer, thus extending the life
             * @implements IKeepAlive
             * @constructor
             * @param {gauge.messages.IKeepAlive=} [properties] Properties to set
             */
            function KeepAlive(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ID of the plugin initiating this request
             * @member {string} pluginId
             * @memberof gauge.messages.KeepAlive
             * @instance
             */
            KeepAlive.prototype.pluginId = "";

            /**
             * Creates a new KeepAlive instance using the specified properties.
             * @function create
             * @memberof gauge.messages.KeepAlive
             * @static
             * @param {gauge.messages.IKeepAlive=} [properties] Properties to set
             * @returns {gauge.messages.KeepAlive} KeepAlive instance
             */
            KeepAlive.create = function create(properties) {
                return new KeepAlive(properties);
            };

            /**
             * Encodes the specified KeepAlive message. Does not implicitly {@link gauge.messages.KeepAlive.verify|verify} messages.
             * @function encode
             * @memberof gauge.messages.KeepAlive
             * @static
             * @param {gauge.messages.IKeepAlive} message KeepAlive message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KeepAlive.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.pluginId != null && message.hasOwnProperty("pluginId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.pluginId);
                return writer;
            };

            /**
             * Encodes the specified KeepAlive message, length delimited. Does not implicitly {@link gauge.messages.KeepAlive.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gauge.messages.KeepAlive
             * @static
             * @param {gauge.messages.IKeepAlive} message KeepAlive message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KeepAlive.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a KeepAlive message from the specified reader or buffer.
             * @function decode
             * @memberof gauge.messages.KeepAlive
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gauge.messages.KeepAlive} KeepAlive
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KeepAlive.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gauge.messages.KeepAlive();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.pluginId = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a KeepAlive message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gauge.messages.KeepAlive
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gauge.messages.KeepAlive} KeepAlive
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KeepAlive.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a KeepAlive message.
             * @function verify
             * @memberof gauge.messages.KeepAlive
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            KeepAlive.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.pluginId != null && message.hasOwnProperty("pluginId"))
                    if (!$util.isString(message.pluginId))
                        return "pluginId: string expected";
                return null;
            };

            /**
             * Creates a KeepAlive message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gauge.messages.KeepAlive
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gauge.messages.KeepAlive} KeepAlive
             */
            KeepAlive.fromObject = function fromObject(object) {
                if (object instanceof $root.gauge.messages.KeepAlive)
                    return object;
                var message = new $root.gauge.messages.KeepAlive();
                if (object.pluginId != null)
                    message.pluginId = String(object.pluginId);
                return message;
            };

            /**
             * Creates a plain object from a KeepAlive message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gauge.messages.KeepAlive
             * @static
             * @param {gauge.messages.KeepAlive} message KeepAlive
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            KeepAlive.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.pluginId = "";
                if (message.pluginId != null && message.hasOwnProperty("pluginId"))
                    object.pluginId = message.pluginId;
                return object;
            };

            /**
             * Converts this KeepAlive to JSON.
             * @function toJSON
             * @memberof gauge.messages.KeepAlive
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            KeepAlive.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return KeepAlive;
        })();

        messages.SpecDetails = (function() {

            /**
             * Properties of a SpecDetails.
             * @memberof gauge.messages
             * @interface ISpecDetails
             * @property {Array.<gauge.messages.SpecDetails.ISpecDetail>|null} [details] Holds a collection of Spec details.
             */

            /**
             * Constructs a new SpecDetails.
             * @memberof gauge.messages
             * @classdesc Represents a SpecDetails.
             * @implements ISpecDetails
             * @constructor
             * @param {gauge.messages.ISpecDetails=} [properties] Properties to set
             */
            function SpecDetails(properties) {
                this.details = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Holds a collection of Spec details.
             * @member {Array.<gauge.messages.SpecDetails.ISpecDetail>} details
             * @memberof gauge.messages.SpecDetails
             * @instance
             */
            SpecDetails.prototype.details = $util.emptyArray;

            /**
             * Creates a new SpecDetails instance using the specified properties.
             * @function create
             * @memberof gauge.messages.SpecDetails
             * @static
             * @param {gauge.messages.ISpecDetails=} [properties] Properties to set
             * @returns {gauge.messages.SpecDetails} SpecDetails instance
             */
            SpecDetails.create = function create(properties) {
                return new SpecDetails(properties);
            };

            /**
             * Encodes the specified SpecDetails message. Does not implicitly {@link gauge.messages.SpecDetails.verify|verify} messages.
             * @function encode
             * @memberof gauge.messages.SpecDetails
             * @static
             * @param {gauge.messages.ISpecDetails} message SpecDetails message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SpecDetails.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.details != null && message.details.length)
                    for (var i = 0; i < message.details.length; ++i)
                        $root.gauge.messages.SpecDetails.SpecDetail.encode(message.details[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified SpecDetails message, length delimited. Does not implicitly {@link gauge.messages.SpecDetails.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gauge.messages.SpecDetails
             * @static
             * @param {gauge.messages.ISpecDetails} message SpecDetails message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SpecDetails.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SpecDetails message from the specified reader or buffer.
             * @function decode
             * @memberof gauge.messages.SpecDetails
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gauge.messages.SpecDetails} SpecDetails
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SpecDetails.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gauge.messages.SpecDetails();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.details && message.details.length))
                            message.details = [];
                        message.details.push($root.gauge.messages.SpecDetails.SpecDetail.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SpecDetails message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gauge.messages.SpecDetails
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gauge.messages.SpecDetails} SpecDetails
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SpecDetails.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SpecDetails message.
             * @function verify
             * @memberof gauge.messages.SpecDetails
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SpecDetails.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.details != null && message.hasOwnProperty("details")) {
                    if (!Array.isArray(message.details))
                        return "details: array expected";
                    for (var i = 0; i < message.details.length; ++i) {
                        var error = $root.gauge.messages.SpecDetails.SpecDetail.verify(message.details[i]);
                        if (error)
                            return "details." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a SpecDetails message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gauge.messages.SpecDetails
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gauge.messages.SpecDetails} SpecDetails
             */
            SpecDetails.fromObject = function fromObject(object) {
                if (object instanceof $root.gauge.messages.SpecDetails)
                    return object;
                var message = new $root.gauge.messages.SpecDetails();
                if (object.details) {
                    if (!Array.isArray(object.details))
                        throw TypeError(".gauge.messages.SpecDetails.details: array expected");
                    message.details = [];
                    for (var i = 0; i < object.details.length; ++i) {
                        if (typeof object.details[i] !== "object")
                            throw TypeError(".gauge.messages.SpecDetails.details: object expected");
                        message.details[i] = $root.gauge.messages.SpecDetails.SpecDetail.fromObject(object.details[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a SpecDetails message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gauge.messages.SpecDetails
             * @static
             * @param {gauge.messages.SpecDetails} message SpecDetails
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SpecDetails.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.details = [];
                if (message.details && message.details.length) {
                    object.details = [];
                    for (var j = 0; j < message.details.length; ++j)
                        object.details[j] = $root.gauge.messages.SpecDetails.SpecDetail.toObject(message.details[j], options);
                }
                return object;
            };

            /**
             * Converts this SpecDetails to JSON.
             * @function toJSON
             * @memberof gauge.messages.SpecDetails
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SpecDetails.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            SpecDetails.SpecDetail = (function() {

                /**
                 * Properties of a SpecDetail.
                 * @memberof gauge.messages.SpecDetails
                 * @interface ISpecDetail
                 * @property {gauge.messages.IProtoSpec|null} [spec] Holds a collection of Specs that are defined in the project.
                 * @property {Array.<gauge.messages.IError>|null} [parseErrors] Holds a collection of parse errors present in the above spec.
                 */

                /**
                 * Constructs a new SpecDetail.
                 * @memberof gauge.messages.SpecDetails
                 * @classdesc Represents a SpecDetail.
                 * @implements ISpecDetail
                 * @constructor
                 * @param {gauge.messages.SpecDetails.ISpecDetail=} [properties] Properties to set
                 */
                function SpecDetail(properties) {
                    this.parseErrors = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Holds a collection of Specs that are defined in the project.
                 * @member {gauge.messages.IProtoSpec|null|undefined} spec
                 * @memberof gauge.messages.SpecDetails.SpecDetail
                 * @instance
                 */
                SpecDetail.prototype.spec = null;

                /**
                 * Holds a collection of parse errors present in the above spec.
                 * @member {Array.<gauge.messages.IError>} parseErrors
                 * @memberof gauge.messages.SpecDetails.SpecDetail
                 * @instance
                 */
                SpecDetail.prototype.parseErrors = $util.emptyArray;

                /**
                 * Creates a new SpecDetail instance using the specified properties.
                 * @function create
                 * @memberof gauge.messages.SpecDetails.SpecDetail
                 * @static
                 * @param {gauge.messages.SpecDetails.ISpecDetail=} [properties] Properties to set
                 * @returns {gauge.messages.SpecDetails.SpecDetail} SpecDetail instance
                 */
                SpecDetail.create = function create(properties) {
                    return new SpecDetail(properties);
                };

                /**
                 * Encodes the specified SpecDetail message. Does not implicitly {@link gauge.messages.SpecDetails.SpecDetail.verify|verify} messages.
                 * @function encode
                 * @memberof gauge.messages.SpecDetails.SpecDetail
                 * @static
                 * @param {gauge.messages.SpecDetails.ISpecDetail} message SpecDetail message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SpecDetail.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.spec != null && message.hasOwnProperty("spec"))
                        $root.gauge.messages.ProtoSpec.encode(message.spec, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.parseErrors != null && message.parseErrors.length)
                        for (var i = 0; i < message.parseErrors.length; ++i)
                            $root.gauge.messages.Error.encode(message.parseErrors[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified SpecDetail message, length delimited. Does not implicitly {@link gauge.messages.SpecDetails.SpecDetail.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof gauge.messages.SpecDetails.SpecDetail
                 * @static
                 * @param {gauge.messages.SpecDetails.ISpecDetail} message SpecDetail message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SpecDetail.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a SpecDetail message from the specified reader or buffer.
                 * @function decode
                 * @memberof gauge.messages.SpecDetails.SpecDetail
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {gauge.messages.SpecDetails.SpecDetail} SpecDetail
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SpecDetail.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gauge.messages.SpecDetails.SpecDetail();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.spec = $root.gauge.messages.ProtoSpec.decode(reader, reader.uint32());
                            break;
                        case 2:
                            if (!(message.parseErrors && message.parseErrors.length))
                                message.parseErrors = [];
                            message.parseErrors.push($root.gauge.messages.Error.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a SpecDetail message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof gauge.messages.SpecDetails.SpecDetail
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {gauge.messages.SpecDetails.SpecDetail} SpecDetail
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SpecDetail.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a SpecDetail message.
                 * @function verify
                 * @memberof gauge.messages.SpecDetails.SpecDetail
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                SpecDetail.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.spec != null && message.hasOwnProperty("spec")) {
                        var error = $root.gauge.messages.ProtoSpec.verify(message.spec);
                        if (error)
                            return "spec." + error;
                    }
                    if (message.parseErrors != null && message.hasOwnProperty("parseErrors")) {
                        if (!Array.isArray(message.parseErrors))
                            return "parseErrors: array expected";
                        for (var i = 0; i < message.parseErrors.length; ++i) {
                            var error = $root.gauge.messages.Error.verify(message.parseErrors[i]);
                            if (error)
                                return "parseErrors." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a SpecDetail message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof gauge.messages.SpecDetails.SpecDetail
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {gauge.messages.SpecDetails.SpecDetail} SpecDetail
                 */
                SpecDetail.fromObject = function fromObject(object) {
                    if (object instanceof $root.gauge.messages.SpecDetails.SpecDetail)
                        return object;
                    var message = new $root.gauge.messages.SpecDetails.SpecDetail();
                    if (object.spec != null) {
                        if (typeof object.spec !== "object")
                            throw TypeError(".gauge.messages.SpecDetails.SpecDetail.spec: object expected");
                        message.spec = $root.gauge.messages.ProtoSpec.fromObject(object.spec);
                    }
                    if (object.parseErrors) {
                        if (!Array.isArray(object.parseErrors))
                            throw TypeError(".gauge.messages.SpecDetails.SpecDetail.parseErrors: array expected");
                        message.parseErrors = [];
                        for (var i = 0; i < object.parseErrors.length; ++i) {
                            if (typeof object.parseErrors[i] !== "object")
                                throw TypeError(".gauge.messages.SpecDetails.SpecDetail.parseErrors: object expected");
                            message.parseErrors[i] = $root.gauge.messages.Error.fromObject(object.parseErrors[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a SpecDetail message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof gauge.messages.SpecDetails.SpecDetail
                 * @static
                 * @param {gauge.messages.SpecDetails.SpecDetail} message SpecDetail
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                SpecDetail.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.parseErrors = [];
                    if (options.defaults)
                        object.spec = null;
                    if (message.spec != null && message.hasOwnProperty("spec"))
                        object.spec = $root.gauge.messages.ProtoSpec.toObject(message.spec, options);
                    if (message.parseErrors && message.parseErrors.length) {
                        object.parseErrors = [];
                        for (var j = 0; j < message.parseErrors.length; ++j)
                            object.parseErrors[j] = $root.gauge.messages.Error.toObject(message.parseErrors[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this SpecDetail to JSON.
                 * @function toJSON
                 * @memberof gauge.messages.SpecDetails.SpecDetail
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                SpecDetail.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return SpecDetail;
            })();

            return SpecDetails;
        })();

        messages.Empty = (function() {

            /**
             * Properties of an Empty.
             * @memberof gauge.messages
             * @interface IEmpty
             */

            /**
             * Constructs a new Empty.
             * @memberof gauge.messages
             * @classdesc Represents an Empty.
             * @implements IEmpty
             * @constructor
             * @param {gauge.messages.IEmpty=} [properties] Properties to set
             */
            function Empty(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new Empty instance using the specified properties.
             * @function create
             * @memberof gauge.messages.Empty
             * @static
             * @param {gauge.messages.IEmpty=} [properties] Properties to set
             * @returns {gauge.messages.Empty} Empty instance
             */
            Empty.create = function create(properties) {
                return new Empty(properties);
            };

            /**
             * Encodes the specified Empty message. Does not implicitly {@link gauge.messages.Empty.verify|verify} messages.
             * @function encode
             * @memberof gauge.messages.Empty
             * @static
             * @param {gauge.messages.IEmpty} message Empty message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Empty.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified Empty message, length delimited. Does not implicitly {@link gauge.messages.Empty.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gauge.messages.Empty
             * @static
             * @param {gauge.messages.IEmpty} message Empty message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Empty.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an Empty message from the specified reader or buffer.
             * @function decode
             * @memberof gauge.messages.Empty
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gauge.messages.Empty} Empty
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Empty.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gauge.messages.Empty();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an Empty message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gauge.messages.Empty
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gauge.messages.Empty} Empty
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Empty.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an Empty message.
             * @function verify
             * @memberof gauge.messages.Empty
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Empty.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates an Empty message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gauge.messages.Empty
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gauge.messages.Empty} Empty
             */
            Empty.fromObject = function fromObject(object) {
                if (object instanceof $root.gauge.messages.Empty)
                    return object;
                return new $root.gauge.messages.Empty();
            };

            /**
             * Creates a plain object from an Empty message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gauge.messages.Empty
             * @static
             * @param {gauge.messages.Empty} message Empty
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Empty.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this Empty to JSON.
             * @function toJSON
             * @memberof gauge.messages.Empty
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Empty.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Empty;
        })();

        messages.Message = (function() {

            /**
             * Properties of a Message.
             * @memberof gauge.messages
             * @interface IMessage
             * @property {gauge.messages.Message.MessageType|null} [messageType] Message messageType
             * @property {number|Long|null} [messageId] This is used to synchronize messages & responses
             * @property {gauge.messages.IExecutionStartingRequest|null} [executionStartingRequest] [ExecutionStartingRequest](#gauge.messages.ExecutionStartingRequest)
             * @property {gauge.messages.ISpecExecutionStartingRequest|null} [specExecutionStartingRequest] [SpecExecutionStartingRequest](#gauge.messages.SpecExecutionStartingRequest)
             * @property {gauge.messages.ISpecExecutionEndingRequest|null} [specExecutionEndingRequest] [SpecExecutionEndingRequest](#gauge.messages.SpecExecutionEndingRequest)
             * @property {gauge.messages.IScenarioExecutionStartingRequest|null} [scenarioExecutionStartingRequest] [ScenarioExecutionStartingRequest](#gauge.messages.ScenarioExecutionStartingRequest)
             * @property {gauge.messages.IScenarioExecutionEndingRequest|null} [scenarioExecutionEndingRequest] [ScenarioExecutionEndingRequest](#gauge.messages.ScenarioExecutionEndingRequest)
             * @property {gauge.messages.IStepExecutionStartingRequest|null} [stepExecutionStartingRequest] [StepExecutionStartingRequest](#gauge.messages.StepExecutionStartingRequest)
             * @property {gauge.messages.IStepExecutionEndingRequest|null} [stepExecutionEndingRequest] [StepExecutionEndingRequest](#gauge.messages.StepExecutionEndingRequest)
             * @property {gauge.messages.IExecuteStepRequest|null} [executeStepRequest] [ExecuteStepRequest](#gauge.messages.ExecuteStepRequest)
             * @property {gauge.messages.IExecutionEndingRequest|null} [executionEndingRequest] [ExecutionEndingRequest](#gauge.messages.ExecutionEndingRequest)
             * @property {gauge.messages.IStepValidateRequest|null} [stepValidateRequest] [StepValidateRequest](#gauge.messages.StepValidateRequest)
             * @property {gauge.messages.IStepValidateResponse|null} [stepValidateResponse] [StepValidateResponse](#gauge.messages.StepValidateResponse)
             * @property {gauge.messages.IExecutionStatusResponse|null} [executionStatusResponse] [ExecutionStatusResponse](#gauge.messages.ExecutionStatusResponse)
             * @property {gauge.messages.IStepNamesRequest|null} [stepNamesRequest] [StepNamesRequest](#gauge.messages.StepNamesRequest)
             * @property {gauge.messages.IStepNamesResponse|null} [stepNamesResponse] [StepNamesResponse](#gauge.messages.StepNamesResponse)
             * @property {gauge.messages.ISuiteExecutionResult|null} [suiteExecutionResult] [SuiteExecutionResult ](#gauge.messages.SuiteExecutionResult )
             * @property {gauge.messages.IKillProcessRequest|null} [killProcessRequest] [KillProcessRequest](#gauge.messages.KillProcessRequest)
             * @property {gauge.messages.IScenarioDataStoreInitRequest|null} [scenarioDataStoreInitRequest] [ScenarioDataStoreInitRequest](#gauge.messages.ScenarioDataStoreInitRequest)
             * @property {gauge.messages.ISpecDataStoreInitRequest|null} [specDataStoreInitRequest] [SpecDataStoreInitRequest](#gauge.messages.SpecDataStoreInitRequest)
             * @property {gauge.messages.ISuiteDataStoreInitRequest|null} [suiteDataStoreInitRequest] [SuiteDataStoreInitRequest](#gauge.messages.SuiteDataStoreInitRequest)
             * @property {gauge.messages.IStepNameRequest|null} [stepNameRequest] [StepNameRequest](#gauge.messages.StepNameRequest)
             * @property {gauge.messages.IStepNameResponse|null} [stepNameResponse] [StepNameResponse](#gauge.messages.StepNameResponse)
             * @property {gauge.messages.IRefactorRequest|null} [refactorRequest] [RefactorRequest](#gauge.messages.RefactorRequest)
             * @property {gauge.messages.IRefactorResponse|null} [refactorResponse] [RefactorResponse](#gauge.messages.RefactorResponse)
             * @property {gauge.messages.IUnsupportedMessageResponse|null} [unsupportedMessageResponse] [UnsupportedMessageResponse](#gauge.messages.UnsupportedMessageResponse)
             * @property {gauge.messages.ICacheFileRequest|null} [cacheFileRequest] [CacheFileRequest](#gauge.messages.CacheFileRequest)
             * @property {gauge.messages.IStepPositionsRequest|null} [stepPositionsRequest] [StepPositionsRequest](#gauge.messages.StepPositionsRequest)
             * @property {gauge.messages.IStepPositionsResponse|null} [stepPositionsResponse] [StepPositionsResponse](#gauge.messages.StepPositionsResponse)
             * @property {gauge.messages.IImplementationFileListRequest|null} [implementationFileListRequest] [ImplementationFileListRequest](#gauge.messages.ImplementationFileListRequest)
             * @property {gauge.messages.IImplementationFileListResponse|null} [implementationFileListResponse] [ImplementationFileListResponse](#gauge.messages.ImplementationFileListResponse)
             * @property {gauge.messages.IStubImplementationCodeRequest|null} [stubImplementationCodeRequest] [StubImplementationCodeRequest](#gauge.messages.StubImplementationCodeRequest)
             * @property {gauge.messages.IFileDiff|null} [fileDiff] [FileDiff](#gauge.messages.FileDiff)
             * @property {gauge.messages.IImplementationFileGlobPatternRequest|null} [implementationFileGlobPatternRequest] [ImplementationFileGlobPatternRequest](#gauge.messages.ImplementationFileGlobPatternRequest)
             * @property {gauge.messages.IImplementationFileGlobPatternResponse|null} [implementationFileGlobPatternResponse] [ImplementationFileGlobPatternResponse](#gauge.messages.ImplementationFileGlobPatternResponse)
             * @property {gauge.messages.ISuiteExecutionResultItem|null} [suiteExecutionResultItem] [SuiteExecutionResult ](#gauge.messages.SuiteExecutionResult )
             * @property {gauge.messages.IKeepAlive|null} [keepAlive] [KeepAlive ](#gauge.messages.KeepAlive )
             */

            /**
             * Constructs a new Message.
             * @memberof gauge.messages
             * @classdesc One of the Request/Response fields will have value, depending on the MessageType set.
             * @implements IMessage
             * @constructor
             * @param {gauge.messages.IMessage=} [properties] Properties to set
             */
            function Message(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Message messageType.
             * @member {gauge.messages.Message.MessageType} messageType
             * @memberof gauge.messages.Message
             * @instance
             */
            Message.prototype.messageType = 0;

            /**
             * This is used to synchronize messages & responses
             * @member {number|Long} messageId
             * @memberof gauge.messages.Message
             * @instance
             */
            Message.prototype.messageId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * [ExecutionStartingRequest](#gauge.messages.ExecutionStartingRequest)
             * @member {gauge.messages.IExecutionStartingRequest|null|undefined} executionStartingRequest
             * @memberof gauge.messages.Message
             * @instance
             */
            Message.prototype.executionStartingRequest = null;

            /**
             * [SpecExecutionStartingRequest](#gauge.messages.SpecExecutionStartingRequest)
             * @member {gauge.messages.ISpecExecutionStartingRequest|null|undefined} specExecutionStartingRequest
             * @memberof gauge.messages.Message
             * @instance
             */
            Message.prototype.specExecutionStartingRequest = null;

            /**
             * [SpecExecutionEndingRequest](#gauge.messages.SpecExecutionEndingRequest)
             * @member {gauge.messages.ISpecExecutionEndingRequest|null|undefined} specExecutionEndingRequest
             * @memberof gauge.messages.Message
             * @instance
             */
            Message.prototype.specExecutionEndingRequest = null;

            /**
             * [ScenarioExecutionStartingRequest](#gauge.messages.ScenarioExecutionStartingRequest)
             * @member {gauge.messages.IScenarioExecutionStartingRequest|null|undefined} scenarioExecutionStartingRequest
             * @memberof gauge.messages.Message
             * @instance
             */
            Message.prototype.scenarioExecutionStartingRequest = null;

            /**
             * [ScenarioExecutionEndingRequest](#gauge.messages.ScenarioExecutionEndingRequest)
             * @member {gauge.messages.IScenarioExecutionEndingRequest|null|undefined} scenarioExecutionEndingRequest
             * @memberof gauge.messages.Message
             * @instance
             */
            Message.prototype.scenarioExecutionEndingRequest = null;

            /**
             * [StepExecutionStartingRequest](#gauge.messages.StepExecutionStartingRequest)
             * @member {gauge.messages.IStepExecutionStartingRequest|null|undefined} stepExecutionStartingRequest
             * @memberof gauge.messages.Message
             * @instance
             */
            Message.prototype.stepExecutionStartingRequest = null;

            /**
             * [StepExecutionEndingRequest](#gauge.messages.StepExecutionEndingRequest)
             * @member {gauge.messages.IStepExecutionEndingRequest|null|undefined} stepExecutionEndingRequest
             * @memberof gauge.messages.Message
             * @instance
             */
            Message.prototype.stepExecutionEndingRequest = null;

            /**
             * [ExecuteStepRequest](#gauge.messages.ExecuteStepRequest)
             * @member {gauge.messages.IExecuteStepRequest|null|undefined} executeStepRequest
             * @memberof gauge.messages.Message
             * @instance
             */
            Message.prototype.executeStepRequest = null;

            /**
             * [ExecutionEndingRequest](#gauge.messages.ExecutionEndingRequest)
             * @member {gauge.messages.IExecutionEndingRequest|null|undefined} executionEndingRequest
             * @memberof gauge.messages.Message
             * @instance
             */
            Message.prototype.executionEndingRequest = null;

            /**
             * [StepValidateRequest](#gauge.messages.StepValidateRequest)
             * @member {gauge.messages.IStepValidateRequest|null|undefined} stepValidateRequest
             * @memberof gauge.messages.Message
             * @instance
             */
            Message.prototype.stepValidateRequest = null;

            /**
             * [StepValidateResponse](#gauge.messages.StepValidateResponse)
             * @member {gauge.messages.IStepValidateResponse|null|undefined} stepValidateResponse
             * @memberof gauge.messages.Message
             * @instance
             */
            Message.prototype.stepValidateResponse = null;

            /**
             * [ExecutionStatusResponse](#gauge.messages.ExecutionStatusResponse)
             * @member {gauge.messages.IExecutionStatusResponse|null|undefined} executionStatusResponse
             * @memberof gauge.messages.Message
             * @instance
             */
            Message.prototype.executionStatusResponse = null;

            /**
             * [StepNamesRequest](#gauge.messages.StepNamesRequest)
             * @member {gauge.messages.IStepNamesRequest|null|undefined} stepNamesRequest
             * @memberof gauge.messages.Message
             * @instance
             */
            Message.prototype.stepNamesRequest = null;

            /**
             * [StepNamesResponse](#gauge.messages.StepNamesResponse)
             * @member {gauge.messages.IStepNamesResponse|null|undefined} stepNamesResponse
             * @memberof gauge.messages.Message
             * @instance
             */
            Message.prototype.stepNamesResponse = null;

            /**
             * [SuiteExecutionResult ](#gauge.messages.SuiteExecutionResult )
             * @member {gauge.messages.ISuiteExecutionResult|null|undefined} suiteExecutionResult
             * @memberof gauge.messages.Message
             * @instance
             */
            Message.prototype.suiteExecutionResult = null;

            /**
             * [KillProcessRequest](#gauge.messages.KillProcessRequest)
             * @member {gauge.messages.IKillProcessRequest|null|undefined} killProcessRequest
             * @memberof gauge.messages.Message
             * @instance
             */
            Message.prototype.killProcessRequest = null;

            /**
             * [ScenarioDataStoreInitRequest](#gauge.messages.ScenarioDataStoreInitRequest)
             * @member {gauge.messages.IScenarioDataStoreInitRequest|null|undefined} scenarioDataStoreInitRequest
             * @memberof gauge.messages.Message
             * @instance
             */
            Message.prototype.scenarioDataStoreInitRequest = null;

            /**
             * [SpecDataStoreInitRequest](#gauge.messages.SpecDataStoreInitRequest)
             * @member {gauge.messages.ISpecDataStoreInitRequest|null|undefined} specDataStoreInitRequest
             * @memberof gauge.messages.Message
             * @instance
             */
            Message.prototype.specDataStoreInitRequest = null;

            /**
             * [SuiteDataStoreInitRequest](#gauge.messages.SuiteDataStoreInitRequest)
             * @member {gauge.messages.ISuiteDataStoreInitRequest|null|undefined} suiteDataStoreInitRequest
             * @memberof gauge.messages.Message
             * @instance
             */
            Message.prototype.suiteDataStoreInitRequest = null;

            /**
             * [StepNameRequest](#gauge.messages.StepNameRequest)
             * @member {gauge.messages.IStepNameRequest|null|undefined} stepNameRequest
             * @memberof gauge.messages.Message
             * @instance
             */
            Message.prototype.stepNameRequest = null;

            /**
             * [StepNameResponse](#gauge.messages.StepNameResponse)
             * @member {gauge.messages.IStepNameResponse|null|undefined} stepNameResponse
             * @memberof gauge.messages.Message
             * @instance
             */
            Message.prototype.stepNameResponse = null;

            /**
             * [RefactorRequest](#gauge.messages.RefactorRequest)
             * @member {gauge.messages.IRefactorRequest|null|undefined} refactorRequest
             * @memberof gauge.messages.Message
             * @instance
             */
            Message.prototype.refactorRequest = null;

            /**
             * [RefactorResponse](#gauge.messages.RefactorResponse)
             * @member {gauge.messages.IRefactorResponse|null|undefined} refactorResponse
             * @memberof gauge.messages.Message
             * @instance
             */
            Message.prototype.refactorResponse = null;

            /**
             * [UnsupportedMessageResponse](#gauge.messages.UnsupportedMessageResponse)
             * @member {gauge.messages.IUnsupportedMessageResponse|null|undefined} unsupportedMessageResponse
             * @memberof gauge.messages.Message
             * @instance
             */
            Message.prototype.unsupportedMessageResponse = null;

            /**
             * [CacheFileRequest](#gauge.messages.CacheFileRequest)
             * @member {gauge.messages.ICacheFileRequest|null|undefined} cacheFileRequest
             * @memberof gauge.messages.Message
             * @instance
             */
            Message.prototype.cacheFileRequest = null;

            /**
             * [StepPositionsRequest](#gauge.messages.StepPositionsRequest)
             * @member {gauge.messages.IStepPositionsRequest|null|undefined} stepPositionsRequest
             * @memberof gauge.messages.Message
             * @instance
             */
            Message.prototype.stepPositionsRequest = null;

            /**
             * [StepPositionsResponse](#gauge.messages.StepPositionsResponse)
             * @member {gauge.messages.IStepPositionsResponse|null|undefined} stepPositionsResponse
             * @memberof gauge.messages.Message
             * @instance
             */
            Message.prototype.stepPositionsResponse = null;

            /**
             * [ImplementationFileListRequest](#gauge.messages.ImplementationFileListRequest)
             * @member {gauge.messages.IImplementationFileListRequest|null|undefined} implementationFileListRequest
             * @memberof gauge.messages.Message
             * @instance
             */
            Message.prototype.implementationFileListRequest = null;

            /**
             * [ImplementationFileListResponse](#gauge.messages.ImplementationFileListResponse)
             * @member {gauge.messages.IImplementationFileListResponse|null|undefined} implementationFileListResponse
             * @memberof gauge.messages.Message
             * @instance
             */
            Message.prototype.implementationFileListResponse = null;

            /**
             * [StubImplementationCodeRequest](#gauge.messages.StubImplementationCodeRequest)
             * @member {gauge.messages.IStubImplementationCodeRequest|null|undefined} stubImplementationCodeRequest
             * @memberof gauge.messages.Message
             * @instance
             */
            Message.prototype.stubImplementationCodeRequest = null;

            /**
             * [FileDiff](#gauge.messages.FileDiff)
             * @member {gauge.messages.IFileDiff|null|undefined} fileDiff
             * @memberof gauge.messages.Message
             * @instance
             */
            Message.prototype.fileDiff = null;

            /**
             * [ImplementationFileGlobPatternRequest](#gauge.messages.ImplementationFileGlobPatternRequest)
             * @member {gauge.messages.IImplementationFileGlobPatternRequest|null|undefined} implementationFileGlobPatternRequest
             * @memberof gauge.messages.Message
             * @instance
             */
            Message.prototype.implementationFileGlobPatternRequest = null;

            /**
             * [ImplementationFileGlobPatternResponse](#gauge.messages.ImplementationFileGlobPatternResponse)
             * @member {gauge.messages.IImplementationFileGlobPatternResponse|null|undefined} implementationFileGlobPatternResponse
             * @memberof gauge.messages.Message
             * @instance
             */
            Message.prototype.implementationFileGlobPatternResponse = null;

            /**
             * [SuiteExecutionResult ](#gauge.messages.SuiteExecutionResult )
             * @member {gauge.messages.ISuiteExecutionResultItem|null|undefined} suiteExecutionResultItem
             * @memberof gauge.messages.Message
             * @instance
             */
            Message.prototype.suiteExecutionResultItem = null;

            /**
             * [KeepAlive ](#gauge.messages.KeepAlive )
             * @member {gauge.messages.IKeepAlive|null|undefined} keepAlive
             * @memberof gauge.messages.Message
             * @instance
             */
            Message.prototype.keepAlive = null;

            /**
             * Creates a new Message instance using the specified properties.
             * @function create
             * @memberof gauge.messages.Message
             * @static
             * @param {gauge.messages.IMessage=} [properties] Properties to set
             * @returns {gauge.messages.Message} Message instance
             */
            Message.create = function create(properties) {
                return new Message(properties);
            };

            /**
             * Encodes the specified Message message. Does not implicitly {@link gauge.messages.Message.verify|verify} messages.
             * @function encode
             * @memberof gauge.messages.Message
             * @static
             * @param {gauge.messages.IMessage} message Message message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Message.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.messageType != null && message.hasOwnProperty("messageType"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.messageType);
                if (message.messageId != null && message.hasOwnProperty("messageId"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.messageId);
                if (message.executionStartingRequest != null && message.hasOwnProperty("executionStartingRequest"))
                    $root.gauge.messages.ExecutionStartingRequest.encode(message.executionStartingRequest, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.specExecutionStartingRequest != null && message.hasOwnProperty("specExecutionStartingRequest"))
                    $root.gauge.messages.SpecExecutionStartingRequest.encode(message.specExecutionStartingRequest, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.specExecutionEndingRequest != null && message.hasOwnProperty("specExecutionEndingRequest"))
                    $root.gauge.messages.SpecExecutionEndingRequest.encode(message.specExecutionEndingRequest, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.scenarioExecutionStartingRequest != null && message.hasOwnProperty("scenarioExecutionStartingRequest"))
                    $root.gauge.messages.ScenarioExecutionStartingRequest.encode(message.scenarioExecutionStartingRequest, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.scenarioExecutionEndingRequest != null && message.hasOwnProperty("scenarioExecutionEndingRequest"))
                    $root.gauge.messages.ScenarioExecutionEndingRequest.encode(message.scenarioExecutionEndingRequest, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                if (message.stepExecutionStartingRequest != null && message.hasOwnProperty("stepExecutionStartingRequest"))
                    $root.gauge.messages.StepExecutionStartingRequest.encode(message.stepExecutionStartingRequest, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                if (message.stepExecutionEndingRequest != null && message.hasOwnProperty("stepExecutionEndingRequest"))
                    $root.gauge.messages.StepExecutionEndingRequest.encode(message.stepExecutionEndingRequest, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                if (message.executeStepRequest != null && message.hasOwnProperty("executeStepRequest"))
                    $root.gauge.messages.ExecuteStepRequest.encode(message.executeStepRequest, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                if (message.executionEndingRequest != null && message.hasOwnProperty("executionEndingRequest"))
                    $root.gauge.messages.ExecutionEndingRequest.encode(message.executionEndingRequest, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
                if (message.stepValidateRequest != null && message.hasOwnProperty("stepValidateRequest"))
                    $root.gauge.messages.StepValidateRequest.encode(message.stepValidateRequest, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
                if (message.stepValidateResponse != null && message.hasOwnProperty("stepValidateResponse"))
                    $root.gauge.messages.StepValidateResponse.encode(message.stepValidateResponse, writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
                if (message.executionStatusResponse != null && message.hasOwnProperty("executionStatusResponse"))
                    $root.gauge.messages.ExecutionStatusResponse.encode(message.executionStatusResponse, writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
                if (message.stepNamesRequest != null && message.hasOwnProperty("stepNamesRequest"))
                    $root.gauge.messages.StepNamesRequest.encode(message.stepNamesRequest, writer.uint32(/* id 15, wireType 2 =*/122).fork()).ldelim();
                if (message.stepNamesResponse != null && message.hasOwnProperty("stepNamesResponse"))
                    $root.gauge.messages.StepNamesResponse.encode(message.stepNamesResponse, writer.uint32(/* id 16, wireType 2 =*/130).fork()).ldelim();
                if (message.suiteExecutionResult != null && message.hasOwnProperty("suiteExecutionResult"))
                    $root.gauge.messages.SuiteExecutionResult.encode(message.suiteExecutionResult, writer.uint32(/* id 17, wireType 2 =*/138).fork()).ldelim();
                if (message.killProcessRequest != null && message.hasOwnProperty("killProcessRequest"))
                    $root.gauge.messages.KillProcessRequest.encode(message.killProcessRequest, writer.uint32(/* id 18, wireType 2 =*/146).fork()).ldelim();
                if (message.scenarioDataStoreInitRequest != null && message.hasOwnProperty("scenarioDataStoreInitRequest"))
                    $root.gauge.messages.ScenarioDataStoreInitRequest.encode(message.scenarioDataStoreInitRequest, writer.uint32(/* id 19, wireType 2 =*/154).fork()).ldelim();
                if (message.specDataStoreInitRequest != null && message.hasOwnProperty("specDataStoreInitRequest"))
                    $root.gauge.messages.SpecDataStoreInitRequest.encode(message.specDataStoreInitRequest, writer.uint32(/* id 20, wireType 2 =*/162).fork()).ldelim();
                if (message.suiteDataStoreInitRequest != null && message.hasOwnProperty("suiteDataStoreInitRequest"))
                    $root.gauge.messages.SuiteDataStoreInitRequest.encode(message.suiteDataStoreInitRequest, writer.uint32(/* id 21, wireType 2 =*/170).fork()).ldelim();
                if (message.stepNameRequest != null && message.hasOwnProperty("stepNameRequest"))
                    $root.gauge.messages.StepNameRequest.encode(message.stepNameRequest, writer.uint32(/* id 22, wireType 2 =*/178).fork()).ldelim();
                if (message.stepNameResponse != null && message.hasOwnProperty("stepNameResponse"))
                    $root.gauge.messages.StepNameResponse.encode(message.stepNameResponse, writer.uint32(/* id 23, wireType 2 =*/186).fork()).ldelim();
                if (message.refactorRequest != null && message.hasOwnProperty("refactorRequest"))
                    $root.gauge.messages.RefactorRequest.encode(message.refactorRequest, writer.uint32(/* id 24, wireType 2 =*/194).fork()).ldelim();
                if (message.refactorResponse != null && message.hasOwnProperty("refactorResponse"))
                    $root.gauge.messages.RefactorResponse.encode(message.refactorResponse, writer.uint32(/* id 25, wireType 2 =*/202).fork()).ldelim();
                if (message.unsupportedMessageResponse != null && message.hasOwnProperty("unsupportedMessageResponse"))
                    $root.gauge.messages.UnsupportedMessageResponse.encode(message.unsupportedMessageResponse, writer.uint32(/* id 26, wireType 2 =*/210).fork()).ldelim();
                if (message.cacheFileRequest != null && message.hasOwnProperty("cacheFileRequest"))
                    $root.gauge.messages.CacheFileRequest.encode(message.cacheFileRequest, writer.uint32(/* id 27, wireType 2 =*/218).fork()).ldelim();
                if (message.stepPositionsRequest != null && message.hasOwnProperty("stepPositionsRequest"))
                    $root.gauge.messages.StepPositionsRequest.encode(message.stepPositionsRequest, writer.uint32(/* id 28, wireType 2 =*/226).fork()).ldelim();
                if (message.stepPositionsResponse != null && message.hasOwnProperty("stepPositionsResponse"))
                    $root.gauge.messages.StepPositionsResponse.encode(message.stepPositionsResponse, writer.uint32(/* id 29, wireType 2 =*/234).fork()).ldelim();
                if (message.implementationFileListRequest != null && message.hasOwnProperty("implementationFileListRequest"))
                    $root.gauge.messages.ImplementationFileListRequest.encode(message.implementationFileListRequest, writer.uint32(/* id 30, wireType 2 =*/242).fork()).ldelim();
                if (message.implementationFileListResponse != null && message.hasOwnProperty("implementationFileListResponse"))
                    $root.gauge.messages.ImplementationFileListResponse.encode(message.implementationFileListResponse, writer.uint32(/* id 31, wireType 2 =*/250).fork()).ldelim();
                if (message.stubImplementationCodeRequest != null && message.hasOwnProperty("stubImplementationCodeRequest"))
                    $root.gauge.messages.StubImplementationCodeRequest.encode(message.stubImplementationCodeRequest, writer.uint32(/* id 32, wireType 2 =*/258).fork()).ldelim();
                if (message.fileDiff != null && message.hasOwnProperty("fileDiff"))
                    $root.gauge.messages.FileDiff.encode(message.fileDiff, writer.uint32(/* id 33, wireType 2 =*/266).fork()).ldelim();
                if (message.implementationFileGlobPatternRequest != null && message.hasOwnProperty("implementationFileGlobPatternRequest"))
                    $root.gauge.messages.ImplementationFileGlobPatternRequest.encode(message.implementationFileGlobPatternRequest, writer.uint32(/* id 34, wireType 2 =*/274).fork()).ldelim();
                if (message.implementationFileGlobPatternResponse != null && message.hasOwnProperty("implementationFileGlobPatternResponse"))
                    $root.gauge.messages.ImplementationFileGlobPatternResponse.encode(message.implementationFileGlobPatternResponse, writer.uint32(/* id 35, wireType 2 =*/282).fork()).ldelim();
                if (message.suiteExecutionResultItem != null && message.hasOwnProperty("suiteExecutionResultItem"))
                    $root.gauge.messages.SuiteExecutionResultItem.encode(message.suiteExecutionResultItem, writer.uint32(/* id 36, wireType 2 =*/290).fork()).ldelim();
                if (message.keepAlive != null && message.hasOwnProperty("keepAlive"))
                    $root.gauge.messages.KeepAlive.encode(message.keepAlive, writer.uint32(/* id 37, wireType 2 =*/298).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Message message, length delimited. Does not implicitly {@link gauge.messages.Message.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gauge.messages.Message
             * @static
             * @param {gauge.messages.IMessage} message Message message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Message.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Message message from the specified reader or buffer.
             * @function decode
             * @memberof gauge.messages.Message
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gauge.messages.Message} Message
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Message.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gauge.messages.Message();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.messageType = reader.int32();
                        break;
                    case 2:
                        message.messageId = reader.int64();
                        break;
                    case 3:
                        message.executionStartingRequest = $root.gauge.messages.ExecutionStartingRequest.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.specExecutionStartingRequest = $root.gauge.messages.SpecExecutionStartingRequest.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.specExecutionEndingRequest = $root.gauge.messages.SpecExecutionEndingRequest.decode(reader, reader.uint32());
                        break;
                    case 6:
                        message.scenarioExecutionStartingRequest = $root.gauge.messages.ScenarioExecutionStartingRequest.decode(reader, reader.uint32());
                        break;
                    case 7:
                        message.scenarioExecutionEndingRequest = $root.gauge.messages.ScenarioExecutionEndingRequest.decode(reader, reader.uint32());
                        break;
                    case 8:
                        message.stepExecutionStartingRequest = $root.gauge.messages.StepExecutionStartingRequest.decode(reader, reader.uint32());
                        break;
                    case 9:
                        message.stepExecutionEndingRequest = $root.gauge.messages.StepExecutionEndingRequest.decode(reader, reader.uint32());
                        break;
                    case 10:
                        message.executeStepRequest = $root.gauge.messages.ExecuteStepRequest.decode(reader, reader.uint32());
                        break;
                    case 11:
                        message.executionEndingRequest = $root.gauge.messages.ExecutionEndingRequest.decode(reader, reader.uint32());
                        break;
                    case 12:
                        message.stepValidateRequest = $root.gauge.messages.StepValidateRequest.decode(reader, reader.uint32());
                        break;
                    case 13:
                        message.stepValidateResponse = $root.gauge.messages.StepValidateResponse.decode(reader, reader.uint32());
                        break;
                    case 14:
                        message.executionStatusResponse = $root.gauge.messages.ExecutionStatusResponse.decode(reader, reader.uint32());
                        break;
                    case 15:
                        message.stepNamesRequest = $root.gauge.messages.StepNamesRequest.decode(reader, reader.uint32());
                        break;
                    case 16:
                        message.stepNamesResponse = $root.gauge.messages.StepNamesResponse.decode(reader, reader.uint32());
                        break;
                    case 17:
                        message.suiteExecutionResult = $root.gauge.messages.SuiteExecutionResult.decode(reader, reader.uint32());
                        break;
                    case 18:
                        message.killProcessRequest = $root.gauge.messages.KillProcessRequest.decode(reader, reader.uint32());
                        break;
                    case 19:
                        message.scenarioDataStoreInitRequest = $root.gauge.messages.ScenarioDataStoreInitRequest.decode(reader, reader.uint32());
                        break;
                    case 20:
                        message.specDataStoreInitRequest = $root.gauge.messages.SpecDataStoreInitRequest.decode(reader, reader.uint32());
                        break;
                    case 21:
                        message.suiteDataStoreInitRequest = $root.gauge.messages.SuiteDataStoreInitRequest.decode(reader, reader.uint32());
                        break;
                    case 22:
                        message.stepNameRequest = $root.gauge.messages.StepNameRequest.decode(reader, reader.uint32());
                        break;
                    case 23:
                        message.stepNameResponse = $root.gauge.messages.StepNameResponse.decode(reader, reader.uint32());
                        break;
                    case 24:
                        message.refactorRequest = $root.gauge.messages.RefactorRequest.decode(reader, reader.uint32());
                        break;
                    case 25:
                        message.refactorResponse = $root.gauge.messages.RefactorResponse.decode(reader, reader.uint32());
                        break;
                    case 26:
                        message.unsupportedMessageResponse = $root.gauge.messages.UnsupportedMessageResponse.decode(reader, reader.uint32());
                        break;
                    case 27:
                        message.cacheFileRequest = $root.gauge.messages.CacheFileRequest.decode(reader, reader.uint32());
                        break;
                    case 28:
                        message.stepPositionsRequest = $root.gauge.messages.StepPositionsRequest.decode(reader, reader.uint32());
                        break;
                    case 29:
                        message.stepPositionsResponse = $root.gauge.messages.StepPositionsResponse.decode(reader, reader.uint32());
                        break;
                    case 30:
                        message.implementationFileListRequest = $root.gauge.messages.ImplementationFileListRequest.decode(reader, reader.uint32());
                        break;
                    case 31:
                        message.implementationFileListResponse = $root.gauge.messages.ImplementationFileListResponse.decode(reader, reader.uint32());
                        break;
                    case 32:
                        message.stubImplementationCodeRequest = $root.gauge.messages.StubImplementationCodeRequest.decode(reader, reader.uint32());
                        break;
                    case 33:
                        message.fileDiff = $root.gauge.messages.FileDiff.decode(reader, reader.uint32());
                        break;
                    case 34:
                        message.implementationFileGlobPatternRequest = $root.gauge.messages.ImplementationFileGlobPatternRequest.decode(reader, reader.uint32());
                        break;
                    case 35:
                        message.implementationFileGlobPatternResponse = $root.gauge.messages.ImplementationFileGlobPatternResponse.decode(reader, reader.uint32());
                        break;
                    case 36:
                        message.suiteExecutionResultItem = $root.gauge.messages.SuiteExecutionResultItem.decode(reader, reader.uint32());
                        break;
                    case 37:
                        message.keepAlive = $root.gauge.messages.KeepAlive.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Message message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gauge.messages.Message
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gauge.messages.Message} Message
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Message.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Message message.
             * @function verify
             * @memberof gauge.messages.Message
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Message.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.messageType != null && message.hasOwnProperty("messageType"))
                    switch (message.messageType) {
                    default:
                        return "messageType: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                    case 8:
                    case 9:
                    case 10:
                    case 11:
                    case 12:
                    case 13:
                    case 14:
                    case 15:
                    case 16:
                    case 17:
                    case 18:
                    case 19:
                    case 20:
                    case 21:
                    case 22:
                    case 23:
                    case 24:
                    case 25:
                    case 26:
                    case 27:
                    case 28:
                    case 29:
                    case 30:
                    case 31:
                    case 32:
                    case 33:
                    case 34:
                        break;
                    }
                if (message.messageId != null && message.hasOwnProperty("messageId"))
                    if (!$util.isInteger(message.messageId) && !(message.messageId && $util.isInteger(message.messageId.low) && $util.isInteger(message.messageId.high)))
                        return "messageId: integer|Long expected";
                if (message.executionStartingRequest != null && message.hasOwnProperty("executionStartingRequest")) {
                    var error = $root.gauge.messages.ExecutionStartingRequest.verify(message.executionStartingRequest);
                    if (error)
                        return "executionStartingRequest." + error;
                }
                if (message.specExecutionStartingRequest != null && message.hasOwnProperty("specExecutionStartingRequest")) {
                    var error = $root.gauge.messages.SpecExecutionStartingRequest.verify(message.specExecutionStartingRequest);
                    if (error)
                        return "specExecutionStartingRequest." + error;
                }
                if (message.specExecutionEndingRequest != null && message.hasOwnProperty("specExecutionEndingRequest")) {
                    var error = $root.gauge.messages.SpecExecutionEndingRequest.verify(message.specExecutionEndingRequest);
                    if (error)
                        return "specExecutionEndingRequest." + error;
                }
                if (message.scenarioExecutionStartingRequest != null && message.hasOwnProperty("scenarioExecutionStartingRequest")) {
                    var error = $root.gauge.messages.ScenarioExecutionStartingRequest.verify(message.scenarioExecutionStartingRequest);
                    if (error)
                        return "scenarioExecutionStartingRequest." + error;
                }
                if (message.scenarioExecutionEndingRequest != null && message.hasOwnProperty("scenarioExecutionEndingRequest")) {
                    var error = $root.gauge.messages.ScenarioExecutionEndingRequest.verify(message.scenarioExecutionEndingRequest);
                    if (error)
                        return "scenarioExecutionEndingRequest." + error;
                }
                if (message.stepExecutionStartingRequest != null && message.hasOwnProperty("stepExecutionStartingRequest")) {
                    var error = $root.gauge.messages.StepExecutionStartingRequest.verify(message.stepExecutionStartingRequest);
                    if (error)
                        return "stepExecutionStartingRequest." + error;
                }
                if (message.stepExecutionEndingRequest != null && message.hasOwnProperty("stepExecutionEndingRequest")) {
                    var error = $root.gauge.messages.StepExecutionEndingRequest.verify(message.stepExecutionEndingRequest);
                    if (error)
                        return "stepExecutionEndingRequest." + error;
                }
                if (message.executeStepRequest != null && message.hasOwnProperty("executeStepRequest")) {
                    var error = $root.gauge.messages.ExecuteStepRequest.verify(message.executeStepRequest);
                    if (error)
                        return "executeStepRequest." + error;
                }
                if (message.executionEndingRequest != null && message.hasOwnProperty("executionEndingRequest")) {
                    var error = $root.gauge.messages.ExecutionEndingRequest.verify(message.executionEndingRequest);
                    if (error)
                        return "executionEndingRequest." + error;
                }
                if (message.stepValidateRequest != null && message.hasOwnProperty("stepValidateRequest")) {
                    var error = $root.gauge.messages.StepValidateRequest.verify(message.stepValidateRequest);
                    if (error)
                        return "stepValidateRequest." + error;
                }
                if (message.stepValidateResponse != null && message.hasOwnProperty("stepValidateResponse")) {
                    var error = $root.gauge.messages.StepValidateResponse.verify(message.stepValidateResponse);
                    if (error)
                        return "stepValidateResponse." + error;
                }
                if (message.executionStatusResponse != null && message.hasOwnProperty("executionStatusResponse")) {
                    var error = $root.gauge.messages.ExecutionStatusResponse.verify(message.executionStatusResponse);
                    if (error)
                        return "executionStatusResponse." + error;
                }
                if (message.stepNamesRequest != null && message.hasOwnProperty("stepNamesRequest")) {
                    var error = $root.gauge.messages.StepNamesRequest.verify(message.stepNamesRequest);
                    if (error)
                        return "stepNamesRequest." + error;
                }
                if (message.stepNamesResponse != null && message.hasOwnProperty("stepNamesResponse")) {
                    var error = $root.gauge.messages.StepNamesResponse.verify(message.stepNamesResponse);
                    if (error)
                        return "stepNamesResponse." + error;
                }
                if (message.suiteExecutionResult != null && message.hasOwnProperty("suiteExecutionResult")) {
                    var error = $root.gauge.messages.SuiteExecutionResult.verify(message.suiteExecutionResult);
                    if (error)
                        return "suiteExecutionResult." + error;
                }
                if (message.killProcessRequest != null && message.hasOwnProperty("killProcessRequest")) {
                    var error = $root.gauge.messages.KillProcessRequest.verify(message.killProcessRequest);
                    if (error)
                        return "killProcessRequest." + error;
                }
                if (message.scenarioDataStoreInitRequest != null && message.hasOwnProperty("scenarioDataStoreInitRequest")) {
                    var error = $root.gauge.messages.ScenarioDataStoreInitRequest.verify(message.scenarioDataStoreInitRequest);
                    if (error)
                        return "scenarioDataStoreInitRequest." + error;
                }
                if (message.specDataStoreInitRequest != null && message.hasOwnProperty("specDataStoreInitRequest")) {
                    var error = $root.gauge.messages.SpecDataStoreInitRequest.verify(message.specDataStoreInitRequest);
                    if (error)
                        return "specDataStoreInitRequest." + error;
                }
                if (message.suiteDataStoreInitRequest != null && message.hasOwnProperty("suiteDataStoreInitRequest")) {
                    var error = $root.gauge.messages.SuiteDataStoreInitRequest.verify(message.suiteDataStoreInitRequest);
                    if (error)
                        return "suiteDataStoreInitRequest." + error;
                }
                if (message.stepNameRequest != null && message.hasOwnProperty("stepNameRequest")) {
                    var error = $root.gauge.messages.StepNameRequest.verify(message.stepNameRequest);
                    if (error)
                        return "stepNameRequest." + error;
                }
                if (message.stepNameResponse != null && message.hasOwnProperty("stepNameResponse")) {
                    var error = $root.gauge.messages.StepNameResponse.verify(message.stepNameResponse);
                    if (error)
                        return "stepNameResponse." + error;
                }
                if (message.refactorRequest != null && message.hasOwnProperty("refactorRequest")) {
                    var error = $root.gauge.messages.RefactorRequest.verify(message.refactorRequest);
                    if (error)
                        return "refactorRequest." + error;
                }
                if (message.refactorResponse != null && message.hasOwnProperty("refactorResponse")) {
                    var error = $root.gauge.messages.RefactorResponse.verify(message.refactorResponse);
                    if (error)
                        return "refactorResponse." + error;
                }
                if (message.unsupportedMessageResponse != null && message.hasOwnProperty("unsupportedMessageResponse")) {
                    var error = $root.gauge.messages.UnsupportedMessageResponse.verify(message.unsupportedMessageResponse);
                    if (error)
                        return "unsupportedMessageResponse." + error;
                }
                if (message.cacheFileRequest != null && message.hasOwnProperty("cacheFileRequest")) {
                    var error = $root.gauge.messages.CacheFileRequest.verify(message.cacheFileRequest);
                    if (error)
                        return "cacheFileRequest." + error;
                }
                if (message.stepPositionsRequest != null && message.hasOwnProperty("stepPositionsRequest")) {
                    var error = $root.gauge.messages.StepPositionsRequest.verify(message.stepPositionsRequest);
                    if (error)
                        return "stepPositionsRequest." + error;
                }
                if (message.stepPositionsResponse != null && message.hasOwnProperty("stepPositionsResponse")) {
                    var error = $root.gauge.messages.StepPositionsResponse.verify(message.stepPositionsResponse);
                    if (error)
                        return "stepPositionsResponse." + error;
                }
                if (message.implementationFileListRequest != null && message.hasOwnProperty("implementationFileListRequest")) {
                    var error = $root.gauge.messages.ImplementationFileListRequest.verify(message.implementationFileListRequest);
                    if (error)
                        return "implementationFileListRequest." + error;
                }
                if (message.implementationFileListResponse != null && message.hasOwnProperty("implementationFileListResponse")) {
                    var error = $root.gauge.messages.ImplementationFileListResponse.verify(message.implementationFileListResponse);
                    if (error)
                        return "implementationFileListResponse." + error;
                }
                if (message.stubImplementationCodeRequest != null && message.hasOwnProperty("stubImplementationCodeRequest")) {
                    var error = $root.gauge.messages.StubImplementationCodeRequest.verify(message.stubImplementationCodeRequest);
                    if (error)
                        return "stubImplementationCodeRequest." + error;
                }
                if (message.fileDiff != null && message.hasOwnProperty("fileDiff")) {
                    var error = $root.gauge.messages.FileDiff.verify(message.fileDiff);
                    if (error)
                        return "fileDiff." + error;
                }
                if (message.implementationFileGlobPatternRequest != null && message.hasOwnProperty("implementationFileGlobPatternRequest")) {
                    var error = $root.gauge.messages.ImplementationFileGlobPatternRequest.verify(message.implementationFileGlobPatternRequest);
                    if (error)
                        return "implementationFileGlobPatternRequest." + error;
                }
                if (message.implementationFileGlobPatternResponse != null && message.hasOwnProperty("implementationFileGlobPatternResponse")) {
                    var error = $root.gauge.messages.ImplementationFileGlobPatternResponse.verify(message.implementationFileGlobPatternResponse);
                    if (error)
                        return "implementationFileGlobPatternResponse." + error;
                }
                if (message.suiteExecutionResultItem != null && message.hasOwnProperty("suiteExecutionResultItem")) {
                    var error = $root.gauge.messages.SuiteExecutionResultItem.verify(message.suiteExecutionResultItem);
                    if (error)
                        return "suiteExecutionResultItem." + error;
                }
                if (message.keepAlive != null && message.hasOwnProperty("keepAlive")) {
                    var error = $root.gauge.messages.KeepAlive.verify(message.keepAlive);
                    if (error)
                        return "keepAlive." + error;
                }
                return null;
            };

            /**
             * Creates a Message message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gauge.messages.Message
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gauge.messages.Message} Message
             */
            Message.fromObject = function fromObject(object) {
                if (object instanceof $root.gauge.messages.Message)
                    return object;
                var message = new $root.gauge.messages.Message();
                switch (object.messageType) {
                case "ExecutionStarting":
                case 0:
                    message.messageType = 0;
                    break;
                case "SpecExecutionStarting":
                case 1:
                    message.messageType = 1;
                    break;
                case "SpecExecutionEnding":
                case 2:
                    message.messageType = 2;
                    break;
                case "ScenarioExecutionStarting":
                case 3:
                    message.messageType = 3;
                    break;
                case "ScenarioExecutionEnding":
                case 4:
                    message.messageType = 4;
                    break;
                case "StepExecutionStarting":
                case 5:
                    message.messageType = 5;
                    break;
                case "StepExecutionEnding":
                case 6:
                    message.messageType = 6;
                    break;
                case "ExecuteStep":
                case 7:
                    message.messageType = 7;
                    break;
                case "ExecutionEnding":
                case 8:
                    message.messageType = 8;
                    break;
                case "StepValidateRequest":
                case 9:
                    message.messageType = 9;
                    break;
                case "StepValidateResponse":
                case 10:
                    message.messageType = 10;
                    break;
                case "ExecutionStatusResponse":
                case 11:
                    message.messageType = 11;
                    break;
                case "StepNamesRequest":
                case 12:
                    message.messageType = 12;
                    break;
                case "StepNamesResponse":
                case 13:
                    message.messageType = 13;
                    break;
                case "KillProcessRequest":
                case 14:
                    message.messageType = 14;
                    break;
                case "SuiteExecutionResult":
                case 15:
                    message.messageType = 15;
                    break;
                case "ScenarioDataStoreInit":
                case 16:
                    message.messageType = 16;
                    break;
                case "SpecDataStoreInit":
                case 17:
                    message.messageType = 17;
                    break;
                case "SuiteDataStoreInit":
                case 18:
                    message.messageType = 18;
                    break;
                case "StepNameRequest":
                case 19:
                    message.messageType = 19;
                    break;
                case "StepNameResponse":
                case 20:
                    message.messageType = 20;
                    break;
                case "RefactorRequest":
                case 21:
                    message.messageType = 21;
                    break;
                case "RefactorResponse":
                case 22:
                    message.messageType = 22;
                    break;
                case "UnsupportedMessageResponse":
                case 23:
                    message.messageType = 23;
                    break;
                case "CacheFileRequest":
                case 24:
                    message.messageType = 24;
                    break;
                case "StepPositionsRequest":
                case 25:
                    message.messageType = 25;
                    break;
                case "StepPositionsResponse":
                case 26:
                    message.messageType = 26;
                    break;
                case "ImplementationFileListRequest":
                case 27:
                    message.messageType = 27;
                    break;
                case "ImplementationFileListResponse":
                case 28:
                    message.messageType = 28;
                    break;
                case "StubImplementationCodeRequest":
                case 29:
                    message.messageType = 29;
                    break;
                case "FileDiff":
                case 30:
                    message.messageType = 30;
                    break;
                case "ImplementationFileGlobPatternRequest":
                case 31:
                    message.messageType = 31;
                    break;
                case "ImplementationFileGlobPatternResponse":
                case 32:
                    message.messageType = 32;
                    break;
                case "SuiteExecutionResultItem":
                case 33:
                    message.messageType = 33;
                    break;
                case "KeepAlive":
                case 34:
                    message.messageType = 34;
                    break;
                }
                if (object.messageId != null)
                    if ($util.Long)
                        (message.messageId = $util.Long.fromValue(object.messageId)).unsigned = false;
                    else if (typeof object.messageId === "string")
                        message.messageId = parseInt(object.messageId, 10);
                    else if (typeof object.messageId === "number")
                        message.messageId = object.messageId;
                    else if (typeof object.messageId === "object")
                        message.messageId = new $util.LongBits(object.messageId.low >>> 0, object.messageId.high >>> 0).toNumber();
                if (object.executionStartingRequest != null) {
                    if (typeof object.executionStartingRequest !== "object")
                        throw TypeError(".gauge.messages.Message.executionStartingRequest: object expected");
                    message.executionStartingRequest = $root.gauge.messages.ExecutionStartingRequest.fromObject(object.executionStartingRequest);
                }
                if (object.specExecutionStartingRequest != null) {
                    if (typeof object.specExecutionStartingRequest !== "object")
                        throw TypeError(".gauge.messages.Message.specExecutionStartingRequest: object expected");
                    message.specExecutionStartingRequest = $root.gauge.messages.SpecExecutionStartingRequest.fromObject(object.specExecutionStartingRequest);
                }
                if (object.specExecutionEndingRequest != null) {
                    if (typeof object.specExecutionEndingRequest !== "object")
                        throw TypeError(".gauge.messages.Message.specExecutionEndingRequest: object expected");
                    message.specExecutionEndingRequest = $root.gauge.messages.SpecExecutionEndingRequest.fromObject(object.specExecutionEndingRequest);
                }
                if (object.scenarioExecutionStartingRequest != null) {
                    if (typeof object.scenarioExecutionStartingRequest !== "object")
                        throw TypeError(".gauge.messages.Message.scenarioExecutionStartingRequest: object expected");
                    message.scenarioExecutionStartingRequest = $root.gauge.messages.ScenarioExecutionStartingRequest.fromObject(object.scenarioExecutionStartingRequest);
                }
                if (object.scenarioExecutionEndingRequest != null) {
                    if (typeof object.scenarioExecutionEndingRequest !== "object")
                        throw TypeError(".gauge.messages.Message.scenarioExecutionEndingRequest: object expected");
                    message.scenarioExecutionEndingRequest = $root.gauge.messages.ScenarioExecutionEndingRequest.fromObject(object.scenarioExecutionEndingRequest);
                }
                if (object.stepExecutionStartingRequest != null) {
                    if (typeof object.stepExecutionStartingRequest !== "object")
                        throw TypeError(".gauge.messages.Message.stepExecutionStartingRequest: object expected");
                    message.stepExecutionStartingRequest = $root.gauge.messages.StepExecutionStartingRequest.fromObject(object.stepExecutionStartingRequest);
                }
                if (object.stepExecutionEndingRequest != null) {
                    if (typeof object.stepExecutionEndingRequest !== "object")
                        throw TypeError(".gauge.messages.Message.stepExecutionEndingRequest: object expected");
                    message.stepExecutionEndingRequest = $root.gauge.messages.StepExecutionEndingRequest.fromObject(object.stepExecutionEndingRequest);
                }
                if (object.executeStepRequest != null) {
                    if (typeof object.executeStepRequest !== "object")
                        throw TypeError(".gauge.messages.Message.executeStepRequest: object expected");
                    message.executeStepRequest = $root.gauge.messages.ExecuteStepRequest.fromObject(object.executeStepRequest);
                }
                if (object.executionEndingRequest != null) {
                    if (typeof object.executionEndingRequest !== "object")
                        throw TypeError(".gauge.messages.Message.executionEndingRequest: object expected");
                    message.executionEndingRequest = $root.gauge.messages.ExecutionEndingRequest.fromObject(object.executionEndingRequest);
                }
                if (object.stepValidateRequest != null) {
                    if (typeof object.stepValidateRequest !== "object")
                        throw TypeError(".gauge.messages.Message.stepValidateRequest: object expected");
                    message.stepValidateRequest = $root.gauge.messages.StepValidateRequest.fromObject(object.stepValidateRequest);
                }
                if (object.stepValidateResponse != null) {
                    if (typeof object.stepValidateResponse !== "object")
                        throw TypeError(".gauge.messages.Message.stepValidateResponse: object expected");
                    message.stepValidateResponse = $root.gauge.messages.StepValidateResponse.fromObject(object.stepValidateResponse);
                }
                if (object.executionStatusResponse != null) {
                    if (typeof object.executionStatusResponse !== "object")
                        throw TypeError(".gauge.messages.Message.executionStatusResponse: object expected");
                    message.executionStatusResponse = $root.gauge.messages.ExecutionStatusResponse.fromObject(object.executionStatusResponse);
                }
                if (object.stepNamesRequest != null) {
                    if (typeof object.stepNamesRequest !== "object")
                        throw TypeError(".gauge.messages.Message.stepNamesRequest: object expected");
                    message.stepNamesRequest = $root.gauge.messages.StepNamesRequest.fromObject(object.stepNamesRequest);
                }
                if (object.stepNamesResponse != null) {
                    if (typeof object.stepNamesResponse !== "object")
                        throw TypeError(".gauge.messages.Message.stepNamesResponse: object expected");
                    message.stepNamesResponse = $root.gauge.messages.StepNamesResponse.fromObject(object.stepNamesResponse);
                }
                if (object.suiteExecutionResult != null) {
                    if (typeof object.suiteExecutionResult !== "object")
                        throw TypeError(".gauge.messages.Message.suiteExecutionResult: object expected");
                    message.suiteExecutionResult = $root.gauge.messages.SuiteExecutionResult.fromObject(object.suiteExecutionResult);
                }
                if (object.killProcessRequest != null) {
                    if (typeof object.killProcessRequest !== "object")
                        throw TypeError(".gauge.messages.Message.killProcessRequest: object expected");
                    message.killProcessRequest = $root.gauge.messages.KillProcessRequest.fromObject(object.killProcessRequest);
                }
                if (object.scenarioDataStoreInitRequest != null) {
                    if (typeof object.scenarioDataStoreInitRequest !== "object")
                        throw TypeError(".gauge.messages.Message.scenarioDataStoreInitRequest: object expected");
                    message.scenarioDataStoreInitRequest = $root.gauge.messages.ScenarioDataStoreInitRequest.fromObject(object.scenarioDataStoreInitRequest);
                }
                if (object.specDataStoreInitRequest != null) {
                    if (typeof object.specDataStoreInitRequest !== "object")
                        throw TypeError(".gauge.messages.Message.specDataStoreInitRequest: object expected");
                    message.specDataStoreInitRequest = $root.gauge.messages.SpecDataStoreInitRequest.fromObject(object.specDataStoreInitRequest);
                }
                if (object.suiteDataStoreInitRequest != null) {
                    if (typeof object.suiteDataStoreInitRequest !== "object")
                        throw TypeError(".gauge.messages.Message.suiteDataStoreInitRequest: object expected");
                    message.suiteDataStoreInitRequest = $root.gauge.messages.SuiteDataStoreInitRequest.fromObject(object.suiteDataStoreInitRequest);
                }
                if (object.stepNameRequest != null) {
                    if (typeof object.stepNameRequest !== "object")
                        throw TypeError(".gauge.messages.Message.stepNameRequest: object expected");
                    message.stepNameRequest = $root.gauge.messages.StepNameRequest.fromObject(object.stepNameRequest);
                }
                if (object.stepNameResponse != null) {
                    if (typeof object.stepNameResponse !== "object")
                        throw TypeError(".gauge.messages.Message.stepNameResponse: object expected");
                    message.stepNameResponse = $root.gauge.messages.StepNameResponse.fromObject(object.stepNameResponse);
                }
                if (object.refactorRequest != null) {
                    if (typeof object.refactorRequest !== "object")
                        throw TypeError(".gauge.messages.Message.refactorRequest: object expected");
                    message.refactorRequest = $root.gauge.messages.RefactorRequest.fromObject(object.refactorRequest);
                }
                if (object.refactorResponse != null) {
                    if (typeof object.refactorResponse !== "object")
                        throw TypeError(".gauge.messages.Message.refactorResponse: object expected");
                    message.refactorResponse = $root.gauge.messages.RefactorResponse.fromObject(object.refactorResponse);
                }
                if (object.unsupportedMessageResponse != null) {
                    if (typeof object.unsupportedMessageResponse !== "object")
                        throw TypeError(".gauge.messages.Message.unsupportedMessageResponse: object expected");
                    message.unsupportedMessageResponse = $root.gauge.messages.UnsupportedMessageResponse.fromObject(object.unsupportedMessageResponse);
                }
                if (object.cacheFileRequest != null) {
                    if (typeof object.cacheFileRequest !== "object")
                        throw TypeError(".gauge.messages.Message.cacheFileRequest: object expected");
                    message.cacheFileRequest = $root.gauge.messages.CacheFileRequest.fromObject(object.cacheFileRequest);
                }
                if (object.stepPositionsRequest != null) {
                    if (typeof object.stepPositionsRequest !== "object")
                        throw TypeError(".gauge.messages.Message.stepPositionsRequest: object expected");
                    message.stepPositionsRequest = $root.gauge.messages.StepPositionsRequest.fromObject(object.stepPositionsRequest);
                }
                if (object.stepPositionsResponse != null) {
                    if (typeof object.stepPositionsResponse !== "object")
                        throw TypeError(".gauge.messages.Message.stepPositionsResponse: object expected");
                    message.stepPositionsResponse = $root.gauge.messages.StepPositionsResponse.fromObject(object.stepPositionsResponse);
                }
                if (object.implementationFileListRequest != null) {
                    if (typeof object.implementationFileListRequest !== "object")
                        throw TypeError(".gauge.messages.Message.implementationFileListRequest: object expected");
                    message.implementationFileListRequest = $root.gauge.messages.ImplementationFileListRequest.fromObject(object.implementationFileListRequest);
                }
                if (object.implementationFileListResponse != null) {
                    if (typeof object.implementationFileListResponse !== "object")
                        throw TypeError(".gauge.messages.Message.implementationFileListResponse: object expected");
                    message.implementationFileListResponse = $root.gauge.messages.ImplementationFileListResponse.fromObject(object.implementationFileListResponse);
                }
                if (object.stubImplementationCodeRequest != null) {
                    if (typeof object.stubImplementationCodeRequest !== "object")
                        throw TypeError(".gauge.messages.Message.stubImplementationCodeRequest: object expected");
                    message.stubImplementationCodeRequest = $root.gauge.messages.StubImplementationCodeRequest.fromObject(object.stubImplementationCodeRequest);
                }
                if (object.fileDiff != null) {
                    if (typeof object.fileDiff !== "object")
                        throw TypeError(".gauge.messages.Message.fileDiff: object expected");
                    message.fileDiff = $root.gauge.messages.FileDiff.fromObject(object.fileDiff);
                }
                if (object.implementationFileGlobPatternRequest != null) {
                    if (typeof object.implementationFileGlobPatternRequest !== "object")
                        throw TypeError(".gauge.messages.Message.implementationFileGlobPatternRequest: object expected");
                    message.implementationFileGlobPatternRequest = $root.gauge.messages.ImplementationFileGlobPatternRequest.fromObject(object.implementationFileGlobPatternRequest);
                }
                if (object.implementationFileGlobPatternResponse != null) {
                    if (typeof object.implementationFileGlobPatternResponse !== "object")
                        throw TypeError(".gauge.messages.Message.implementationFileGlobPatternResponse: object expected");
                    message.implementationFileGlobPatternResponse = $root.gauge.messages.ImplementationFileGlobPatternResponse.fromObject(object.implementationFileGlobPatternResponse);
                }
                if (object.suiteExecutionResultItem != null) {
                    if (typeof object.suiteExecutionResultItem !== "object")
                        throw TypeError(".gauge.messages.Message.suiteExecutionResultItem: object expected");
                    message.suiteExecutionResultItem = $root.gauge.messages.SuiteExecutionResultItem.fromObject(object.suiteExecutionResultItem);
                }
                if (object.keepAlive != null) {
                    if (typeof object.keepAlive !== "object")
                        throw TypeError(".gauge.messages.Message.keepAlive: object expected");
                    message.keepAlive = $root.gauge.messages.KeepAlive.fromObject(object.keepAlive);
                }
                return message;
            };

            /**
             * Creates a plain object from a Message message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gauge.messages.Message
             * @static
             * @param {gauge.messages.Message} message Message
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Message.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.messageType = options.enums === String ? "ExecutionStarting" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.messageId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.messageId = options.longs === String ? "0" : 0;
                    object.executionStartingRequest = null;
                    object.specExecutionStartingRequest = null;
                    object.specExecutionEndingRequest = null;
                    object.scenarioExecutionStartingRequest = null;
                    object.scenarioExecutionEndingRequest = null;
                    object.stepExecutionStartingRequest = null;
                    object.stepExecutionEndingRequest = null;
                    object.executeStepRequest = null;
                    object.executionEndingRequest = null;
                    object.stepValidateRequest = null;
                    object.stepValidateResponse = null;
                    object.executionStatusResponse = null;
                    object.stepNamesRequest = null;
                    object.stepNamesResponse = null;
                    object.suiteExecutionResult = null;
                    object.killProcessRequest = null;
                    object.scenarioDataStoreInitRequest = null;
                    object.specDataStoreInitRequest = null;
                    object.suiteDataStoreInitRequest = null;
                    object.stepNameRequest = null;
                    object.stepNameResponse = null;
                    object.refactorRequest = null;
                    object.refactorResponse = null;
                    object.unsupportedMessageResponse = null;
                    object.cacheFileRequest = null;
                    object.stepPositionsRequest = null;
                    object.stepPositionsResponse = null;
                    object.implementationFileListRequest = null;
                    object.implementationFileListResponse = null;
                    object.stubImplementationCodeRequest = null;
                    object.fileDiff = null;
                    object.implementationFileGlobPatternRequest = null;
                    object.implementationFileGlobPatternResponse = null;
                    object.suiteExecutionResultItem = null;
                    object.keepAlive = null;
                }
                if (message.messageType != null && message.hasOwnProperty("messageType"))
                    object.messageType = options.enums === String ? $root.gauge.messages.Message.MessageType[message.messageType] : message.messageType;
                if (message.messageId != null && message.hasOwnProperty("messageId"))
                    if (typeof message.messageId === "number")
                        object.messageId = options.longs === String ? String(message.messageId) : message.messageId;
                    else
                        object.messageId = options.longs === String ? $util.Long.prototype.toString.call(message.messageId) : options.longs === Number ? new $util.LongBits(message.messageId.low >>> 0, message.messageId.high >>> 0).toNumber() : message.messageId;
                if (message.executionStartingRequest != null && message.hasOwnProperty("executionStartingRequest"))
                    object.executionStartingRequest = $root.gauge.messages.ExecutionStartingRequest.toObject(message.executionStartingRequest, options);
                if (message.specExecutionStartingRequest != null && message.hasOwnProperty("specExecutionStartingRequest"))
                    object.specExecutionStartingRequest = $root.gauge.messages.SpecExecutionStartingRequest.toObject(message.specExecutionStartingRequest, options);
                if (message.specExecutionEndingRequest != null && message.hasOwnProperty("specExecutionEndingRequest"))
                    object.specExecutionEndingRequest = $root.gauge.messages.SpecExecutionEndingRequest.toObject(message.specExecutionEndingRequest, options);
                if (message.scenarioExecutionStartingRequest != null && message.hasOwnProperty("scenarioExecutionStartingRequest"))
                    object.scenarioExecutionStartingRequest = $root.gauge.messages.ScenarioExecutionStartingRequest.toObject(message.scenarioExecutionStartingRequest, options);
                if (message.scenarioExecutionEndingRequest != null && message.hasOwnProperty("scenarioExecutionEndingRequest"))
                    object.scenarioExecutionEndingRequest = $root.gauge.messages.ScenarioExecutionEndingRequest.toObject(message.scenarioExecutionEndingRequest, options);
                if (message.stepExecutionStartingRequest != null && message.hasOwnProperty("stepExecutionStartingRequest"))
                    object.stepExecutionStartingRequest = $root.gauge.messages.StepExecutionStartingRequest.toObject(message.stepExecutionStartingRequest, options);
                if (message.stepExecutionEndingRequest != null && message.hasOwnProperty("stepExecutionEndingRequest"))
                    object.stepExecutionEndingRequest = $root.gauge.messages.StepExecutionEndingRequest.toObject(message.stepExecutionEndingRequest, options);
                if (message.executeStepRequest != null && message.hasOwnProperty("executeStepRequest"))
                    object.executeStepRequest = $root.gauge.messages.ExecuteStepRequest.toObject(message.executeStepRequest, options);
                if (message.executionEndingRequest != null && message.hasOwnProperty("executionEndingRequest"))
                    object.executionEndingRequest = $root.gauge.messages.ExecutionEndingRequest.toObject(message.executionEndingRequest, options);
                if (message.stepValidateRequest != null && message.hasOwnProperty("stepValidateRequest"))
                    object.stepValidateRequest = $root.gauge.messages.StepValidateRequest.toObject(message.stepValidateRequest, options);
                if (message.stepValidateResponse != null && message.hasOwnProperty("stepValidateResponse"))
                    object.stepValidateResponse = $root.gauge.messages.StepValidateResponse.toObject(message.stepValidateResponse, options);
                if (message.executionStatusResponse != null && message.hasOwnProperty("executionStatusResponse"))
                    object.executionStatusResponse = $root.gauge.messages.ExecutionStatusResponse.toObject(message.executionStatusResponse, options);
                if (message.stepNamesRequest != null && message.hasOwnProperty("stepNamesRequest"))
                    object.stepNamesRequest = $root.gauge.messages.StepNamesRequest.toObject(message.stepNamesRequest, options);
                if (message.stepNamesResponse != null && message.hasOwnProperty("stepNamesResponse"))
                    object.stepNamesResponse = $root.gauge.messages.StepNamesResponse.toObject(message.stepNamesResponse, options);
                if (message.suiteExecutionResult != null && message.hasOwnProperty("suiteExecutionResult"))
                    object.suiteExecutionResult = $root.gauge.messages.SuiteExecutionResult.toObject(message.suiteExecutionResult, options);
                if (message.killProcessRequest != null && message.hasOwnProperty("killProcessRequest"))
                    object.killProcessRequest = $root.gauge.messages.KillProcessRequest.toObject(message.killProcessRequest, options);
                if (message.scenarioDataStoreInitRequest != null && message.hasOwnProperty("scenarioDataStoreInitRequest"))
                    object.scenarioDataStoreInitRequest = $root.gauge.messages.ScenarioDataStoreInitRequest.toObject(message.scenarioDataStoreInitRequest, options);
                if (message.specDataStoreInitRequest != null && message.hasOwnProperty("specDataStoreInitRequest"))
                    object.specDataStoreInitRequest = $root.gauge.messages.SpecDataStoreInitRequest.toObject(message.specDataStoreInitRequest, options);
                if (message.suiteDataStoreInitRequest != null && message.hasOwnProperty("suiteDataStoreInitRequest"))
                    object.suiteDataStoreInitRequest = $root.gauge.messages.SuiteDataStoreInitRequest.toObject(message.suiteDataStoreInitRequest, options);
                if (message.stepNameRequest != null && message.hasOwnProperty("stepNameRequest"))
                    object.stepNameRequest = $root.gauge.messages.StepNameRequest.toObject(message.stepNameRequest, options);
                if (message.stepNameResponse != null && message.hasOwnProperty("stepNameResponse"))
                    object.stepNameResponse = $root.gauge.messages.StepNameResponse.toObject(message.stepNameResponse, options);
                if (message.refactorRequest != null && message.hasOwnProperty("refactorRequest"))
                    object.refactorRequest = $root.gauge.messages.RefactorRequest.toObject(message.refactorRequest, options);
                if (message.refactorResponse != null && message.hasOwnProperty("refactorResponse"))
                    object.refactorResponse = $root.gauge.messages.RefactorResponse.toObject(message.refactorResponse, options);
                if (message.unsupportedMessageResponse != null && message.hasOwnProperty("unsupportedMessageResponse"))
                    object.unsupportedMessageResponse = $root.gauge.messages.UnsupportedMessageResponse.toObject(message.unsupportedMessageResponse, options);
                if (message.cacheFileRequest != null && message.hasOwnProperty("cacheFileRequest"))
                    object.cacheFileRequest = $root.gauge.messages.CacheFileRequest.toObject(message.cacheFileRequest, options);
                if (message.stepPositionsRequest != null && message.hasOwnProperty("stepPositionsRequest"))
                    object.stepPositionsRequest = $root.gauge.messages.StepPositionsRequest.toObject(message.stepPositionsRequest, options);
                if (message.stepPositionsResponse != null && message.hasOwnProperty("stepPositionsResponse"))
                    object.stepPositionsResponse = $root.gauge.messages.StepPositionsResponse.toObject(message.stepPositionsResponse, options);
                if (message.implementationFileListRequest != null && message.hasOwnProperty("implementationFileListRequest"))
                    object.implementationFileListRequest = $root.gauge.messages.ImplementationFileListRequest.toObject(message.implementationFileListRequest, options);
                if (message.implementationFileListResponse != null && message.hasOwnProperty("implementationFileListResponse"))
                    object.implementationFileListResponse = $root.gauge.messages.ImplementationFileListResponse.toObject(message.implementationFileListResponse, options);
                if (message.stubImplementationCodeRequest != null && message.hasOwnProperty("stubImplementationCodeRequest"))
                    object.stubImplementationCodeRequest = $root.gauge.messages.StubImplementationCodeRequest.toObject(message.stubImplementationCodeRequest, options);
                if (message.fileDiff != null && message.hasOwnProperty("fileDiff"))
                    object.fileDiff = $root.gauge.messages.FileDiff.toObject(message.fileDiff, options);
                if (message.implementationFileGlobPatternRequest != null && message.hasOwnProperty("implementationFileGlobPatternRequest"))
                    object.implementationFileGlobPatternRequest = $root.gauge.messages.ImplementationFileGlobPatternRequest.toObject(message.implementationFileGlobPatternRequest, options);
                if (message.implementationFileGlobPatternResponse != null && message.hasOwnProperty("implementationFileGlobPatternResponse"))
                    object.implementationFileGlobPatternResponse = $root.gauge.messages.ImplementationFileGlobPatternResponse.toObject(message.implementationFileGlobPatternResponse, options);
                if (message.suiteExecutionResultItem != null && message.hasOwnProperty("suiteExecutionResultItem"))
                    object.suiteExecutionResultItem = $root.gauge.messages.SuiteExecutionResultItem.toObject(message.suiteExecutionResultItem, options);
                if (message.keepAlive != null && message.hasOwnProperty("keepAlive"))
                    object.keepAlive = $root.gauge.messages.KeepAlive.toObject(message.keepAlive, options);
                return object;
            };

            /**
             * Converts this Message to JSON.
             * @function toJSON
             * @memberof gauge.messages.Message
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Message.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * MessageType enum.
             * @name gauge.messages.Message.MessageType
             * @enum {string}
             * @property {number} ExecutionStarting=0 ExecutionStarting value
             * @property {number} SpecExecutionStarting=1 SpecExecutionStarting value
             * @property {number} SpecExecutionEnding=2 SpecExecutionEnding value
             * @property {number} ScenarioExecutionStarting=3 ScenarioExecutionStarting value
             * @property {number} ScenarioExecutionEnding=4 ScenarioExecutionEnding value
             * @property {number} StepExecutionStarting=5 StepExecutionStarting value
             * @property {number} StepExecutionEnding=6 StepExecutionEnding value
             * @property {number} ExecuteStep=7 ExecuteStep value
             * @property {number} ExecutionEnding=8 ExecutionEnding value
             * @property {number} StepValidateRequest=9 StepValidateRequest value
             * @property {number} StepValidateResponse=10 StepValidateResponse value
             * @property {number} ExecutionStatusResponse=11 ExecutionStatusResponse value
             * @property {number} StepNamesRequest=12 StepNamesRequest value
             * @property {number} StepNamesResponse=13 StepNamesResponse value
             * @property {number} KillProcessRequest=14 KillProcessRequest value
             * @property {number} SuiteExecutionResult=15 SuiteExecutionResult value
             * @property {number} ScenarioDataStoreInit=16 ScenarioDataStoreInit value
             * @property {number} SpecDataStoreInit=17 SpecDataStoreInit value
             * @property {number} SuiteDataStoreInit=18 SuiteDataStoreInit value
             * @property {number} StepNameRequest=19 StepNameRequest value
             * @property {number} StepNameResponse=20 StepNameResponse value
             * @property {number} RefactorRequest=21 RefactorRequest value
             * @property {number} RefactorResponse=22 RefactorResponse value
             * @property {number} UnsupportedMessageResponse=23 UnsupportedMessageResponse value
             * @property {number} CacheFileRequest=24 CacheFileRequest value
             * @property {number} StepPositionsRequest=25 StepPositionsRequest value
             * @property {number} StepPositionsResponse=26 StepPositionsResponse value
             * @property {number} ImplementationFileListRequest=27 ImplementationFileListRequest value
             * @property {number} ImplementationFileListResponse=28 ImplementationFileListResponse value
             * @property {number} StubImplementationCodeRequest=29 StubImplementationCodeRequest value
             * @property {number} FileDiff=30 FileDiff value
             * @property {number} ImplementationFileGlobPatternRequest=31 ImplementationFileGlobPatternRequest value
             * @property {number} ImplementationFileGlobPatternResponse=32 ImplementationFileGlobPatternResponse value
             * @property {number} SuiteExecutionResultItem=33 SuiteExecutionResultItem value
             * @property {number} KeepAlive=34 KeepAlive value
             */
            Message.MessageType = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "ExecutionStarting"] = 0;
                values[valuesById[1] = "SpecExecutionStarting"] = 1;
                values[valuesById[2] = "SpecExecutionEnding"] = 2;
                values[valuesById[3] = "ScenarioExecutionStarting"] = 3;
                values[valuesById[4] = "ScenarioExecutionEnding"] = 4;
                values[valuesById[5] = "StepExecutionStarting"] = 5;
                values[valuesById[6] = "StepExecutionEnding"] = 6;
                values[valuesById[7] = "ExecuteStep"] = 7;
                values[valuesById[8] = "ExecutionEnding"] = 8;
                values[valuesById[9] = "StepValidateRequest"] = 9;
                values[valuesById[10] = "StepValidateResponse"] = 10;
                values[valuesById[11] = "ExecutionStatusResponse"] = 11;
                values[valuesById[12] = "StepNamesRequest"] = 12;
                values[valuesById[13] = "StepNamesResponse"] = 13;
                values[valuesById[14] = "KillProcessRequest"] = 14;
                values[valuesById[15] = "SuiteExecutionResult"] = 15;
                values[valuesById[16] = "ScenarioDataStoreInit"] = 16;
                values[valuesById[17] = "SpecDataStoreInit"] = 17;
                values[valuesById[18] = "SuiteDataStoreInit"] = 18;
                values[valuesById[19] = "StepNameRequest"] = 19;
                values[valuesById[20] = "StepNameResponse"] = 20;
                values[valuesById[21] = "RefactorRequest"] = 21;
                values[valuesById[22] = "RefactorResponse"] = 22;
                values[valuesById[23] = "UnsupportedMessageResponse"] = 23;
                values[valuesById[24] = "CacheFileRequest"] = 24;
                values[valuesById[25] = "StepPositionsRequest"] = 25;
                values[valuesById[26] = "StepPositionsResponse"] = 26;
                values[valuesById[27] = "ImplementationFileListRequest"] = 27;
                values[valuesById[28] = "ImplementationFileListResponse"] = 28;
                values[valuesById[29] = "StubImplementationCodeRequest"] = 29;
                values[valuesById[30] = "FileDiff"] = 30;
                values[valuesById[31] = "ImplementationFileGlobPatternRequest"] = 31;
                values[valuesById[32] = "ImplementationFileGlobPatternResponse"] = 32;
                values[valuesById[33] = "SuiteExecutionResultItem"] = 33;
                values[valuesById[34] = "KeepAlive"] = 34;
                return values;
            })();

            return Message;
        })();

        messages.Runner = (function() {

            /**
             * Constructs a new Runner service.
             * @memberof gauge.messages
             * @classdesc Represents a Runner
             * @extends $protobuf.rpc.Service
             * @constructor
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             */
            function Runner(rpcImpl, requestDelimited, responseDelimited) {
                $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
            }

            (Runner.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = Runner;

            /**
             * Creates new Runner service using the specified rpc implementation.
             * @function create
             * @memberof gauge.messages.Runner
             * @static
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             * @returns {Runner} RPC service. Useful where requests and/or responses are streamed.
             */
            Runner.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                return new this(rpcImpl, requestDelimited, responseDelimited);
            };

            /**
             * Callback as used by {@link gauge.messages.Runner#validateStep}.
             * @memberof gauge.messages.Runner
             * @typedef ValidateStepCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {gauge.messages.StepValidateResponse} [response] StepValidateResponse
             */

            /**
             * Calls ValidateStep.
             * @function validateStep
             * @memberof gauge.messages.Runner
             * @instance
             * @param {gauge.messages.IStepValidateRequest} request StepValidateRequest message or plain object
             * @param {gauge.messages.Runner.ValidateStepCallback} callback Node-style callback called with the error, if any, and StepValidateResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Runner.prototype.validateStep = function validateStep(request, callback) {
                return this.rpcCall(validateStep, $root.gauge.messages.StepValidateRequest, $root.gauge.messages.StepValidateResponse, request, callback);
            }, "name", { value: "ValidateStep" });

            /**
             * Calls ValidateStep.
             * @function validateStep
             * @memberof gauge.messages.Runner
             * @instance
             * @param {gauge.messages.IStepValidateRequest} request StepValidateRequest message or plain object
             * @returns {Promise<gauge.messages.StepValidateResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link gauge.messages.Runner#initializeSuiteDataStore}.
             * @memberof gauge.messages.Runner
             * @typedef InitializeSuiteDataStoreCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {gauge.messages.ExecutionStatusResponse} [response] ExecutionStatusResponse
             */

            /**
             * Calls InitializeSuiteDataStore.
             * @function initializeSuiteDataStore
             * @memberof gauge.messages.Runner
             * @instance
             * @param {gauge.messages.ISuiteDataStoreInitRequest} request SuiteDataStoreInitRequest message or plain object
             * @param {gauge.messages.Runner.InitializeSuiteDataStoreCallback} callback Node-style callback called with the error, if any, and ExecutionStatusResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Runner.prototype.initializeSuiteDataStore = function initializeSuiteDataStore(request, callback) {
                return this.rpcCall(initializeSuiteDataStore, $root.gauge.messages.SuiteDataStoreInitRequest, $root.gauge.messages.ExecutionStatusResponse, request, callback);
            }, "name", { value: "InitializeSuiteDataStore" });

            /**
             * Calls InitializeSuiteDataStore.
             * @function initializeSuiteDataStore
             * @memberof gauge.messages.Runner
             * @instance
             * @param {gauge.messages.ISuiteDataStoreInitRequest} request SuiteDataStoreInitRequest message or plain object
             * @returns {Promise<gauge.messages.ExecutionStatusResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link gauge.messages.Runner#startExecution}.
             * @memberof gauge.messages.Runner
             * @typedef StartExecutionCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {gauge.messages.ExecutionStatusResponse} [response] ExecutionStatusResponse
             */

            /**
             * Calls StartExecution.
             * @function startExecution
             * @memberof gauge.messages.Runner
             * @instance
             * @param {gauge.messages.IExecutionStartingRequest} request ExecutionStartingRequest message or plain object
             * @param {gauge.messages.Runner.StartExecutionCallback} callback Node-style callback called with the error, if any, and ExecutionStatusResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Runner.prototype.startExecution = function startExecution(request, callback) {
                return this.rpcCall(startExecution, $root.gauge.messages.ExecutionStartingRequest, $root.gauge.messages.ExecutionStatusResponse, request, callback);
            }, "name", { value: "StartExecution" });

            /**
             * Calls StartExecution.
             * @function startExecution
             * @memberof gauge.messages.Runner
             * @instance
             * @param {gauge.messages.IExecutionStartingRequest} request ExecutionStartingRequest message or plain object
             * @returns {Promise<gauge.messages.ExecutionStatusResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link gauge.messages.Runner#initializeSpecDataStore}.
             * @memberof gauge.messages.Runner
             * @typedef InitializeSpecDataStoreCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {gauge.messages.ExecutionStatusResponse} [response] ExecutionStatusResponse
             */

            /**
             * Calls InitializeSpecDataStore.
             * @function initializeSpecDataStore
             * @memberof gauge.messages.Runner
             * @instance
             * @param {gauge.messages.ISpecDataStoreInitRequest} request SpecDataStoreInitRequest message or plain object
             * @param {gauge.messages.Runner.InitializeSpecDataStoreCallback} callback Node-style callback called with the error, if any, and ExecutionStatusResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Runner.prototype.initializeSpecDataStore = function initializeSpecDataStore(request, callback) {
                return this.rpcCall(initializeSpecDataStore, $root.gauge.messages.SpecDataStoreInitRequest, $root.gauge.messages.ExecutionStatusResponse, request, callback);
            }, "name", { value: "InitializeSpecDataStore" });

            /**
             * Calls InitializeSpecDataStore.
             * @function initializeSpecDataStore
             * @memberof gauge.messages.Runner
             * @instance
             * @param {gauge.messages.ISpecDataStoreInitRequest} request SpecDataStoreInitRequest message or plain object
             * @returns {Promise<gauge.messages.ExecutionStatusResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link gauge.messages.Runner#startSpecExecution}.
             * @memberof gauge.messages.Runner
             * @typedef StartSpecExecutionCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {gauge.messages.ExecutionStatusResponse} [response] ExecutionStatusResponse
             */

            /**
             * Calls StartSpecExecution.
             * @function startSpecExecution
             * @memberof gauge.messages.Runner
             * @instance
             * @param {gauge.messages.ISpecExecutionStartingRequest} request SpecExecutionStartingRequest message or plain object
             * @param {gauge.messages.Runner.StartSpecExecutionCallback} callback Node-style callback called with the error, if any, and ExecutionStatusResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Runner.prototype.startSpecExecution = function startSpecExecution(request, callback) {
                return this.rpcCall(startSpecExecution, $root.gauge.messages.SpecExecutionStartingRequest, $root.gauge.messages.ExecutionStatusResponse, request, callback);
            }, "name", { value: "StartSpecExecution" });

            /**
             * Calls StartSpecExecution.
             * @function startSpecExecution
             * @memberof gauge.messages.Runner
             * @instance
             * @param {gauge.messages.ISpecExecutionStartingRequest} request SpecExecutionStartingRequest message or plain object
             * @returns {Promise<gauge.messages.ExecutionStatusResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link gauge.messages.Runner#initializeScenarioDataStore}.
             * @memberof gauge.messages.Runner
             * @typedef InitializeScenarioDataStoreCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {gauge.messages.ExecutionStatusResponse} [response] ExecutionStatusResponse
             */

            /**
             * Calls InitializeScenarioDataStore.
             * @function initializeScenarioDataStore
             * @memberof gauge.messages.Runner
             * @instance
             * @param {gauge.messages.IScenarioDataStoreInitRequest} request ScenarioDataStoreInitRequest message or plain object
             * @param {gauge.messages.Runner.InitializeScenarioDataStoreCallback} callback Node-style callback called with the error, if any, and ExecutionStatusResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Runner.prototype.initializeScenarioDataStore = function initializeScenarioDataStore(request, callback) {
                return this.rpcCall(initializeScenarioDataStore, $root.gauge.messages.ScenarioDataStoreInitRequest, $root.gauge.messages.ExecutionStatusResponse, request, callback);
            }, "name", { value: "InitializeScenarioDataStore" });

            /**
             * Calls InitializeScenarioDataStore.
             * @function initializeScenarioDataStore
             * @memberof gauge.messages.Runner
             * @instance
             * @param {gauge.messages.IScenarioDataStoreInitRequest} request ScenarioDataStoreInitRequest message or plain object
             * @returns {Promise<gauge.messages.ExecutionStatusResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link gauge.messages.Runner#startScenarioExecution}.
             * @memberof gauge.messages.Runner
             * @typedef StartScenarioExecutionCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {gauge.messages.ExecutionStatusResponse} [response] ExecutionStatusResponse
             */

            /**
             * Calls StartScenarioExecution.
             * @function startScenarioExecution
             * @memberof gauge.messages.Runner
             * @instance
             * @param {gauge.messages.IScenarioExecutionStartingRequest} request ScenarioExecutionStartingRequest message or plain object
             * @param {gauge.messages.Runner.StartScenarioExecutionCallback} callback Node-style callback called with the error, if any, and ExecutionStatusResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Runner.prototype.startScenarioExecution = function startScenarioExecution(request, callback) {
                return this.rpcCall(startScenarioExecution, $root.gauge.messages.ScenarioExecutionStartingRequest, $root.gauge.messages.ExecutionStatusResponse, request, callback);
            }, "name", { value: "StartScenarioExecution" });

            /**
             * Calls StartScenarioExecution.
             * @function startScenarioExecution
             * @memberof gauge.messages.Runner
             * @instance
             * @param {gauge.messages.IScenarioExecutionStartingRequest} request ScenarioExecutionStartingRequest message or plain object
             * @returns {Promise<gauge.messages.ExecutionStatusResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link gauge.messages.Runner#startStepExecution}.
             * @memberof gauge.messages.Runner
             * @typedef StartStepExecutionCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {gauge.messages.ExecutionStatusResponse} [response] ExecutionStatusResponse
             */

            /**
             * Calls StartStepExecution.
             * @function startStepExecution
             * @memberof gauge.messages.Runner
             * @instance
             * @param {gauge.messages.IStepExecutionStartingRequest} request StepExecutionStartingRequest message or plain object
             * @param {gauge.messages.Runner.StartStepExecutionCallback} callback Node-style callback called with the error, if any, and ExecutionStatusResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Runner.prototype.startStepExecution = function startStepExecution(request, callback) {
                return this.rpcCall(startStepExecution, $root.gauge.messages.StepExecutionStartingRequest, $root.gauge.messages.ExecutionStatusResponse, request, callback);
            }, "name", { value: "StartStepExecution" });

            /**
             * Calls StartStepExecution.
             * @function startStepExecution
             * @memberof gauge.messages.Runner
             * @instance
             * @param {gauge.messages.IStepExecutionStartingRequest} request StepExecutionStartingRequest message or plain object
             * @returns {Promise<gauge.messages.ExecutionStatusResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link gauge.messages.Runner#executeStep}.
             * @memberof gauge.messages.Runner
             * @typedef ExecuteStepCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {gauge.messages.ExecutionStatusResponse} [response] ExecutionStatusResponse
             */

            /**
             * Calls ExecuteStep.
             * @function executeStep
             * @memberof gauge.messages.Runner
             * @instance
             * @param {gauge.messages.IExecuteStepRequest} request ExecuteStepRequest message or plain object
             * @param {gauge.messages.Runner.ExecuteStepCallback} callback Node-style callback called with the error, if any, and ExecutionStatusResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Runner.prototype.executeStep = function executeStep(request, callback) {
                return this.rpcCall(executeStep, $root.gauge.messages.ExecuteStepRequest, $root.gauge.messages.ExecutionStatusResponse, request, callback);
            }, "name", { value: "ExecuteStep" });

            /**
             * Calls ExecuteStep.
             * @function executeStep
             * @memberof gauge.messages.Runner
             * @instance
             * @param {gauge.messages.IExecuteStepRequest} request ExecuteStepRequest message or plain object
             * @returns {Promise<gauge.messages.ExecutionStatusResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link gauge.messages.Runner#finishStepExecution}.
             * @memberof gauge.messages.Runner
             * @typedef FinishStepExecutionCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {gauge.messages.ExecutionStatusResponse} [response] ExecutionStatusResponse
             */

            /**
             * Calls FinishStepExecution.
             * @function finishStepExecution
             * @memberof gauge.messages.Runner
             * @instance
             * @param {gauge.messages.IStepExecutionEndingRequest} request StepExecutionEndingRequest message or plain object
             * @param {gauge.messages.Runner.FinishStepExecutionCallback} callback Node-style callback called with the error, if any, and ExecutionStatusResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Runner.prototype.finishStepExecution = function finishStepExecution(request, callback) {
                return this.rpcCall(finishStepExecution, $root.gauge.messages.StepExecutionEndingRequest, $root.gauge.messages.ExecutionStatusResponse, request, callback);
            }, "name", { value: "FinishStepExecution" });

            /**
             * Calls FinishStepExecution.
             * @function finishStepExecution
             * @memberof gauge.messages.Runner
             * @instance
             * @param {gauge.messages.IStepExecutionEndingRequest} request StepExecutionEndingRequest message or plain object
             * @returns {Promise<gauge.messages.ExecutionStatusResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link gauge.messages.Runner#finishScenarioExecution}.
             * @memberof gauge.messages.Runner
             * @typedef FinishScenarioExecutionCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {gauge.messages.ExecutionStatusResponse} [response] ExecutionStatusResponse
             */

            /**
             * Calls FinishScenarioExecution.
             * @function finishScenarioExecution
             * @memberof gauge.messages.Runner
             * @instance
             * @param {gauge.messages.IScenarioExecutionEndingRequest} request ScenarioExecutionEndingRequest message or plain object
             * @param {gauge.messages.Runner.FinishScenarioExecutionCallback} callback Node-style callback called with the error, if any, and ExecutionStatusResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Runner.prototype.finishScenarioExecution = function finishScenarioExecution(request, callback) {
                return this.rpcCall(finishScenarioExecution, $root.gauge.messages.ScenarioExecutionEndingRequest, $root.gauge.messages.ExecutionStatusResponse, request, callback);
            }, "name", { value: "FinishScenarioExecution" });

            /**
             * Calls FinishScenarioExecution.
             * @function finishScenarioExecution
             * @memberof gauge.messages.Runner
             * @instance
             * @param {gauge.messages.IScenarioExecutionEndingRequest} request ScenarioExecutionEndingRequest message or plain object
             * @returns {Promise<gauge.messages.ExecutionStatusResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link gauge.messages.Runner#finishSpecExecution}.
             * @memberof gauge.messages.Runner
             * @typedef FinishSpecExecutionCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {gauge.messages.ExecutionStatusResponse} [response] ExecutionStatusResponse
             */

            /**
             * Calls FinishSpecExecution.
             * @function finishSpecExecution
             * @memberof gauge.messages.Runner
             * @instance
             * @param {gauge.messages.ISpecExecutionEndingRequest} request SpecExecutionEndingRequest message or plain object
             * @param {gauge.messages.Runner.FinishSpecExecutionCallback} callback Node-style callback called with the error, if any, and ExecutionStatusResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Runner.prototype.finishSpecExecution = function finishSpecExecution(request, callback) {
                return this.rpcCall(finishSpecExecution, $root.gauge.messages.SpecExecutionEndingRequest, $root.gauge.messages.ExecutionStatusResponse, request, callback);
            }, "name", { value: "FinishSpecExecution" });

            /**
             * Calls FinishSpecExecution.
             * @function finishSpecExecution
             * @memberof gauge.messages.Runner
             * @instance
             * @param {gauge.messages.ISpecExecutionEndingRequest} request SpecExecutionEndingRequest message or plain object
             * @returns {Promise<gauge.messages.ExecutionStatusResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link gauge.messages.Runner#finishExecution}.
             * @memberof gauge.messages.Runner
             * @typedef FinishExecutionCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {gauge.messages.ExecutionStatusResponse} [response] ExecutionStatusResponse
             */

            /**
             * Calls FinishExecution.
             * @function finishExecution
             * @memberof gauge.messages.Runner
             * @instance
             * @param {gauge.messages.IExecutionEndingRequest} request ExecutionEndingRequest message or plain object
             * @param {gauge.messages.Runner.FinishExecutionCallback} callback Node-style callback called with the error, if any, and ExecutionStatusResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Runner.prototype.finishExecution = function finishExecution(request, callback) {
                return this.rpcCall(finishExecution, $root.gauge.messages.ExecutionEndingRequest, $root.gauge.messages.ExecutionStatusResponse, request, callback);
            }, "name", { value: "FinishExecution" });

            /**
             * Calls FinishExecution.
             * @function finishExecution
             * @memberof gauge.messages.Runner
             * @instance
             * @param {gauge.messages.IExecutionEndingRequest} request ExecutionEndingRequest message or plain object
             * @returns {Promise<gauge.messages.ExecutionStatusResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link gauge.messages.Runner#cacheFile}.
             * @memberof gauge.messages.Runner
             * @typedef CacheFileCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {gauge.messages.Empty} [response] Empty
             */

            /**
             * Calls CacheFile.
             * @function cacheFile
             * @memberof gauge.messages.Runner
             * @instance
             * @param {gauge.messages.ICacheFileRequest} request CacheFileRequest message or plain object
             * @param {gauge.messages.Runner.CacheFileCallback} callback Node-style callback called with the error, if any, and Empty
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Runner.prototype.cacheFile = function cacheFile(request, callback) {
                return this.rpcCall(cacheFile, $root.gauge.messages.CacheFileRequest, $root.gauge.messages.Empty, request, callback);
            }, "name", { value: "CacheFile" });

            /**
             * Calls CacheFile.
             * @function cacheFile
             * @memberof gauge.messages.Runner
             * @instance
             * @param {gauge.messages.ICacheFileRequest} request CacheFileRequest message or plain object
             * @returns {Promise<gauge.messages.Empty>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link gauge.messages.Runner#getStepName}.
             * @memberof gauge.messages.Runner
             * @typedef GetStepNameCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {gauge.messages.StepNameResponse} [response] StepNameResponse
             */

            /**
             * Calls GetStepName.
             * @function getStepName
             * @memberof gauge.messages.Runner
             * @instance
             * @param {gauge.messages.IStepNameRequest} request StepNameRequest message or plain object
             * @param {gauge.messages.Runner.GetStepNameCallback} callback Node-style callback called with the error, if any, and StepNameResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Runner.prototype.getStepName = function getStepName(request, callback) {
                return this.rpcCall(getStepName, $root.gauge.messages.StepNameRequest, $root.gauge.messages.StepNameResponse, request, callback);
            }, "name", { value: "GetStepName" });

            /**
             * Calls GetStepName.
             * @function getStepName
             * @memberof gauge.messages.Runner
             * @instance
             * @param {gauge.messages.IStepNameRequest} request StepNameRequest message or plain object
             * @returns {Promise<gauge.messages.StepNameResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link gauge.messages.Runner#getGlobPatterns}.
             * @memberof gauge.messages.Runner
             * @typedef GetGlobPatternsCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {gauge.messages.ImplementationFileGlobPatternResponse} [response] ImplementationFileGlobPatternResponse
             */

            /**
             * Calls GetGlobPatterns.
             * @function getGlobPatterns
             * @memberof gauge.messages.Runner
             * @instance
             * @param {gauge.messages.IEmpty} request Empty message or plain object
             * @param {gauge.messages.Runner.GetGlobPatternsCallback} callback Node-style callback called with the error, if any, and ImplementationFileGlobPatternResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Runner.prototype.getGlobPatterns = function getGlobPatterns(request, callback) {
                return this.rpcCall(getGlobPatterns, $root.gauge.messages.Empty, $root.gauge.messages.ImplementationFileGlobPatternResponse, request, callback);
            }, "name", { value: "GetGlobPatterns" });

            /**
             * Calls GetGlobPatterns.
             * @function getGlobPatterns
             * @memberof gauge.messages.Runner
             * @instance
             * @param {gauge.messages.IEmpty} request Empty message or plain object
             * @returns {Promise<gauge.messages.ImplementationFileGlobPatternResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link gauge.messages.Runner#getStepNames}.
             * @memberof gauge.messages.Runner
             * @typedef GetStepNamesCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {gauge.messages.StepNamesResponse} [response] StepNamesResponse
             */

            /**
             * Calls GetStepNames.
             * @function getStepNames
             * @memberof gauge.messages.Runner
             * @instance
             * @param {gauge.messages.IStepNamesRequest} request StepNamesRequest message or plain object
             * @param {gauge.messages.Runner.GetStepNamesCallback} callback Node-style callback called with the error, if any, and StepNamesResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Runner.prototype.getStepNames = function getStepNames(request, callback) {
                return this.rpcCall(getStepNames, $root.gauge.messages.StepNamesRequest, $root.gauge.messages.StepNamesResponse, request, callback);
            }, "name", { value: "GetStepNames" });

            /**
             * Calls GetStepNames.
             * @function getStepNames
             * @memberof gauge.messages.Runner
             * @instance
             * @param {gauge.messages.IStepNamesRequest} request StepNamesRequest message or plain object
             * @returns {Promise<gauge.messages.StepNamesResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link gauge.messages.Runner#getStepPositions}.
             * @memberof gauge.messages.Runner
             * @typedef GetStepPositionsCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {gauge.messages.StepPositionsResponse} [response] StepPositionsResponse
             */

            /**
             * Calls GetStepPositions.
             * @function getStepPositions
             * @memberof gauge.messages.Runner
             * @instance
             * @param {gauge.messages.IStepPositionsRequest} request StepPositionsRequest message or plain object
             * @param {gauge.messages.Runner.GetStepPositionsCallback} callback Node-style callback called with the error, if any, and StepPositionsResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Runner.prototype.getStepPositions = function getStepPositions(request, callback) {
                return this.rpcCall(getStepPositions, $root.gauge.messages.StepPositionsRequest, $root.gauge.messages.StepPositionsResponse, request, callback);
            }, "name", { value: "GetStepPositions" });

            /**
             * Calls GetStepPositions.
             * @function getStepPositions
             * @memberof gauge.messages.Runner
             * @instance
             * @param {gauge.messages.IStepPositionsRequest} request StepPositionsRequest message or plain object
             * @returns {Promise<gauge.messages.StepPositionsResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link gauge.messages.Runner#getImplementationFiles}.
             * @memberof gauge.messages.Runner
             * @typedef GetImplementationFilesCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {gauge.messages.ImplementationFileListResponse} [response] ImplementationFileListResponse
             */

            /**
             * Calls GetImplementationFiles.
             * @function getImplementationFiles
             * @memberof gauge.messages.Runner
             * @instance
             * @param {gauge.messages.IEmpty} request Empty message or plain object
             * @param {gauge.messages.Runner.GetImplementationFilesCallback} callback Node-style callback called with the error, if any, and ImplementationFileListResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Runner.prototype.getImplementationFiles = function getImplementationFiles(request, callback) {
                return this.rpcCall(getImplementationFiles, $root.gauge.messages.Empty, $root.gauge.messages.ImplementationFileListResponse, request, callback);
            }, "name", { value: "GetImplementationFiles" });

            /**
             * Calls GetImplementationFiles.
             * @function getImplementationFiles
             * @memberof gauge.messages.Runner
             * @instance
             * @param {gauge.messages.IEmpty} request Empty message or plain object
             * @returns {Promise<gauge.messages.ImplementationFileListResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link gauge.messages.Runner#implementStub}.
             * @memberof gauge.messages.Runner
             * @typedef ImplementStubCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {gauge.messages.FileDiff} [response] FileDiff
             */

            /**
             * Calls ImplementStub.
             * @function implementStub
             * @memberof gauge.messages.Runner
             * @instance
             * @param {gauge.messages.IStubImplementationCodeRequest} request StubImplementationCodeRequest message or plain object
             * @param {gauge.messages.Runner.ImplementStubCallback} callback Node-style callback called with the error, if any, and FileDiff
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Runner.prototype.implementStub = function implementStub(request, callback) {
                return this.rpcCall(implementStub, $root.gauge.messages.StubImplementationCodeRequest, $root.gauge.messages.FileDiff, request, callback);
            }, "name", { value: "ImplementStub" });

            /**
             * Calls ImplementStub.
             * @function implementStub
             * @memberof gauge.messages.Runner
             * @instance
             * @param {gauge.messages.IStubImplementationCodeRequest} request StubImplementationCodeRequest message or plain object
             * @returns {Promise<gauge.messages.FileDiff>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link gauge.messages.Runner#refactor}.
             * @memberof gauge.messages.Runner
             * @typedef RefactorCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {gauge.messages.RefactorResponse} [response] RefactorResponse
             */

            /**
             * Calls Refactor.
             * @function refactor
             * @memberof gauge.messages.Runner
             * @instance
             * @param {gauge.messages.IRefactorRequest} request RefactorRequest message or plain object
             * @param {gauge.messages.Runner.RefactorCallback} callback Node-style callback called with the error, if any, and RefactorResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Runner.prototype.refactor = function refactor(request, callback) {
                return this.rpcCall(refactor, $root.gauge.messages.RefactorRequest, $root.gauge.messages.RefactorResponse, request, callback);
            }, "name", { value: "Refactor" });

            /**
             * Calls Refactor.
             * @function refactor
             * @memberof gauge.messages.Runner
             * @instance
             * @param {gauge.messages.IRefactorRequest} request RefactorRequest message or plain object
             * @returns {Promise<gauge.messages.RefactorResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link gauge.messages.Runner#kill}.
             * @memberof gauge.messages.Runner
             * @typedef KillCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {gauge.messages.Empty} [response] Empty
             */

            /**
             * Calls Kill.
             * @function kill
             * @memberof gauge.messages.Runner
             * @instance
             * @param {gauge.messages.IKillProcessRequest} request KillProcessRequest message or plain object
             * @param {gauge.messages.Runner.KillCallback} callback Node-style callback called with the error, if any, and Empty
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Runner.prototype.kill = function kill(request, callback) {
                return this.rpcCall(kill, $root.gauge.messages.KillProcessRequest, $root.gauge.messages.Empty, request, callback);
            }, "name", { value: "Kill" });

            /**
             * Calls Kill.
             * @function kill
             * @memberof gauge.messages.Runner
             * @instance
             * @param {gauge.messages.IKillProcessRequest} request KillProcessRequest message or plain object
             * @returns {Promise<gauge.messages.Empty>} Promise
             * @variation 2
             */

            return Runner;
        })();

        messages.Reporter = (function() {

            /**
             * Constructs a new Reporter service.
             * @memberof gauge.messages
             * @classdesc Represents a Reporter
             * @extends $protobuf.rpc.Service
             * @constructor
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             */
            function Reporter(rpcImpl, requestDelimited, responseDelimited) {
                $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
            }

            (Reporter.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = Reporter;

            /**
             * Creates new Reporter service using the specified rpc implementation.
             * @function create
             * @memberof gauge.messages.Reporter
             * @static
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             * @returns {Reporter} RPC service. Useful where requests and/or responses are streamed.
             */
            Reporter.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                return new this(rpcImpl, requestDelimited, responseDelimited);
            };

            /**
             * Callback as used by {@link gauge.messages.Reporter#notifyExecutionStarting}.
             * @memberof gauge.messages.Reporter
             * @typedef NotifyExecutionStartingCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {gauge.messages.Empty} [response] Empty
             */

            /**
             * Calls NotifyExecutionStarting.
             * @function notifyExecutionStarting
             * @memberof gauge.messages.Reporter
             * @instance
             * @param {gauge.messages.IExecutionStartingRequest} request ExecutionStartingRequest message or plain object
             * @param {gauge.messages.Reporter.NotifyExecutionStartingCallback} callback Node-style callback called with the error, if any, and Empty
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Reporter.prototype.notifyExecutionStarting = function notifyExecutionStarting(request, callback) {
                return this.rpcCall(notifyExecutionStarting, $root.gauge.messages.ExecutionStartingRequest, $root.gauge.messages.Empty, request, callback);
            }, "name", { value: "NotifyExecutionStarting" });

            /**
             * Calls NotifyExecutionStarting.
             * @function notifyExecutionStarting
             * @memberof gauge.messages.Reporter
             * @instance
             * @param {gauge.messages.IExecutionStartingRequest} request ExecutionStartingRequest message or plain object
             * @returns {Promise<gauge.messages.Empty>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link gauge.messages.Reporter#notifySpecExecutionStarting}.
             * @memberof gauge.messages.Reporter
             * @typedef NotifySpecExecutionStartingCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {gauge.messages.Empty} [response] Empty
             */

            /**
             * Calls NotifySpecExecutionStarting.
             * @function notifySpecExecutionStarting
             * @memberof gauge.messages.Reporter
             * @instance
             * @param {gauge.messages.ISpecExecutionStartingRequest} request SpecExecutionStartingRequest message or plain object
             * @param {gauge.messages.Reporter.NotifySpecExecutionStartingCallback} callback Node-style callback called with the error, if any, and Empty
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Reporter.prototype.notifySpecExecutionStarting = function notifySpecExecutionStarting(request, callback) {
                return this.rpcCall(notifySpecExecutionStarting, $root.gauge.messages.SpecExecutionStartingRequest, $root.gauge.messages.Empty, request, callback);
            }, "name", { value: "NotifySpecExecutionStarting" });

            /**
             * Calls NotifySpecExecutionStarting.
             * @function notifySpecExecutionStarting
             * @memberof gauge.messages.Reporter
             * @instance
             * @param {gauge.messages.ISpecExecutionStartingRequest} request SpecExecutionStartingRequest message or plain object
             * @returns {Promise<gauge.messages.Empty>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link gauge.messages.Reporter#notifyScenarioExecutionStarting}.
             * @memberof gauge.messages.Reporter
             * @typedef NotifyScenarioExecutionStartingCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {gauge.messages.Empty} [response] Empty
             */

            /**
             * Calls NotifyScenarioExecutionStarting.
             * @function notifyScenarioExecutionStarting
             * @memberof gauge.messages.Reporter
             * @instance
             * @param {gauge.messages.IScenarioExecutionStartingRequest} request ScenarioExecutionStartingRequest message or plain object
             * @param {gauge.messages.Reporter.NotifyScenarioExecutionStartingCallback} callback Node-style callback called with the error, if any, and Empty
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Reporter.prototype.notifyScenarioExecutionStarting = function notifyScenarioExecutionStarting(request, callback) {
                return this.rpcCall(notifyScenarioExecutionStarting, $root.gauge.messages.ScenarioExecutionStartingRequest, $root.gauge.messages.Empty, request, callback);
            }, "name", { value: "NotifyScenarioExecutionStarting" });

            /**
             * Calls NotifyScenarioExecutionStarting.
             * @function notifyScenarioExecutionStarting
             * @memberof gauge.messages.Reporter
             * @instance
             * @param {gauge.messages.IScenarioExecutionStartingRequest} request ScenarioExecutionStartingRequest message or plain object
             * @returns {Promise<gauge.messages.Empty>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link gauge.messages.Reporter#notifyStepExecutionStarting}.
             * @memberof gauge.messages.Reporter
             * @typedef NotifyStepExecutionStartingCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {gauge.messages.Empty} [response] Empty
             */

            /**
             * Calls NotifyStepExecutionStarting.
             * @function notifyStepExecutionStarting
             * @memberof gauge.messages.Reporter
             * @instance
             * @param {gauge.messages.IStepExecutionStartingRequest} request StepExecutionStartingRequest message or plain object
             * @param {gauge.messages.Reporter.NotifyStepExecutionStartingCallback} callback Node-style callback called with the error, if any, and Empty
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Reporter.prototype.notifyStepExecutionStarting = function notifyStepExecutionStarting(request, callback) {
                return this.rpcCall(notifyStepExecutionStarting, $root.gauge.messages.StepExecutionStartingRequest, $root.gauge.messages.Empty, request, callback);
            }, "name", { value: "NotifyStepExecutionStarting" });

            /**
             * Calls NotifyStepExecutionStarting.
             * @function notifyStepExecutionStarting
             * @memberof gauge.messages.Reporter
             * @instance
             * @param {gauge.messages.IStepExecutionStartingRequest} request StepExecutionStartingRequest message or plain object
             * @returns {Promise<gauge.messages.Empty>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link gauge.messages.Reporter#notifyStepExecutionEnding}.
             * @memberof gauge.messages.Reporter
             * @typedef NotifyStepExecutionEndingCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {gauge.messages.Empty} [response] Empty
             */

            /**
             * Calls NotifyStepExecutionEnding.
             * @function notifyStepExecutionEnding
             * @memberof gauge.messages.Reporter
             * @instance
             * @param {gauge.messages.IStepExecutionEndingRequest} request StepExecutionEndingRequest message or plain object
             * @param {gauge.messages.Reporter.NotifyStepExecutionEndingCallback} callback Node-style callback called with the error, if any, and Empty
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Reporter.prototype.notifyStepExecutionEnding = function notifyStepExecutionEnding(request, callback) {
                return this.rpcCall(notifyStepExecutionEnding, $root.gauge.messages.StepExecutionEndingRequest, $root.gauge.messages.Empty, request, callback);
            }, "name", { value: "NotifyStepExecutionEnding" });

            /**
             * Calls NotifyStepExecutionEnding.
             * @function notifyStepExecutionEnding
             * @memberof gauge.messages.Reporter
             * @instance
             * @param {gauge.messages.IStepExecutionEndingRequest} request StepExecutionEndingRequest message or plain object
             * @returns {Promise<gauge.messages.Empty>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link gauge.messages.Reporter#notifyScenarioExecutionEnding}.
             * @memberof gauge.messages.Reporter
             * @typedef NotifyScenarioExecutionEndingCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {gauge.messages.Empty} [response] Empty
             */

            /**
             * Calls NotifyScenarioExecutionEnding.
             * @function notifyScenarioExecutionEnding
             * @memberof gauge.messages.Reporter
             * @instance
             * @param {gauge.messages.IScenarioExecutionEndingRequest} request ScenarioExecutionEndingRequest message or plain object
             * @param {gauge.messages.Reporter.NotifyScenarioExecutionEndingCallback} callback Node-style callback called with the error, if any, and Empty
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Reporter.prototype.notifyScenarioExecutionEnding = function notifyScenarioExecutionEnding(request, callback) {
                return this.rpcCall(notifyScenarioExecutionEnding, $root.gauge.messages.ScenarioExecutionEndingRequest, $root.gauge.messages.Empty, request, callback);
            }, "name", { value: "NotifyScenarioExecutionEnding" });

            /**
             * Calls NotifyScenarioExecutionEnding.
             * @function notifyScenarioExecutionEnding
             * @memberof gauge.messages.Reporter
             * @instance
             * @param {gauge.messages.IScenarioExecutionEndingRequest} request ScenarioExecutionEndingRequest message or plain object
             * @returns {Promise<gauge.messages.Empty>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link gauge.messages.Reporter#notifySpecExecutionEnding}.
             * @memberof gauge.messages.Reporter
             * @typedef NotifySpecExecutionEndingCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {gauge.messages.Empty} [response] Empty
             */

            /**
             * Calls NotifySpecExecutionEnding.
             * @function notifySpecExecutionEnding
             * @memberof gauge.messages.Reporter
             * @instance
             * @param {gauge.messages.ISpecExecutionEndingRequest} request SpecExecutionEndingRequest message or plain object
             * @param {gauge.messages.Reporter.NotifySpecExecutionEndingCallback} callback Node-style callback called with the error, if any, and Empty
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Reporter.prototype.notifySpecExecutionEnding = function notifySpecExecutionEnding(request, callback) {
                return this.rpcCall(notifySpecExecutionEnding, $root.gauge.messages.SpecExecutionEndingRequest, $root.gauge.messages.Empty, request, callback);
            }, "name", { value: "NotifySpecExecutionEnding" });

            /**
             * Calls NotifySpecExecutionEnding.
             * @function notifySpecExecutionEnding
             * @memberof gauge.messages.Reporter
             * @instance
             * @param {gauge.messages.ISpecExecutionEndingRequest} request SpecExecutionEndingRequest message or plain object
             * @returns {Promise<gauge.messages.Empty>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link gauge.messages.Reporter#notifyExecutionEnding}.
             * @memberof gauge.messages.Reporter
             * @typedef NotifyExecutionEndingCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {gauge.messages.Empty} [response] Empty
             */

            /**
             * Calls NotifyExecutionEnding.
             * @function notifyExecutionEnding
             * @memberof gauge.messages.Reporter
             * @instance
             * @param {gauge.messages.IExecutionEndingRequest} request ExecutionEndingRequest message or plain object
             * @param {gauge.messages.Reporter.NotifyExecutionEndingCallback} callback Node-style callback called with the error, if any, and Empty
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Reporter.prototype.notifyExecutionEnding = function notifyExecutionEnding(request, callback) {
                return this.rpcCall(notifyExecutionEnding, $root.gauge.messages.ExecutionEndingRequest, $root.gauge.messages.Empty, request, callback);
            }, "name", { value: "NotifyExecutionEnding" });

            /**
             * Calls NotifyExecutionEnding.
             * @function notifyExecutionEnding
             * @memberof gauge.messages.Reporter
             * @instance
             * @param {gauge.messages.IExecutionEndingRequest} request ExecutionEndingRequest message or plain object
             * @returns {Promise<gauge.messages.Empty>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link gauge.messages.Reporter#notifySuiteResult}.
             * @memberof gauge.messages.Reporter
             * @typedef NotifySuiteResultCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {gauge.messages.Empty} [response] Empty
             */

            /**
             * Calls NotifySuiteResult.
             * @function notifySuiteResult
             * @memberof gauge.messages.Reporter
             * @instance
             * @param {gauge.messages.ISuiteExecutionResult} request SuiteExecutionResult message or plain object
             * @param {gauge.messages.Reporter.NotifySuiteResultCallback} callback Node-style callback called with the error, if any, and Empty
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Reporter.prototype.notifySuiteResult = function notifySuiteResult(request, callback) {
                return this.rpcCall(notifySuiteResult, $root.gauge.messages.SuiteExecutionResult, $root.gauge.messages.Empty, request, callback);
            }, "name", { value: "NotifySuiteResult" });

            /**
             * Calls NotifySuiteResult.
             * @function notifySuiteResult
             * @memberof gauge.messages.Reporter
             * @instance
             * @param {gauge.messages.ISuiteExecutionResult} request SuiteExecutionResult message or plain object
             * @returns {Promise<gauge.messages.Empty>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link gauge.messages.Reporter#kill}.
             * @memberof gauge.messages.Reporter
             * @typedef KillCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {gauge.messages.Empty} [response] Empty
             */

            /**
             * Calls Kill.
             * @function kill
             * @memberof gauge.messages.Reporter
             * @instance
             * @param {gauge.messages.IKillProcessRequest} request KillProcessRequest message or plain object
             * @param {gauge.messages.Reporter.KillCallback} callback Node-style callback called with the error, if any, and Empty
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Reporter.prototype.kill = function kill(request, callback) {
                return this.rpcCall(kill, $root.gauge.messages.KillProcessRequest, $root.gauge.messages.Empty, request, callback);
            }, "name", { value: "Kill" });

            /**
             * Calls Kill.
             * @function kill
             * @memberof gauge.messages.Reporter
             * @instance
             * @param {gauge.messages.IKillProcessRequest} request KillProcessRequest message or plain object
             * @returns {Promise<gauge.messages.Empty>} Promise
             * @variation 2
             */

            return Reporter;
        })();

        messages.Documenter = (function() {

            /**
             * Constructs a new Documenter service.
             * @memberof gauge.messages
             * @classdesc Represents a Documenter
             * @extends $protobuf.rpc.Service
             * @constructor
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             */
            function Documenter(rpcImpl, requestDelimited, responseDelimited) {
                $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
            }

            (Documenter.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = Documenter;

            /**
             * Creates new Documenter service using the specified rpc implementation.
             * @function create
             * @memberof gauge.messages.Documenter
             * @static
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             * @returns {Documenter} RPC service. Useful where requests and/or responses are streamed.
             */
            Documenter.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                return new this(rpcImpl, requestDelimited, responseDelimited);
            };

            /**
             * Callback as used by {@link gauge.messages.Documenter#generateDocs}.
             * @memberof gauge.messages.Documenter
             * @typedef GenerateDocsCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {gauge.messages.Empty} [response] Empty
             */

            /**
             * Calls GenerateDocs.
             * @function generateDocs
             * @memberof gauge.messages.Documenter
             * @instance
             * @param {gauge.messages.ISpecDetails} request SpecDetails message or plain object
             * @param {gauge.messages.Documenter.GenerateDocsCallback} callback Node-style callback called with the error, if any, and Empty
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Documenter.prototype.generateDocs = function generateDocs(request, callback) {
                return this.rpcCall(generateDocs, $root.gauge.messages.SpecDetails, $root.gauge.messages.Empty, request, callback);
            }, "name", { value: "GenerateDocs" });

            /**
             * Calls GenerateDocs.
             * @function generateDocs
             * @memberof gauge.messages.Documenter
             * @instance
             * @param {gauge.messages.ISpecDetails} request SpecDetails message or plain object
             * @returns {Promise<gauge.messages.Empty>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link gauge.messages.Documenter#kill}.
             * @memberof gauge.messages.Documenter
             * @typedef KillCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {gauge.messages.Empty} [response] Empty
             */

            /**
             * Calls Kill.
             * @function kill
             * @memberof gauge.messages.Documenter
             * @instance
             * @param {gauge.messages.IKillProcessRequest} request KillProcessRequest message or plain object
             * @param {gauge.messages.Documenter.KillCallback} callback Node-style callback called with the error, if any, and Empty
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Documenter.prototype.kill = function kill(request, callback) {
                return this.rpcCall(kill, $root.gauge.messages.KillProcessRequest, $root.gauge.messages.Empty, request, callback);
            }, "name", { value: "Kill" });

            /**
             * Calls Kill.
             * @function kill
             * @memberof gauge.messages.Documenter
             * @instance
             * @param {gauge.messages.IKillProcessRequest} request KillProcessRequest message or plain object
             * @returns {Promise<gauge.messages.Empty>} Promise
             * @variation 2
             */

            return Documenter;
        })();

        return messages;
    })();

    return gauge;
})();

module.exports = $root;
